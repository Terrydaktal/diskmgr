#!/usr/bin/env python3
import cmd
import subprocess
import os
import sys
import shlex
import csv
import json
import time
import argparse
import random
import re
import shutil
from pathlib import Path

# Configuration
MAP_FILENAME = 'diskmap.tsv'
PASSGEN_BIN = 'passgen'

# ANSI Colors
class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def log(msg, level='INFO'):
    if level == 'ERROR':
        print(f"{Colors.FAIL}ERROR: {msg}{Colors.ENDC}", file=sys.stderr)
    elif level == 'WARN':
        print(f"{Colors.WARNING}WARNING: {msg}{Colors.ENDC}", file=sys.stderr)
    else:
        print(f"{Colors.OKBLUE}diskmgr: {msg}{Colors.ENDC}")

def run_command(command, check=True, input_str=None, capture_output=True, sudo=False):
    if sudo:
        command = ['sudo'] + command
    
    try:
        result = subprocess.run(
            command,
            input=input_str,
            text=True,
            check=check,
            stdout=subprocess.PIPE if capture_output else None,
            stderr=subprocess.PIPE if capture_output else None
        )
        return result
    except subprocess.CalledProcessError as e:
        if check:
            log(f"Command failed: {' '.join(command)}", 'ERROR')
            if e.stderr:
                log(e.stderr.strip(), 'ERROR')
            raise
        return e

def _split_nonempty_lines(s):
    if not s:
        return []
    out = []
    for line in str(s).splitlines():
        line = line.strip()
        if line and line not in out:
            out.append(line)
    return out

def find_mount_targets(source):
    """
    Return a list of mount TARGETs for a given SOURCE.

    Notes:
    - A single filesystem can be mounted at multiple targets; findmnt will then
      return multiple lines. Callers must not treat stdout as a single path.
    - We resolve the source to a real path so /dev/mapper/<name> and /dev/dm-X
      match the same mount.
    """
    src_real = os.path.realpath(source)
    res = run_command(['findmnt', '-rn', '-S', src_real, '-o', 'TARGET'], check=False)
    if getattr(res, 'returncode', 1) != 0:
        return []
    return _split_nonempty_lines(getattr(res, 'stdout', ''))

def cleanup_mountpoint_dir(mountpoint):
    """
    Best-effort cleanup of a mountpoint directory after unmount.

    Only attempts removal for mountpoints under /media/$USER/ and only if the
    directory is no longer a mount target. Uses rmdir (so it only removes empty
    directories) to avoid deleting real data.
    """
    if not mountpoint:
        return

    user = os.environ.get('USER', 'root')
    media_root = os.path.realpath(f"/media/{user}")
    mp_real = os.path.realpath(mountpoint)
    if not (mp_real == media_root or mp_real.startswith(media_root + os.sep)):
        return

    # Still mounted? Don't touch it.
    if run_command(['findmnt', '-rn', '-M', mountpoint], check=False).returncode == 0:
        return

    res = run_command(['rmdir', mountpoint], sudo=True, check=False)
    if getattr(res, 'returncode', 1) == 0:
        log(f"Removed mountpoint directory {mountpoint}")

def _sysfs_block_name(dev_path):
    """Return kernel block name (e.g. sda2, nvme0n1p1, dm-0) for a /dev path."""
    return os.path.basename(os.path.realpath(dev_path))

def _sysfs_to_parent_disk_name(block_name, max_hops=16):
    """
    Best-effort: resolve a block device name to its underlying whole-disk name.

    - Partitions: sda2 -> sda, nvme0n1p1 -> nvme0n1
    - dm devices: dm-0 -> first slave (often sda2), then keep resolving
    """
    cur = block_name
    for _ in range(max_hops):
        sys_path = f"/sys/class/block/{cur}"
        if not os.path.exists(sys_path):
            break

        # If it's a device-mapper node, walk down to its first slave.
        if cur.startswith("dm-"):
            slaves_dir = os.path.join(sys_path, "slaves")
            try:
                slaves = sorted(os.listdir(slaves_dir)) if os.path.isdir(slaves_dir) else []
            except Exception:
                slaves = []
            if slaves:
                cur = slaves[0]
                continue
            break

        # If it's a partition, its parent is the directory above in sysfs.
        if os.path.exists(os.path.join(sys_path, "partition")):
            parent = os.path.basename(os.path.realpath(os.path.join(sys_path, "..")))
            if parent and parent != cur:
                cur = parent
                continue
            break

        # Already a whole-disk node (or at least not a partition we can detect).
        break

    return cur

def _merge_intervals(intervals):
    """Merge half-open intervals [(start, end), ...] in bytes."""
    if not intervals:
        return []
    intervals = sorted(intervals)
    out = [list(intervals[0])]
    for s, e in intervals[1:]:
        if s <= out[-1][1]:
            out[-1][1] = max(out[-1][1], e)
        else:
            out.append([s, e])
    return [(s, e) for s, e in out]

def _subtract_intervals(a, b):
    """Return intervals in a that are not covered by b. Inputs must be merged/sorted."""
    if not a:
        return []
    if not b:
        return list(a)
    out = []
    j = 0
    for s, e in a:
        cur = s
        while j < len(b) and b[j][1] <= cur:
            j += 1
        k = j
        while k < len(b) and b[k][0] < e:
            bs, be = b[k]
            if bs > cur:
                out.append((cur, min(bs, e)))
            cur = max(cur, be)
            if cur >= e:
                break
            k += 1
        if cur < e:
            out.append((cur, e))
    return out

def _parse_ddrescue_bad_intervals(map_path, bad_status='-'):
    """
    Parse a ddrescue mapfile and return merged byte intervals for a status character.

    ddrescue map lines are typically: <start_hex> <size_hex> <status_char>
    This parser is intentionally minimal and tolerant.
    """
    intervals = []
    try:
        with open(map_path, 'r', encoding='utf-8', errors='replace') as f:
            for raw in f:
                line = raw.strip()
                if not line or line.startswith('#'):
                    continue
                parts = line.split()
                if len(parts) < 3:
                    continue
                a, b, st = parts[0], parts[1], parts[2]
                if not (a.startswith('0x') and b.startswith('0x') and st):
                    continue
                if st[0] != bad_status:
                    continue
                try:
                    start = int(a, 16)
                    size = int(b, 16)
                except ValueError:
                    continue
                if size <= 0:
                    continue
                intervals.append((start, start + size))
    except FileNotFoundError:
        return []
    return _merge_intervals(intervals)

def _pick_refresh_device(name, mapped_dev):
    """
    If a mapping is opened as /dev/mapper/<name>, prefer refreshing that device.
    This lets us run debugfs on ext filesystems and avoids writing to a raw LUKS container
    while it has an active dm mapping.
    """
    mapper = f"/dev/mapper/{name}"
    if os.path.exists(mapper):
        return os.path.realpath(mapper)
    return os.path.realpath(mapped_dev)

def _device_is_mounted(dev_path):
    # Check both the device and its realpath (dm-crypt aliases etc).
    for src in {dev_path, os.path.realpath(dev_path)}:
        if find_mount_targets(src):
            return True
    return False

def get_script_dir():
    return Path(__file__).resolve().parent

def get_map_file_path():
    return get_script_dir() / MAP_FILENAME

def read_luks_map():
    map_file = get_map_file_path()
    if not map_file.exists():
        return {}
    
    mappings = {}
    with open(map_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            parts = line.split(None, 1) # Split on first whitespace
            if len(parts) == 2:
                name, path = parts
                mappings[name] = path
    return mappings

def save_luks_map(mappings):
    map_file = get_map_file_path()
    with open(map_file, 'w') as f:
        for name, path in mappings.items():
            f.write(f"{name}\t{path}\n")

def disk_base_name(dev_path):
    # Given /dev/sdb or /dev/sdb1 -> sdb
    try:
        dev_name = os.path.basename(dev_path)
        # simplistic, better to use lsblk
        res = run_command(['lsblk', '-no', 'PKNAME', dev_path], check=False)
        if res.stdout.strip():
            return res.stdout.strip()
        return dev_name
    except:
        return os.path.basename(dev_path)

def disk_is_nvme(dev_path):
    # Check if NVMe
    try:
        res = run_command(['lsblk', '-dno', 'TRAN', dev_path], check=False)
        if res.stdout.strip() == 'nvme':
            return True
        if 'nvme' in dev_path:
            return True
    except:
        pass
    return False

def disk_is_rotational(dev_path):
    try:
        base = disk_base_name(dev_path)
        p = Path(f"/sys/block/{base}/queue/rotational")
        if p.exists():
            return p.read_text().strip() == "1"
    except:
        pass
    return False

def disk_discard_supported(dev_path):
    try:
        res = run_command(['lsblk', '-dno', 'DISC-MAX', dev_path], check=False)
        val = res.stdout.strip()
        return val and val != "0B" and val != "0"
    except:
        return False

def secure_erase_disk(dev_path):
    if not os.path.exists(dev_path):
        log(f"Device not found: {dev_path}", 'ERROR')
        return False

    # Detect if partition or disk
    is_part = False
    try:
        res = run_command(['lsblk', '-dno', 'TYPE', dev_path], capture_output=True)
        if res.stdout.strip() == 'part':
            is_part = True
    except:
        pass

    target_type = "PARTITION" if is_part else "FULL DISK"
    log(f"Starting secure erase on {dev_path} ({target_type})")

    if disk_is_nvme(dev_path):
        if is_part:
            log("NVMe hardware-level erase (Sanitize/Format) skipped: Target is a partition, not a full disk.", 'WARN')
        else:
            # Query capabilities
            try:
                res = run_command(['nvme', 'id-ctrl', '-o', 'json', dev_path], sudo=True, capture_output=True)
                ctrl_data = json.loads(res.stdout)
                oacs = ctrl_data.get('oacs', 0)
                sanicap = ctrl_data.get('sanicap', 0)
                fna = ctrl_data.get('fna', 0)
                
                can_format = bool(oacs & 0x02)
                can_format_block = can_format # Baseline if Format is supported
                can_format_crypto = can_format and bool(fna & 0x04)
                can_sanitize_block = bool(sanicap & 0x02)
                can_sanitize_crypto = bool(sanicap & 0x01)
                
                # 1. Sanitize Crypto Erase (Priority 1)
                if can_sanitize_crypto:
                    log(f"Attempting NVMe Sanitize Crypto Erase (Action 4) on {dev_path}...")
                    try:
                        run_command(['nvme', 'sanitize', dev_path, '-a', '4'], sudo=True)
                        run_command(['udevadm', 'settle'], sudo=True)
                        log("NVMe Sanitize Crypto Erase completed successfully.")
                        return True
                    except Exception as e:
                        log(f"NVMe Sanitize Crypto Erase failed: {e}. Falling back...", 'WARN')

                # 2. Sanitize Block Erase (Priority 2)
                if can_sanitize_block:
                    log(f"Attempting NVMe Sanitize Block Erase (Action 2) on {dev_path}...")
                    try:
                        run_command(['nvme', 'sanitize', dev_path, '-a', '2'], sudo=True)
                        run_command(['udevadm', 'settle'], sudo=True)
                        log("NVMe Sanitize Block Erase completed successfully.")
                        return True
                    except Exception as e:
                        log(f"NVMe Sanitize Block Erase failed: {e}. Falling back...", 'WARN')

                # 3. Format Crypto Erase (Priority 3)
                if can_format_crypto:
                    log(f"Attempting NVMe Format Crypto Erase (SES 2) on {dev_path}...")
                    try:
                        run_command(['nvme', 'format', dev_path, '--ses=2'], sudo=True)
                        run_command(['udevadm', 'settle'], sudo=True)
                        log("NVMe Format Crypto Erase completed successfully.")
                        return True
                    except Exception as e:
                        log(f"NVMe Format Crypto Erase failed: {e}. Falling back...", 'WARN')

                # 4. Format Block Erase (Last NVMe Fallback)
                if can_format_block:
                    log(f"Attempting NVMe Format Block Erase (SES 1) on {dev_path}...")
                    try:
                        run_command(['nvme', 'format', dev_path, '--ses=1'], sudo=True)
                        run_command(['udevadm', 'settle'], sudo=True)
                        log("NVMe Format Block Erase completed successfully.")
                        return True
                    except Exception as e:
                        log(f"NVMe Format Block Erase failed: {e}. Falling back...", 'WARN')
                
                log("No supported NVMe hardware erase methods found. Falling back to software discard/overwrite.")

            except Exception as e:
                log(f"Failed to query NVMe capabilities: {e}. Falling back to software methods.", 'WARN')

    elif not disk_is_rotational(dev_path):
        # SSD/Flash (SATA/SAS)
        if is_part:
            log("SATA SSD hardware-level erase (ATA Sanitize/Secure Erase) skipped: Target is a partition.", 'WARN')
        else:
            # 1. PSID Revert / TCG Opal (Placeholder)
            log(f"Checking for PSID Revert / TCG Opal support (Currently Unimplemented)...")

            # 2. ATA Sanitize
            try:
                res = run_command(['hdparm', '-I', dev_path], sudo=True, capture_output=True)
                if "sanitize" in res.stdout.lower():
                     log(f"Attempting ATA Sanitize Block Erase on {dev_path}...")
                     try:
                         run_command(['hdparm', '--sanitize-block-erase', dev_path], sudo=True)
                         log("ATA Sanitize Block Erase completed successfully.")
                         return True
                     except Exception as e:
                         log(f"ATA Sanitize failed: {e}. Falling back...", 'WARN')
            except:
                pass

            # 3. ATA Secure Erase (Enhanced & Standard)
            try:
                res = run_command(['hdparm', '-I', dev_path], sudo=True, capture_output=True)
                if "supported" in res.stdout.lower() and "security:" in res.stdout.lower():
                    if "frozen" in res.stdout.lower():
                        log("ATA Secure Erase is FROZEN by BIOS/EFI. Skipping...", 'WARN')
                    else:
                        log("ATA Secure Erase supported. Setting temporary password 'diskmgr'...")
                        try:
                            pw = "diskmgr"
                            run_command(['hdparm', '--user-master', 'u', '--security-set-pass', pw, dev_path], sudo=True)
                            
                            # Enhanced
                            if "enhanced" in res.stdout.lower():
                                log(f"Attempting ATA Secure Erase (Enhanced) on {dev_path}...")
                                try:
                                    run_command(['hdparm', '--user-master', 'u', '--security-erase-enhanced', pw, dev_path], sudo=True)
                                    log("ATA Secure Erase (Enhanced) completed successfully.")
                                    return True
                                except Exception as e:
                                    log(f"ATA Secure Erase (Enhanced) failed: {e}. Falling back...", 'WARN')

                            # Standard
                            log(f"Attempting ATA Secure Erase (Standard) on {dev_path}...")
                            try:
                                run_command(['hdparm', '--user-master', 'u', '--security-erase', pw, dev_path], sudo=True)
                                log("ATA Secure Erase (Standard) completed successfully.")
                                return True
                            except Exception as e:
                                log(f"ATA Secure Erase (Standard) failed: {e}. Falling back...", 'WARN')
                        except Exception as e:
                            log(f"Failed to set security password: {e}. Falling back...", 'WARN')
            except:
                pass

    if disk_is_rotational(dev_path):
        if not is_part:
            # Try ATA methods for HDD too
            try:
                res = run_command(['hdparm', '-I', dev_path], sudo=True, capture_output=True)
                if "sanitize" in res.stdout.lower():
                     log(f"Attempting ATA Sanitize on HDD {dev_path}...")
                     try:
                         run_command(['hdparm', '--sanitize-block-erase', dev_path], sudo=True)
                         log("HDD ATA Sanitize completed successfully.")
                         return True
                     except Exception as e:
                         log(f"HDD ATA Sanitize failed: {e}. Falling back...", 'WARN')
                
                if "supported" in res.stdout.lower() and "security:" in res.stdout.lower() and "frozen" not in res.stdout.lower():
                    log(f"Attempting ATA Secure Erase on HDD {dev_path}...")
                    try:
                        pw = "diskmgr"
                        run_command(['hdparm', '--user-master', 'u', '--security-set-pass', pw, dev_path], sudo=True)
                        erase_cmd = '--security-erase-enhanced' if "enhanced" in res.stdout.lower() else '--security-erase'
                        run_command(['hdparm', '--user-master', 'u', erase_cmd, pw, dev_path], sudo=True)
                        log("HDD ATA Secure Erase completed successfully.")
                        return True
                    except Exception as e:
                        log(f"HDD ATA Secure Erase failed: {e}. Falling back...", 'WARN')
            except:
                pass

        # Final HDD Fallback
        log(f"Performing software zero-overwrite (dd) on {dev_path}...")
        try:
            run_command(['dd', 'if=/dev/zero', f'of={dev_path}', 'bs=16M', 'status=progress', 'oflag=direct'], sudo=True, capture_output=False)
            run_command(['sync'], sudo=True)
            log("Zero overwrite completed. Verifying first 1MB...")
            res_v = run_command(['dd', f'if={dev_path}', 'bs=1M', 'count=1'], sudo=True, capture_output=True)
            if any(b != 0 for b in res_v.stdout.encode('latin1') if isinstance(b, int)):
                 log("Verification failed: First 1MB is not zeroed.", 'ERROR')
                 return False
            log("Verification successful.")
            return True
        except Exception as e:
            log(f"Software overwrite failed: {e}", 'ERROR')
            return False

    # SSD Software Fallbacks
    log(f"Attempting blkdiscard --secure on {dev_path}...")
    try:
        run_command(['blkdiscard', '--secure', dev_path], sudo=True)
        run_command(['udevadm', 'settle'], sudo=True)
        log("blkdiscard --secure completed successfully.")
        return True
    except Exception as e:
        log(f"blkdiscard --secure not supported or failed: {e}. Falling back...", 'WARN')

    log(f"Attempting standard blkdiscard on {dev_path}...")
    if disk_discard_supported(dev_path):
        try:
            run_command(['blkdiscard', dev_path], sudo=True)
            run_command(['udevadm', 'settle'], sudo=True)
            log("Standard blkdiscard completed successfully.")
            return True
        except Exception as e:
            log(f"Standard blkdiscard failed: {e}", 'ERROR')
            return False
    else:
        log("Discard not supported on this device. Final software overwrite attempted.", 'WARN')
        try:
            run_command(['dd', 'if=/dev/zero', f'of={dev_path}', 'bs=16M', 'status=progress', 'oflag=direct'], sudo=True, capture_output=False)
            return True
        except:
            return False

class CmdArgumentParser(argparse.ArgumentParser):
    def error(self, message):
        raise argparse.ArgumentError(None, message)

class DiskMgrShell(cmd.Cmd):
    intro = 'Welcome to diskmgr. Type help or ? to list commands.\n'
    prompt = f'{Colors.OKGREEN}(diskmgr) {Colors.ENDC}'
    
    def __init__(self):
        super().__init__()
        self.mappings = read_luks_map()
        self.unmapped_cache = []

    def get_disk_info(self):
        # Use lsblk -J for JSON output
        cmd = ['lsblk', '-J', '-e', '7', '-o', 'NAME,KNAME,TYPE,RM,SIZE,FSTYPE,LABEL,MOUNTPOINT,MODEL,WWN,PKNAME,TRAN,DISC-MAX']
        try:
            res = run_command(cmd, capture_output=True)
            data = json.loads(res.stdout)
            return data.get('blockdevices', [])
        except Exception as e:
            log(f"Failed to list disks: {e}", 'ERROR')
            return []

    def flatten_disks(self, devices):
        """Recursively flatten the lsblk tree structure."""
        flat = []
        for dev in devices:
            flat.append(dev)
            if 'children' in dev:
                flat.extend(self.flatten_disks(dev['children']))
        return flat

    def find_persistent_path(self, dev_node, wwn=None, type_='disk'):
        # Try to find /dev/disk/by-id/ match
        
        # 1. Try WWN logic from opendisk
        if wwn:
            prefix = "nvme-" if wwn.startswith("eui.") else "wwn-"
            path = f"/dev/disk/by-id/{prefix}{wwn}"
            try:
                if os.path.realpath(path) == os.path.realpath(f"/dev/{dev_node}"):
                    return path
            except:
                pass

        # 2. Brute force check /dev/disk/by-id
        by_id_dir = Path('/dev/disk/by-id')
        if by_id_dir.exists():
            for link in by_id_dir.iterdir():
                try:
                    if link.resolve() == Path(f"/dev/{dev_node}").resolve():
                        return str(link)
                except:
                    continue
        
        return "-"

    def do_help(self, arg):
        'List available commands with "help" or detailed help with "help cmd".'
        if arg:
            super().do_help(arg)
            return

        print(f"\n{Colors.HEADER}Disk Manager (diskmgr){Colors.ENDC}")
        print("A utility designed to simplify the management of encrypted and plain removable media.")
        print("It maps friendly labels to hardware-specific Persistent Device Paths (PDP), ensuring")
        print("that disks are recognized reliably even if device nodes change.\n")
        
        print(f"{Colors.BOLD}COMMANDS:{Colors.ENDC}")
        print(f"  {Colors.OKGREEN}list{Colors.ENDC}")
        print("      Shows all configured mappings and unmapped system disks in one table.")

        print(f"  {Colors.OKGREEN}layout{Colors.ENDC}")
        print("      Displays the physical partition layout and free space for all disks.")

        print(f"  {Colors.OKGREEN}boot{Colors.ENDC}")
        print("      Displays all boot entries and submenus from GRUB.")
        
        print(f"  {Colors.OKGREEN}map <id/name> <name>{Colors.ENDC}")
        print("      Assigns a friendly name to a disk or renames an existing mapping.")

        print(f"  {Colors.OKGREEN}unmap <name>{Colors.ENDC}")
        print("      Removes an existing mapping from the configuration.")
        
        print(f"  {Colors.OKGREEN}open <name>{Colors.ENDC}")
        print("      Unlocks LUKS (if encrypted) and mounts the disk.")
        print("      Mounts to /media/$USER/<label> (prefers label over mapping name).")
        
        print(f"  {Colors.OKGREEN}close <name>{Colors.ENDC}")
        print("      Unmounts and closes the disk.")

        print(f"  {Colors.OKGREEN}label <name> [new_label]{Colors.ENDC}")
        print("      Get or set the filesystem label of an OPEN disk.")

        print(f"  {Colors.OKGREEN}remount <name>{Colors.ENDC}")
        print("      Move an OPEN disk's mount to /media/$USER/<label> (and clean up old mountpoint dirs).")

        print(f"  {Colors.OKGREEN}luks <passwd|backup|restore>{Colors.ENDC}")
        print("      LUKS management: change password, backup/restore headers.")
        
        print(f"  {Colors.OKGREEN}create <name> [options]{Colors.ENDC}")
        print("      Initializes a new disk (Erase -> LUKS -> Format -> Mount).")

        print(f"  {Colors.OKGREEN}erase <name>{Colors.ENDC}")
        print("      Securely erases a disk (multi-step hardware-aware wipe).")

        print(f"  {Colors.OKGREEN}clone <src_name> <dst_name>{Colors.ENDC}")
        print("      Clones one disk to another (requires target >= source size).")

        print(f"  {Colors.OKGREEN}sync <sec_name> <pri_name>{Colors.ENDC}")
        print("      Syncs two mounted disks (rsync pri -> sec).")

        print(f"  {Colors.OKGREEN}health <name>{Colors.ENDC}")
        print("      Shows SMART health (smartctl -a) for the underlying disk (USB uses -d sat).")

        print(f"  {Colors.OKGREEN}refresh <name>{Colors.ENDC}")
        print("      Two-pass ddrescue refresh to detect bit rot and force remap of bad sectors (destructive).")
        
        print(f"  {Colors.OKGREEN}exit / quit / Ctrl+D{Colors.ENDC}")
        print("      Exit the application.")

        print("\nType 'help <command>' for more specific details.")

    def do_exit(self, arg):
        'Exit the application'
        return True

    def do_quit(self, arg):
        'Exit the application'
        return True

    def do_EOF(self, arg):
        'Exit the application'
        print("")
        return True

    def do_layout(self, arg):
        '''Display the physical partition layout and free space for all plugged-in disks.
        
        UNDER THE HOOD:
        1.  Hardware Scan: Identifies all physical 'disk' devices (excluding partitions).
        2.  Geometry Query: Runs 'sudo parted -m <dev> unit s print free' and 'blockdev --getsz'.
        3.  Parsing: 
            - Extracts Partition Table type (gpt/mbr) and sector sizes.
            - Calculates total logical sectors from blockdev output.
        4.  Formatting:
            - Adds GPT metadata blocks (Primary/Backup) if applicable.
            - Identifies 'free' space segments.
            - Calculates MiB and GiB values from sector counts.
        '''
        all_devs = self.get_disk_info()
        disks = [d for d in all_devs if d.get('type') == 'disk']
        
        if not disks:
            log("No physical disks found.", 'WARN')
            return

        for disk in disks:
            d_name = disk['name']
            dev_path = f"/dev/{d_name}"
            model = disk.get('model', 'Unknown')
            
            try:
                # 1. Get Geometry from parted
                res = run_command(['parted', '-m', '-s', dev_path, 'unit', 's', 'print', 'free'], sudo=True, check=False)
                if getattr(res, 'returncode', 1) != 0:
                    # Common case: blank disk or missing/corrupt partition table.
                    # Avoid noisy "Command failed" logs and present a human-readable reason.
                    stderr = (getattr(res, 'stderr', '') or '').strip()

                    # Fall back to blockdev sector sizes for a useful header.
                    ls = run_command(['blockdev', '--getss', dev_path], sudo=True, check=False).stdout.strip()
                    ps = run_command(['blockdev', '--getpbsz', dev_path], sudo=True, check=False).stdout.strip()
                    logical_sector = int(ls) if ls.isdigit() else 512
                    physical_sector = int(ps) if ps.isdigit() else logical_sector

                    res_sz = run_command(['blockdev', '--getsz', dev_path], sudo=True, check=False)
                    total_512_sectors = int(res_sz.stdout.strip()) if (res_sz.stdout or "").strip().isdigit() else 0
                    total_logical_sectors = (total_512_sectors * 512) // logical_sector if logical_sector else 0

                    print(f"\n{Colors.BOLD}Disk: {dev_path} ({model}) [none] [Sector: L{logical_sector}/P{physical_sector}] [Total Sectors: {total_logical_sectors}]{Colors.ENDC}")
                    if stderr:
                        if "unrecognised disk label" in stderr.lower():
                            log(f"{dev_path}: no partition table (unrecognized disk label).", 'WARN')
                        else:
                            log(f"{dev_path}: could not read partition layout: {stderr}", 'WARN')

                    # Still show lsblk hierarchy so the user can see what's on the disk.
                    print("")
                    try:
                        ls_res = run_command(['lsblk', '-J', '-f', dev_path], sudo=True, check=False)
                        if ls_res.stdout.strip():
                            data = json.loads(ls_res.stdout)
                            if 'blockdevices' in data:
                                print(f"{Colors.BOLD}{'NAME':<25} {'FSTYPE':<12} {'FSVER':<6} {'LABEL':<12} {'UUID':<38} {'FSAVAIL':<10} {'FSUSE%':<8} {'MOUNTPOINTS'}{Colors.ENDC}")
                                self.render_lsblk_json(data['blockdevices'])
                    except Exception as e:
                        log(f"Could not render lsblk tree: {e}", 'DEBUG')
                    print("-" * 155)
                    continue

                lines = res.stdout.strip().splitlines()
                
                header_parts = lines[1].strip(';').split(':')
                logical_sector = int(header_parts[3])
                physical_sector = int(header_parts[4])
                ptable = header_parts[5]
                
                # 2. Get Total Size from blockdev (always in 512b units)
                res_sz = run_command(['blockdev', '--getsz', dev_path], sudo=True)
                total_512_sectors = int(res_sz.stdout.strip())
                total_logical_sectors = (total_512_sectors * 512) // logical_sector

                print(f"\n{Colors.BOLD}Disk: {dev_path} ({model}) [{ptable}] [Sector: L{logical_sector}/P{physical_sector}] [Total Sectors: {total_logical_sectors}]{Colors.ENDC}")

                # 4. Parse Data Lines from parted for visual blocks
                data_lines = [l for l in lines if l and not l.startswith('BYT') and not l.startswith('/')]
                
                segments = []
                
                # Dynamic Initial Overhead Detection
                if data_lines:
                    first_line_parts = data_lines[0].strip(';').split(':')
                    first_start = int(first_line_parts[1].strip('s'))
                    if first_start > 0:
                        overhead_size = first_start
                        overhead_bytes = overhead_size * logical_sector
                        
                        label = "Overhead"
                        if ptable == 'gpt': label = "GPT Primary"
                        elif ptable in ['msdos', 'mbr']: label = "MBR"
                        
                        segments.append(f"{Colors.FAIL}[ {label} {overhead_size}s ({overhead_bytes:.2f}B) ]{Colors.ENDC}")

                for line in data_lines:
                    parts = line.strip(';').split(':')
                    if len(parts) < 4: continue
                    
                    num = parts[0]
                    size_sectors = int(parts[3].strip('s'))
                    fs_or_type = parts[4] if len(parts) > 4 else ""
                    
                    size_bytes = size_sectors * logical_sector
                    # Use B, KiB, MiB, GiB based on size
                    if size_bytes < 1024:
                        size_info = f"{size_bytes:.2f}B"
                    elif size_bytes < 1024**2:
                        size_info = f"{size_bytes/1024:.2f}KiB"
                    elif size_bytes < 1024**3:
                        size_info = f"{size_bytes/(1024**2):.2f}MiB"
                    else:
                        size_info = f"{size_bytes/(1024**2):.2f}MiB ≈ {size_bytes/(1024**3):.1f}GiB"

                    if fs_or_type == 'free' or (not fs_or_type and len(parts) == 5):
                        segments.append(f"{Colors.OKCYAN}[ free {size_sectors}s ({size_info}) ]{Colors.ENDC}")
                    else:
                        flags = parts[6] if len(parts) > 6 else ""
                        kname = f"{d_name}{num}"
                        if 'nvme' in d_name and not kname.startswith(f"{d_name}p"):
                            kname = f"{d_name}p{num}"
                        
                        dtype = fs_or_type if fs_or_type else "-"
                        flag_info = f" ({flags})" if flags else ""
                        segments.append(f"{Colors.OKGREEN}[ {kname} {dtype} {size_sectors}s ({size_info}){flag_info} ]{Colors.ENDC}")
                
                # GPT Backup Overhead
                if data_lines:
                    last_line_parts = data_lines[-1].strip(';').split(':')
                    last_end = int(last_line_parts[2].strip('s'))
                    if last_end < total_logical_sectors - 1:
                        overhead_size = total_logical_sectors - 1 - last_end
                        overhead_bytes = overhead_size * logical_sector
                        l_label = "Overhead"
                        if ptable == 'gpt': l_label = "GPT Backup"
                        segments.append(f"{Colors.FAIL}[ {l_label} {overhead_size}s ({overhead_bytes:.2f}B) ]{Colors.ENDC}")

                print(" ".join(segments))

                # 4. Print lsblk hierarchy at the bottom
                print("")
                try:
                    # Use JSON output for absolute reliability in data capture
                    ls_res = run_command(['lsblk', '-J', '-f', dev_path], sudo=True, check=False)
                    if ls_res.stdout.strip():
                        data = json.loads(ls_res.stdout)
                        if 'blockdevices' in data:
                            print(f"{Colors.BOLD}{'NAME':<25} {'FSTYPE':<12} {'FSVER':<6} {'LABEL':<12} {'UUID':<38} {'FSAVAIL':<10} {'FSUSE%':<8} {'MOUNTPOINTS'}{Colors.ENDC}")
                            self.render_lsblk_json(data['blockdevices'])
                except Exception as e:
                    log(f"Could not render lsblk tree: {e}", 'DEBUG')
                print("-" * 155)
            except Exception as e:
                print(f"\n{Colors.BOLD}Disk: {dev_path} ({model}){Colors.ENDC}")
                log(f"Could not read layout for {dev_path}: {e}", 'WARN')
        print("")

    def render_lsblk_json(self, devices, indent="", is_root=True):
        for i, dev in enumerate(devices):
            is_last = (i == len(devices) - 1)
            
            name = dev.get('name', '')
            fstype = dev.get('fstype') or ""
            fsver = dev.get('fsver') or ""
            label = dev.get('label') or ""
            uuid = dev.get('uuid') or ""
            fsavail = dev.get('fsavail') or ""
            fsuse = dev.get('fsuse%') or ""
            mounts = ", ".join([m for m in dev.get('mountpoints', []) if m])

            # Tree characters
            if is_root:
                tree_part = name
                next_indent = ""
            else:
                char = "└─" if is_last else "├─"
                tree_part = indent + char + name
                next_indent = indent + ("    " if is_last else "│   ")

            # Print row
            # NAME(25) FSTYPE(12) FSVER(6) LABEL(12) UUID(38) FSAVAIL(10) FSUSE(8) MOUNTPOINTS
            print(f"{tree_part:<25} {fstype:<12} {fsver:<6} {label:<12} {uuid:<38} {fsavail:<10} {fsuse:<8} {mounts}".rstrip())
            
            if 'children' in dev:
                self.render_lsblk_json(dev['children'], next_indent, is_root=False)

    def resolve_uuid_to_dev(self, uuid):
        '''Resolves a UUID to a short device name like sda1 or nvme0n1p1.'''
        uuid = uuid.strip()
        if not uuid or uuid == "(firmware)":
            return ""
        try:
            # Use check=False to avoid noisy logs if UUID doesn't resolve
            res = run_command(['blkid', '-U', uuid], sudo=True, capture_output=True, check=False)
            path = res.stdout.strip()
            if path:
                return os.path.basename(path)
        except:
            pass
        return ""

    def do_boot(self, arg):
        '''Display boot entries from the GRUB configuration of all disks.
        
        UNDER THE HOOD:
        Scans all block devices. If mounted, it parses /boot/grub/grub.cfg.
        If unmounted or encrypted, it explains why it cannot yet read the config.
        '''
        all_devs = self.get_disk_info()
        flat_disks = self.flatten_disks(all_devs)
        
        # AWK script parses Title <TAB> Entry <TAB> SEARCH <TAB> ROOT
        awk_script = r"""
  /search[[:space:]].*--fs-uuid/ {g_search=$NF}

  /^[[:space:]]*submenu / {
    submenu_title=$2
    next
  }

  /^[[:space:]]*menuentry / {
    e=$2; search_u=""; root_u=""; in_entry=1
    next
  }

  in_entry && search_u=="" && /search[[:space:]].*--fs-uuid/ {search_u=$NF}
  in_entry && root_u=="" && /(linux|linuxefi)[[:space:]].*root=UUID=/ {
    match($0,/root=UUID=[0-9a-fA-F-]+/)
    if (RSTART) root_u=substr($0,RSTART+10,RLENGTH-10)
  }

  in_entry && /^[[:space:]]*}/ {
    if (submenu_title=="") submenu_title="Top-level"
    s = (search_u!="" ? search_u : g_search)
    r = (root_u!=""   ? root_u   : "-")
    if (e ~ /UEFI Firmware Settings/) { s="(firmware)"; r="(firmware)" }
    
    print submenu_title "\t" e "\t" s "\t" r
    in_entry=0
  }
"""
        processed_devs = set()

        print(f"\n{Colors.HEADER}{Colors.BOLD}--- System Boot Configuration Scan ---{Colors.ENDC}")

        for dev in flat_disks:
            d_name = dev.get('name')
            d_kname = dev.get('kname', d_name)
            d_path = f"/dev/{d_kname}"
            d_type = dev.get('type')
            fstype = dev.get('fstype')
            mountpoint = dev.get('mountpoint')

            if d_type == 'loop' or (d_type == 'disk' and 'children' in dev):
                continue
            
            if d_path in processed_devs:
                continue
            processed_devs.add(d_path)

            print(f"\n{Colors.OKBLUE}Device: {d_path} ({fstype or 'unknown FS'}){Colors.ENDC}")

            if fstype == 'crypto_LUKS':
                print(f"  {Colors.WARNING}Result: LUKS container is LOCKED. Please 'open' this disk to scan for boot entries.{Colors.ENDC}")
            elif not mountpoint:
                if fstype and fstype != '-':
                    print(f"  {Colors.WARNING}Result: Disk is UNMOUNTED. Please 'open' or mount the disk to scan for boot entries.{Colors.ENDC}")
                else:
                    print(f"  {Colors.WARNING}Result: No recognizable filesystem found.{Colors.ENDC}")
            else:
                cfg_path = Path(mountpoint) / "boot/grub/grub.cfg"
                display_path = str(cfg_path).replace("//", "/")
                try:
                    if cfg_path.exists():
                        print(f"  {Colors.OKGREEN}Result: Found GRUB config at {display_path}{Colors.ENDC}")
                        cmd = ['sudo', 'awk', '-F', "'", awk_script, str(cfg_path)]
                        res = run_command(cmd, capture_output=True)
                        
                        if res.stdout.strip():
                            entries = {}
                            for line in res.stdout.strip().splitlines():
                                if '\t' in line:
                                    parts = [x.strip() for x in line.split('\t')]
                                    if len(parts) == 4:
                                        sub, title, s_uuid, r_uuid = parts
                                        if sub not in entries: entries[sub] = []
                                        entries[sub].append((title, s_uuid, r_uuid))
                            
                            for sub, items in entries.items():
                                print(f"\n{sub}")
                                for i, (title, s_uuid, r_uuid) in enumerate(items):
                                    connector = "  └─" if i == len(items) - 1 else "  ├─"
                                    
                                    s_dev = self.resolve_uuid_to_dev(s_uuid)
                                    r_dev = self.resolve_uuid_to_dev(r_uuid)
                                    
                                    s_info = f"SEARCH={s_uuid:<36} [{s_dev if s_dev else '-'}]"
                                    r_info = f"ROOT={r_uuid:<36} [{r_dev if r_dev else '-'}]"
                                    
                                    print(f"{connector} {title:<72}  {Colors.OKCYAN}{s_info}  {r_info}{Colors.ENDC}")
                        else:
                            print("  (No menu entries found in config)")
                    else:
                        print(f"  {Colors.OKCYAN}Result: Mounted at {mountpoint}, but no GRUB configuration found.{Colors.ENDC}")
                except PermissionError:
                    print(f"  {Colors.FAIL}Result: Permission denied scanning {mountpoint} (System protected path).{Colors.ENDC}")
                except Exception as e:
                    print(f"  {Colors.FAIL}Result: Error checking path: {e}{Colors.ENDC}")
            
            print("-" * 60)

    def do_list(self, arg):
        '''List all configured mappings and available system disks in a single table.
        
        UNDER THE HOOD:
        1.  Resolution: Refreshes mappings from diskmap.tsv.
        2.  Hardware Discovery: Uses 'lsblk' to gather hardware properties and identifies 
            underlying physical partitions even when opened as virtual devices.
        3.  Zero-Sudo LUKS Detection: Queries the system 'udev' database via 'udevadm info' 
            to accurately identify encrypted disks without requiring root privileges.
        4.  Status Logic:
            - MISSING: Persistent path not found in /dev.
            - CLOSED: Present but locked (LUKS) or unmounted (Plain).
            - OPEN: Unlocked/Decrypted but not yet mounted.
            - MOUNTED: Active filesystem attached to the preferred path (/media/$USER/name).
        5.  Dynamic Formatting: Pre-calculates the maximum width of every column across 
            all rows for a perfectly aligned, readable table.
        6.  Exclusion Logic: Rigorously filters out virtual mapper devices and their 
            kernel aliases (dm-X) from the unmapped list once they are active.
        '''
        self.mappings = read_luks_map()
        mapped_rows = []
        unmapped_rows = []
        
        # 1. Collect Mapped Disks
        mapped_real_paths = set()
        mapped_names = set()
        i = 1
        for name, path in self.mappings.items():
            phys_device = "-"
            dm_device = ""
            fstype = "-"
            size = "-"
            label = "-"
            mountpoint = f"/media/{os.environ.get('USER', 'root')}/{name}"
            is_luks = "-"
            state = "MISSING"
            
            mapped_names.add(name)
            
            # Default mountpoint based on name
            mount_name = name

            if os.path.exists(path):
                real_path = os.path.realpath(path)
                mapped_real_paths.add(real_path)
                state = "CLOSED"
                is_luks = "N"
                
                # Get Physical Device Properties
                try:
                    cmd_p = ['lsblk', '-n', '-P', '-o', 'KNAME,PKNAME,FSTYPE,SIZE,LABEL', real_path]
                    res_p = run_command(cmd_p, check=False)
                    if res_p.stdout.strip():
                        props = {}
                        for part in shlex.split(res_p.stdout.strip()):
                            if '=' in part:
                                k, v = part.split('=', 1)
                                props[k] = v
                        
                        phys_device = props.get('KNAME', '-')
                        # If the 'physical' device is actually a DM device, try to get its parent
                        if phys_device.startswith('dm-'):
                            parent = props.get('PKNAME', '')
                            if parent: phys_device = parent

                        fstype = props.get('FSTYPE', '-')
                        size = props.get('SIZE', '-')
                        label = props.get('LABEL', '-')
                        
                        # Fallback to blkid for more reliable label (lsblk is often stale)
                        try:
                            res_b = run_command(['blkid', '-o', 'value', '-s', 'LABEL', real_path], sudo=True, check=False)
                            if res_b.stdout.strip():
                                label = res_b.stdout.strip()
                        except:
                            pass
                        
                        if label and label != '-':
                            mount_name = label

                        # Check LUKS status using udev (No sudo required)
                        res_u = run_command(['udevadm', 'info', '--query=property', f'--name={real_path}'], check=False)
                        if 'ID_FS_TYPE=crypto_LUKS' in res_u.stdout:
                            is_luks = "Y"
                        elif fstype == 'crypto_LUKS':
                            is_luks = "Y"
                except:
                    pass

            mountpoint = f"/media/{os.environ.get('USER', 'root')}/{mount_name}"

            mapper_path = f"/dev/mapper/{name}"
            target_to_mount = mapper_path

            if is_luks == "Y" and os.path.exists(mapper_path):
                mapped_real_paths.add(os.path.realpath(mapper_path))
                mapped_real_paths.add(mapper_path)
                mapped_names.add(name) # Hide '1a'
                
                state = "OPEN"
                try:
                    cmd_m = ['lsblk', '-n', '-P', '-o', 'KNAME,PKNAME,FSTYPE,LABEL,SIZE', mapper_path]
                    res_m = run_command(cmd_m, check=False)
                    if res_m.stdout.strip():
                        props = {}
                        for part in shlex.split(res_m.stdout.strip()):
                            if '=' in part:
                                k, v = part.split('=', 1)
                                props[k] = v
                        # Get mapper kernel name (e.g. dm-0)
                        dm_device = props.get('KNAME', '')
                        if dm_device: mapped_names.add(dm_device)
                        
                        # Also hide the physical parent of the DM device
                        dm_parent = props.get('PKNAME', '')
                        if dm_parent: 
                            mapped_names.add(dm_parent)
                            if phys_device == '-': phys_device = dm_parent
                        
                        # Use mapper properties for FS details
                        if props.get('FSTYPE'): fstype = props.get('FSTYPE')
                        if props.get('LABEL'): 
                            label = props.get('LABEL')
                            if label and label != '-':
                                mountpoint = f"/media/{os.environ.get('USER', 'root')}/{label}"
                        if props.get('SIZE'): size = props.get('SIZE')
                except:
                    pass
                
                targets = find_mount_targets(mapper_path)
                if targets:
                    mountpoint = ", ".join(targets)
                    state = "MOUNTED"
            elif is_luks == "N" and state != "MISSING":
                 targets = find_mount_targets(path)
                 if targets:
                     mountpoint = ", ".join(targets)
                     state = "MOUNTED"

            # Only show mountpoint if actually MOUNTED
            if state != "MOUNTED":
                mountpoint = "-"

            display_dev = phys_device
            if dm_device and dm_device != phys_device:
                display_dev = f"{phys_device}({dm_device})"

            mapped_rows.append({
                'idx': f"[{i}]", 'name': name, 'luks': is_luks, 'state': state, 
                'fstype': fstype, 'label': label if label else "-", 'mount': mountpoint, 
                'dev': display_dev, 'size': size, 'path': path
            })
            i += 1

        # 2. Collect Unmapped Disks
        all_disks = self.get_disk_info()
        flat_disks = self.flatten_disks(all_disks)
        self.unmapped_cache = []
        u_idx = 1
        for dev in flat_disks:
            d_name = dev.get('name') # Usually mapper name or short kernel name
            d_kname = dev.get('kname') # Kernel name (sda2, dm-0)
            if not d_name or d_name.startswith('loop'):
                continue
            
            # Hide if NAME or KNAME matches a known mapping (1a, dm-0, etc.)
            if d_name in mapped_names or d_kname in mapped_names:
                continue

            dev_path = f"/dev/{d_name}"
            real_dev_path = os.path.realpath(dev_path)
            
            # Hide if this is a known mapped physical device or mapper device path
            if real_dev_path in mapped_real_paths or dev_path in mapped_real_paths:
                continue
            
            # Check for /dev/mapper/ links appearing in dev nodes
            if os.path.exists(f"/dev/mapper/{d_name}"):
                continue

            fstype = dev.get('fstype') or '-'
            label = dev.get('label') or '-'
            
            # Fallback to blkid for more reliable label
            try:
                res_b = run_command(['blkid', '-o', 'value', '-s', 'LABEL', dev_path], sudo=True, check=False)
                if res_b.stdout.strip():
                    label = res_b.stdout.strip()
            except:
                pass

            size = dev.get('size') or '-'
            mountpoint = dev.get('mountpoint') or '-'
            pdp = self.find_persistent_path(d_name, dev.get('wwn'))
            
            self.unmapped_cache.append({
                'dev': dev_path, 'pdp': pdp if pdp != '-' else dev_path,
                'size': size, 'model': dev.get('model'), 'type': dev.get('type')
            })
            
            is_luks_u = "N"
            if fstype == 'crypto_LUKS':
                is_luks_u = "Y"
            else:
                # Check udev for unmapped too
                res_uu = subprocess.run(['udevadm', 'info', '--query=property', f'--name={dev_path}'], capture_output=True, text=True)
                if 'ID_FS_TYPE=crypto_LUKS' in res_uu.stdout:
                    is_luks_u = "Y"

            # Check if this device has any active LUKS children (is it open?)
            is_open = False
            has_mount = mountpoint != '-'
            
            # Look for crypt children in the flattened list
            # A bit inefficient but reliable: find if any device has this one as PKNAME
            for child in flat_disks:
                if child.get('pkname') == d_name or child.get('pkname') == d_kname:
                    if child.get('type') == 'crypt':
                        is_open = True
                        if child.get('mountpoint'):
                            has_mount = True
                            mountpoint = child.get('mountpoint')

            state_u = "UNMOUNTED"
            if has_mount:
                state_u = "MOUNTED"
            elif is_open:
                state_u = "OPEN"
            elif is_luks_u == "Y":
                state_u = "LOCKED"

            unmapped_rows.append({
                'idx': f"[U{u_idx}]", 'name': "-", 'luks': is_luks_u, 'state': state_u,
                'fstype': fstype, 'label': label, 'mount': mountpoint,
                'dev': d_kname if d_kname else d_name, 'size': size, 'path': pdp
            })
            u_idx += 1

        # 3. Calculate Widths and Print
        all_rows = mapped_rows + unmapped_rows
        headers = ["#", "NAME", "LUKS", "STATE", "FSTYPE", "LABEL", "MOUNTPOINT", "DEVICE", "SIZE", "PERSISTENT PATH"]
        keys = ['idx', 'name', 'luks', 'state', 'fstype', 'label', 'mount', 'dev', 'size', 'path']
        widths = {k: len(h) for k, h in zip(keys, headers)}
        
        for row in all_rows:
            for k in keys:
                widths[k] = max(widths[k], len(str(row[k])))
        
        fmt = "  ".join([f"{{:<{widths[k]}}}" for k in keys])

        print(f"\n{Colors.HEADER}--- Disk Management Table ({get_map_file_path()}) ---{Colors.ENDC}")
        print(fmt.format(*headers))
        print("-" * (sum(widths.values()) + len(keys)*2))
        for row in all_rows:
            print(fmt.format(*[row[k] for k in keys]))
        print("")

    def resolve_target(self, target_str, allow_id=True):
        '''Resolves a target string to a physical path.
        Only supports Discovery IDs (U1, [U1]) or existing mapping names.
        '''
        clean = target_str.strip('[]')
        
        # 1. Check Discovery ID
        if allow_id and clean.startswith('U') and clean[1:].isdigit():
            idx = int(clean[1:]) - 1
            if 0 <= idx < len(self.unmapped_cache):
                return self.unmapped_cache[idx]['pdp']
            return None
            
        # 2. Check Mapping Name
        self.mappings = read_luks_map()
        if target_str in self.mappings:
            return self.mappings[target_str]
            
        return None

    def extensive_confirm(self, target_name):
        print(f"\n{Colors.FAIL}{Colors.BOLD}!!! EXTENSIVE CONFIRMATION REQUIRED !!!{Colors.ENDC}")
        print(f"You are about to perform a DESTRUCTIVE operation on: {Colors.WARNING}{target_name}{Colors.ENDC}")
        print("To proceed, you must answer two math questions correctly.")
        
        for i in range(2):
            a = random.randint(11, 99)
            b = random.randint(11, 99)
            op = random.choice(['+', '-'])
            if op == '+':
                ans = a + b
            else:
                ans = a - b
            
            try:
                user_ans = input(f"Question {i+1}/2: What is {a} {op} {b}? ")
                if not user_ans or int(user_ans) != ans:
                    log("Incorrect answer. Aborting operation.", 'ERROR')
                    return False
            except ValueError:
                log("Invalid input. Aborting operation.", 'ERROR')
                return False
        
        print(f"{Colors.OKGREEN}Verification successful. Proceeding...{Colors.ENDC}")
        return True

    def is_root_disk(self, target_path):
        """Checks if the target path is the root disk or partition."""
        try:
            # Get the root device
            res = run_command(['findmnt', '-nro', 'SOURCE', '/'], capture_output=True)
            root_dev = os.path.realpath(res.stdout.strip())
            
            target_real = os.path.realpath(target_path)
            
            # 1. Direct match
            if target_real == root_dev:
                return True
                
            # 2. Parent disk match (if target is /dev/sda and root is /dev/sda2)
            res_p = run_command(['lsblk', '-no', 'PKNAME', root_dev], check=False)
            parent = res_p.stdout.strip()
            if parent and target_real == os.path.realpath(f"/dev/{parent}"):
                return True
                
            # 3. Child partition match (if target is /dev/sda2 and root is /dev/sda)
            res_c = run_command(['lsblk', '-no', 'PKNAME', target_real], check=False)
            target_parent = res_c.stdout.strip()
            if target_parent and root_dev == os.path.realpath(f"/dev/{target_parent}"):
                # This is actually covered by case 1 if root is the disk, 
                # but if root is a partition we don't want to wipe its siblings?
                # Actually, the most dangerous case is wiping the disk containing root.
                pass

        except:
            pass
        return False

    def do_map(self, arg):
        '''Create or modify a persistent mapping: map <name/id> <name>
        
        Usage:
          map [U1] backup    Assigns friendly name to discovery ID (e.g., map U1 backup)
          map 1a backup      Renames an existing mapping (e.g., map 1a backup)
        
        Note: Raw device paths (e.g., /dev/sdb) are NOT allowed.
        
        UNDER THE HOOD:
        1.  Input Resolution: 
            - discovery ID (e.g., [U1]): Resolves the temporary device to its Persistent Device Path (PDP).
            - mapping name (e.g., 1a): Selects an existing mapping for RENAME operations.
        2.  PDP Linking: Extracts the /dev/disk/by-id/ path for the target hardware.
        3.  Conflict Check: Ensures the new friendly name is not already in use.
        4.  Persistence: Writes the [Name <TAB> PDP] pair to diskmap.tsv.
        
        This ensures the disk is recognized correctly regardless of USB port or device node changes.
        '''
        args = arg.split()
        if len(args) != 2:
            log("Usage: map <id/name> <new_name>", 'ERROR')
            return

        target, name = args
        self.mappings = read_luks_map() # Refresh
        
        # 1. Check for Rename (target is a mapping name)
        if target in self.mappings:
            real_target = self.mappings[target]
            log(f"Renaming mapping {target} -> {name}")
            del self.mappings[target]
        else:
            # 2. Check for New Map (target is a discovery ID)
            real_target = self.resolve_target(target)
            if not real_target:
                log(f"Invalid target: '{target}'. Use a Discovery ID (e.g., [U1]) or an existing name.", 'ERROR')
                return
            log(f"Resolved {target} -> {real_target}")
        
        if name in self.mappings:
             log(f"Mapping '{name}' already exists.", 'ERROR')
             return

        # Collision Prevention: Prevent names that look like IDs
        clean_name = name.strip('[]')
        if (clean_name.startswith('U') and clean_name[1:].isdigit()) or clean_name.isdigit():
            log(f"Invalid name: '{name}'. Names cannot be simple numbers or match the 'U1' ID format.", 'ERROR')
            return

        self.mappings[name] = real_target
        save_luks_map(self.mappings)
        log(f"Mapping saved: {name} -> {real_target}")

    def do_unmap(self, arg):
        '''Remove a persistent mapping: unmap <name>
        
        UNDER THE HOOD:
        1.  Resolution: Verifies the mapping exists in diskmap.tsv.
        2.  Removal: Deletes the [Name <TAB> PDP] pair from the internal dictionary.
        3.  Persistence: Re-writes diskmap.tsv with the mapping removed.
        '''
        name = arg.strip()
        if not name:
            log("Usage: unmap <name>", 'ERROR')
            return

        self.mappings = read_luks_map()
        if name not in self.mappings:
            log(f"Unknown mapping: '{name}'", 'ERROR')
            return

        del self.mappings[name]
        save_luks_map(self.mappings)
        log(f"Mapping '{name}' removed successfully.")

    def do_open(self, arg):
        '''Unlock (if encrypted) and mount a disk: open <name>
        
        UNDER THE HOOD:
        1.  Identity Resolution: Looks up the friendly name in diskmap.tsv.
        2.  Hardware Wait: Polls for up to 10 seconds to allow for hardware spin-up/udev events.
        3.  Validation: 
            - Runs 'cryptsetup isLuks' to check for encryption.
            - If NOT encrypted (Plain Disk): 
              * Skips decryption step.
              * Verifies the existence of a valid filesystem.
              * Proceeds to label detection and mounting.
        4.  Decryption (LUKS only):
            - Executes 'passgen' to retrieve the passphrase.
            - Pipes the passphrase into 'cryptsetup open' to create a cleartext device in /dev/mapper/.
        5.  Mounting:
            - Identifies the preferred mountpoint: /media/$USER/<label>.
            - If no hardware label is present, falls back to /media/$USER/<mapping_name>.
            - Note: Prioritizing the label ensures that the disk mounts to the same 
              path used by standard OS automounters for plain removable media.
            - Ensures the directory exists and attaches the device.
        6.  Policy Enforcement: If the disk is already mounted at a non-standard path, 
            it unmounts and remounts it to the preferred path.
        '''
        name = arg.strip()
        if not name:
             log("Usage: open <name>", 'ERROR')
             return
             
        self.mappings = read_luks_map()
        if name not in self.mappings:
            log(f"Unknown mapping: {name}. Use 'list' to find Discovery IDs and 'map' them first.", 'ERROR')
            return
            
        src = self.mappings[name]
        
        # Wait for device
        log(f"Waiting for device {src}...")
        for _ in range(50): # 10s wait
            if os.path.exists(src):
                break
            time.sleep(0.2)
            
        if not os.path.exists(src):
            log(f"Device not found: {src}", 'ERROR')
            return
            
        devnode = os.path.realpath(src)
        
        # Check LUKS
        is_luks = False
        try:
            res = run_command(['cryptsetup', 'isLuks', devnode], sudo=True, check=False)
            if res.returncode == 0:
                is_luks = True
        except:
             pass

        if not is_luks:
             # Not LUKS, check if it has a filesystem
             res = run_command(['lsblk', '-n', '-o', 'FSTYPE', devnode], check=False)
             if not res.stdout.strip():
                 log(f"Device {devnode} is not a valid LUKS device and has no recognizable filesystem.", 'ERROR')
                 return
             log(f"Device {devnode} is not LUKS, but has a filesystem. Proceeding with plain mount.")

        mapper_path = f"/dev/mapper/{name}"
        target_to_mount = mapper_path

        if is_luks:
            if not os.path.exists(mapper_path):
                log(f"Opening LUKS mapping {name}...")
                # Use passgen
                pg_cmd = subprocess.Popen([PASSGEN_BIN], stdout=subprocess.PIPE, text=True)
                # Pipe to cryptsetup
                try:
                    run_command(
                        ['cryptsetup', 'open', '--key-file', '-', src, name],
                        input_str=pg_cmd.communicate()[0],
                        sudo=True,
                        check=True
                    )
                    log("LUKS opened.")
                except Exception as e:
                    log(f"Failed to open LUKS: {e}", 'ERROR')
                    return
            else:
                log("Mapping already exists.")
        else:
            # Plain disk
            target_to_mount = devnode

        # Detect label for mountpoint
        mount_name = name
        try:
            res_b = run_command(['blkid', '-o', 'value', '-s', 'LABEL', target_to_mount], sudo=True, check=False)
            if res_b.stdout.strip():
                mount_name = res_b.stdout.strip()
        except:
            pass

        # Mount
        mountpoint = f"/media/{os.environ.get('USER', 'root')}/{mount_name}"
        
        # Safety Check: Is this mountpoint already in use by another device?
        res_check = run_command(['findmnt', '-rn', '-M', mountpoint], check=False)
        if res_check.returncode == 0:
            # Check if it's a DIFFERENT device
            res_src = run_command(['findmnt', '-rn', '-M', mountpoint, '-o', 'SOURCE'], capture_output=True)
            current_src = os.path.realpath(res_src.stdout.strip())
            if current_src != os.path.realpath(target_to_mount):
                log(f"MOUNT BLOCKED: Path {mountpoint} is already in use by {current_src}.", 'ERROR')
                return

        if not os.path.exists(mountpoint):
            run_command(['mkdir', '-p', mountpoint], sudo=True)
            
        # Check if mounted (may have multiple mount targets)
        current_targets = find_mount_targets(target_to_mount)

        if not current_targets:
            log(f"Mounting {target_to_mount} to {mountpoint}...")
            run_command(['mount', target_to_mount, mountpoint], sudo=True)
            log("Mounted.")
        elif mountpoint in current_targets:
            extra = [t for t in current_targets if t != mountpoint]
            if extra:
                log(f"Disk is also mounted at {', '.join(extra)}. Unmounting extra mount(s)...")
                for mp in extra:
                    try:
                        run_command(['umount', mp], sudo=True)
                    except Exception as e:
                        log(f"Failed to unmount {mp}: {e}. It may be in use.", 'WARN')
            log(f"Already mounted at {mountpoint}.")
        else:
            log(f"Disk is mounted at {', '.join(current_targets)} (system default). Overriding...")
            try:
                for mp in current_targets:
                    run_command(['umount', mp], sudo=True)
                run_command(['mount', target_to_mount, mountpoint], sudo=True)
                log(f"Successfully moved mount to {mountpoint}")
            except Exception as e:
                log(f"Failed to override mount: {e}. It may be in use.", 'WARN')

    def do_close(self, arg):
        '''Unmount and lock (if encrypted) a disk: close <name>
        
        UNDER THE HOOD:
        1.  Unmounting (Encrypted & Plain): 
            - Flushes all pending writes to the disk (data integrity).
            - Terminates active file handles to the device.
            - Attempts unmount by mapper path (LUKS), source path (Plain), or guessed mountpoint.
        2.  Locking (LUKS only):
            - Commands the kernel to wipe encryption keys from RAM.
            - Removes the virtual cleartext device from /dev/mapper/.
        3.  Audit: Checks and displays remaining active mappings for security awareness.
        '''
        name = arg.strip()
        if not name:
            log("Usage: close <name>", 'ERROR')
            return

        mapper_path = f"/dev/mapper/{name}"
        mount_guess = f"/media/{os.environ.get('USER', 'root')}/{name}"

        run_command(['sudo', '-v']) # Refresh sudo

        # Unmount
        unmounted = False
        unmounted_targets = []
        # 1. Try by mapper
        targets = find_mount_targets(mapper_path)
        if targets:
            for mp in targets:
                log(f"Unmounting {mp}...")
                run_command(['umount', mp], sudo=True)
                unmounted_targets.append(mp)
            unmounted = True
        
        # 2. Try by source path (for non-LUKS)
        if not unmounted:
            self.mappings = read_luks_map()
            if name in self.mappings:
                src = self.mappings[name]
                targets = find_mount_targets(src)
                if targets:
                    for mp in targets:
                        log(f"Unmounting {mp}...")
                        run_command(['umount', mp], sudo=True)
                        unmounted_targets.append(mp)
                    unmounted = True

        # 3. Try by guess
        if not unmounted:
            if run_command(['findmnt', '-rn', '-M', mount_guess], check=False).returncode == 0:
                 log(f"Unmounting {mount_guess}...")
                 run_command(['umount', mount_guess], sudo=True)
                 unmounted_targets.append(mount_guess)
                 unmounted = True

        # Cleanup mountpoint dir(s) (best-effort)
        for mp in unmounted_targets:
            cleanup_mountpoint_dir(mp)
        
        # Close
        if os.path.exists(mapper_path):
            log(f"Closing mapping {name}...")
            run_command(['cryptsetup', 'close', name], sudo=True)
            log("Closed.")
        else:
            log("Mapping not open or already closed.")

    def do_label(self, arg):
        '''Get or set the filesystem label of an OPEN disk: label <name> [new_label]

        UNDER THE HOOD:
        1.  Validation: Verifies that the disk is currently open/unlocked.
        2.  Identification: Queries the filesystem type (ext4, xfs, etc.) via 'lsblk'.
        3.  Labeling:
            - ext4: Uses 'e2label' on the active device.
            - xfs: Requires a temporary unmount, then uses 'xfs_admin -L', then remounts.
        4.  Refresh: Executes 'udevadm trigger' to force tools like 'lsblk' to see the change.
        
        The label is written directly to the disk hardware and persists across different computers.
        '''
        parser = CmdArgumentParser(prog='label', add_help=False)
        parser.add_argument('name')
        parser.add_argument('new_label', nargs='?')
        
        try:
            split_args = shlex.split(arg)
            args = parser.parse_args(split_args)
        except argparse.ArgumentError as e:
            log(str(e), 'ERROR')
            return
        except SystemExit:
            return

        name = args.name
        new_label = args.new_label
        
        # Resolve target device
        target_dev = None
        mapper_path = f"/dev/mapper/{name}"
        
        if os.path.exists(mapper_path):
            target_dev = mapper_path
        else:
            self.mappings = read_luks_map()
            if name in self.mappings:
                src = self.mappings[name]
                if not os.path.exists(src):
                    log(f"Device for mapping '{name}' is missing: {src}", 'ERROR')
                    return
                
                devnode = os.path.realpath(src)
                # Check if it's LUKS
                try:
                    res = run_command(['cryptsetup', 'isLuks', devnode], sudo=True, check=False)
                    if res.returncode == 0:
                        log(f"Mapping '{name}' is LUKS but not open. Please 'open {name}' first.", 'ERROR')
                        return
                    # if returncode != 0, it's not LUKS, which is what we want for a plain disk
                except:
                    pass
                
                target_dev = devnode
            else:
                log(f"Device not found or unknown mapping: {name}", 'ERROR')
                return
             
        # Get info
        try:
            cmd = ['lsblk', '-J', '-o', 'FSTYPE,MOUNTPOINT,LABEL', target_dev]
            res = run_command(cmd, capture_output=True)
            data = json.loads(res.stdout)
            dev = data.get('blockdevices', [{}])[0]
            fstype = dev.get('fstype')
            mountpoint = dev.get('mountpoint')
            current_label = dev.get('label')
        except Exception as e:
            log(f"Failed to inspect device: {e}", 'ERROR')
            return
            
        if not new_label:
            print(f"Label for {name} ({fstype}): {current_label if current_label else '<none>'}")
            return
            
        if current_label == new_label:
            log("Label is already set to that value.")
        else:
            log(f"Changing label: '{current_label}' -> '{new_label}' ({fstype})")
            
            if fstype == 'ext4':
                try:
                    run_command(['e2label', target_dev, new_label], sudo=True)
                    run_command(['udevadm', 'trigger', '--name-match=' + target_dev], sudo=True)
                    run_command(['udevadm', 'settle'], sudo=True)
                    log("Label updated.")
                except:
                    pass # run_command logs error
            elif fstype == 'xfs':
                # XFS requires unmount
                remount_needed = False
                targets = find_mount_targets(target_dev)
                if targets:
                    log(f"XFS requires unmounting to label. Unmounting {', '.join(targets)}...")
                    try:
                        for mp in targets:
                            run_command(['umount', mp], sudo=True)
                        remount_needed = True
                        # Best effort: restore the "primary" mount after relabel.
                        mountpoint = mountpoint or targets[0]
                    except Exception as e:
                        log(f"Failed to unmount: {e}", 'ERROR')
                        return

                try:
                    run_command(['xfs_admin', '-L', new_label, target_dev], sudo=True)
                    run_command(['udevadm', 'trigger', '--name-match=' + target_dev], sudo=True)
                    run_command(['udevadm', 'settle'], sudo=True)
                    log("Label updated.")
                except:
                    pass
                finally:
                    if remount_needed:
                        log(f"Remounting {mountpoint}...")
                        try:
                             run_command(['mount', target_dev, mountpoint], sudo=True)
                             targets = find_mount_targets(target_dev)
                             mountpoint = targets[0] if targets else None
                        except Exception as e:
                            log(f"Failed to remount: {e}. You may need to mount manually.", 'ERROR')

            else:
                log(f"Unsupported filesystem for labeling: {fstype}", 'ERROR')
                return

    def do_remount(self, arg):
        '''Remount an OPEN disk to its label mountpoint: remount <name>

        This fixes "mounted twice" and "data1/data2 suffix" issues by moving the mount
        to the canonical path: /media/$USER/<label>.

        SAFETY RULES:
        - Refuses if the target mountpoint is already mounted by a different device.
        - Refuses if the target directory exists, is not a mountpoint, and is non-empty.
        - Refuses if the filesystem has no LABEL (set one with: label <name> <new_label>).

        UNDER THE HOOD:
        1.  Resolve Device: Uses /dev/mapper/<name> if present, otherwise the mapped source path.
            If the mapping is LUKS and not OPEN, it refuses.
        2.  Identify Label: Reads the filesystem LABEL via blkid.
        3.  Preflight: Validates /media/$USER/<label> is safe to use.
        4.  Unmount: Unmounts all current mount targets for the device (if any).
        5.  Cleanup: Removes empty old mountpoint directories under /media/$USER (best-effort rmdir).
        6.  Mount: Mounts the device at /media/$USER/<label>.
        '''
        parser = CmdArgumentParser(prog='remount', add_help=False)
        parser.add_argument('name')

        try:
            split_args = shlex.split(arg)
            args = parser.parse_args(split_args)
        except argparse.ArgumentError as e:
            log(str(e), 'ERROR')
            return
        except SystemExit:
            return

        name = args.name

        # Resolve target device (must be OPEN if it's LUKS).
        target_dev = None
        mapper_path = f"/dev/mapper/{name}"
        if os.path.exists(mapper_path):
            target_dev = mapper_path
        else:
            self.mappings = read_luks_map()
            if name not in self.mappings:
                log(f"Device not found or unknown mapping: {name}", 'ERROR')
                return

            src = self.mappings[name]
            if not os.path.exists(src):
                log(f"Device for mapping '{name}' is missing: {src}", 'ERROR')
                return

            devnode = os.path.realpath(src)
            try:
                res = run_command(['cryptsetup', 'isLuks', devnode], sudo=True, check=False)
                if res.returncode == 0:
                    log(f"Mapping '{name}' is LUKS but not open. Please 'open {name}' first.", 'ERROR')
                    return
            except:
                pass

            target_dev = devnode

        # Determine label -> preferred mountpoint.
        label = ""
        try:
            res_b = run_command(['blkid', '-o', 'value', '-s', 'LABEL', target_dev], sudo=True, check=False)
            label = res_b.stdout.strip()
        except:
            pass

        if not label:
            log(f"REMOUNT BLOCKED: {name} has no filesystem label. Set one with: label {name} <new_label>", 'ERROR')
            return

        user = os.environ.get('USER', 'root')
        new_mountpoint = f"/media/{user}/{label}"

        # Safety: is target mountpoint already in use by another device?
        res_check = run_command(['findmnt', '-rn', '-M', new_mountpoint], check=False)
        if res_check.returncode == 0:
            res_src = run_command(['findmnt', '-rn', '-M', new_mountpoint, '-o', 'SOURCE'], check=False)
            current_src = os.path.realpath(res_src.stdout.strip()) if res_src.stdout.strip() else ""
            if current_src and current_src != os.path.realpath(target_dev):
                log(f"REMOUNT BLOCKED: Mountpoint {new_mountpoint} is already in use by {current_src}.", 'ERROR')
                return

        # Figure out where it's mounted now (may be multiple targets).
        current_targets = find_mount_targets(target_dev)

        if new_mountpoint in current_targets:
            extra = [t for t in current_targets if t != new_mountpoint]
            if not extra:
                log(f"Already mounted at {new_mountpoint}.")
                return

            log(f"Disk is also mounted at {', '.join(extra)}. Unmounting extra mount(s)...")
            try:
                for mp in extra:
                    run_command(['umount', mp], sudo=True)
                    cleanup_mountpoint_dir(mp)
            except Exception as e:
                log(f"Failed to unmount extra mount(s): {e}", 'ERROR')
            return

        if current_targets:
            log(f"Unmounting {', '.join(current_targets)} for remount...")
            try:
                for mp in current_targets:
                    run_command(['umount', mp], sudo=True)
                    if mp != new_mountpoint:
                        cleanup_mountpoint_dir(mp)
            except Exception as e:
                log(f"Failed to unmount existing mount(s): {e}", 'ERROR')
                return

        # Target dir exists but isn't a mountpoint; it must be empty to be safe to mount over.
        if os.path.exists(new_mountpoint):
            if run_command(['findmnt', '-rn', '-M', new_mountpoint], check=False).returncode != 0:
                try:
                    if os.path.isdir(new_mountpoint) and os.listdir(new_mountpoint):
                        log(f"REMOUNT BLOCKED: Directory {new_mountpoint} exists and is not empty.", 'ERROR')
                        return
                except Exception as e:
                    log(f"REMOUNT BLOCKED: Unable to inspect {new_mountpoint}: {e}", 'ERROR')
                    return

        log(f"Mounting {target_dev} to {new_mountpoint}...")
        try:
            run_command(['mkdir', '-p', new_mountpoint], sudo=True)
            run_command(['mount', target_dev, new_mountpoint], sudo=True)
            log(f"Remounted successfully at {new_mountpoint}")
        except Exception as e:
            log(f"Failed to mount at {new_mountpoint}: {e}", 'ERROR')

    def do_luks(self, arg):
        '''LUKS encryption management: luks <passwd|backup|restore> [options]
        
        Subcommands:
          passwd <name>           Change the LUKS passphrase.
          backup <name> [file]    Save the LUKS header to a file.
          restore <name> <file>   Restore the LUKS header from a file (Destructive).
        '''
        args = arg.split()
        if not args:
            self.do_help('luks')
            return

        subcmd = args[0]
        sub_args = args[1:]

        if subcmd == 'passwd':
            if not sub_args:
                log("Usage: luks passwd <name>", 'ERROR')
                return
            name = sub_args[0]
            src = self.resolve_target(name, allow_id=False)
            if not src:
                log(f"Unknown mapping: '{name}'.", 'ERROR')
                return
            devnode = os.path.realpath(src)
            res = run_command(['cryptsetup', 'isLuks', devnode], sudo=True, check=False)
            if res.returncode != 0:
                log(f"Device {name} ({devnode}) is not a LUKS encrypted device.", 'ERROR')
                return
            log(f"Starting passphrase change for {name} ({devnode})...")
            try:
                run_command(['cryptsetup', 'luksChangeKey', devnode], sudo=True, capture_output=False)
                log("Passphrase updated successfully.")
            except Exception as e:
                log(f"Failed to change passphrase: {e}", 'ERROR')

        elif subcmd == 'backup':
            if not sub_args:
                log("Usage: luks backup <name> [filename]", 'ERROR')
                return
            name = sub_args[0]
            filename = sub_args[1] if len(sub_args) > 1 else f"{name}.header.bak"
            src = self.resolve_target(name)
            if not src:
                log(f"Unknown target: '{name}'", 'ERROR')
                return
            devnode = os.path.realpath(src)
            res = run_command(['cryptsetup', 'isLuks', devnode], sudo=True, check=False)
            if res.returncode != 0:
                log(f"Device {devnode} is not a valid LUKS device.", 'ERROR')
                return
            log(f"Backing up LUKS header from {name} ({devnode}) to {filename}...")
            try:
                run_command(['cryptsetup', 'luksHeaderBackup', devnode, '--header-backup-file', filename], sudo=True)
                log(f"Header backup successful: {filename}")
            except Exception as e:
                log(f"Backup failed: {e}", 'ERROR')

        elif subcmd == 'restore':
            if len(sub_args) < 2:
                log("Usage: luks restore <name> <filename>", 'ERROR')
                return
            name, filename = sub_args[0], sub_args[1]
            if not os.path.exists(filename):
                log(f"Backup file not found: {filename}", 'ERROR')
                return
            src = self.resolve_target(name)
            if not src:
                log(f"Unknown target: '{name}'", 'ERROR')
                return
            devnode = os.path.realpath(src)
            log(f"RESTORE WARNING: About to overwrite LUKS header on {name} ({devnode}) using {filename}")
            if not self.extensive_confirm(name):
                return
            run_command(['sudo', '-v'])
            try:
                run_command(['cryptsetup', 'luksHeaderRestore', devnode, '--header-backup-file', filename], sudo=True)
                log("Header restore completed successfully.")
            except Exception as e:
                log(f"Restore failed: {e}", 'ERROR')
        else:
            log(f"Unknown LUKS subcommand: {subcmd}", 'ERROR')
            self.do_help('luks')

    def do_erase(self, arg):
        '''Securely erase a disk: erase <name> [options]
        
        Note: You must 'map' a disk first to give it a name before erasing it.
        
        NUANCES & SAFETY:
        - Whole Disk (sda): 
          Attempts deep hardware-level wipes (NVMe Sanitize, ATA Secure Erase, etc.). 
          Destroys the Partition Table and ALL partitions on the drive.
        - Partition (sda2): 
          Hardware-level wipes are SKIPPED for safety. The script falls back to 
          highly effective software wipes (blkdiscard or dd zero-overwrite).
          ONLY the specified partition is wiped; other partitions remain safe.
        - Mapped Name (1a): 
          Resolves to the physical partition and follows partition-level safety rules.
        
        UNDER THE HOOD:
        1.  Target Resolution: Maps friendly name to a raw block device.
        2.  Destructive Wipe:
            - NVMe: Prioritizes (1) Sanitize Crypto Erase, (2) Sanitize Block Erase, 
              (3) Format Crypto Erase, and (4) Format Block Erase.
            - SSD: Prioritizes (1) PSID Revert, (2) ATA Sanitize, (3) ATA Secure Erase (Enhanced), 
              (4) ATA Secure Erase (Standard), (5) blkdiscard --secure, and (6) blkdiscard.
            - HDD: Prioritizes (1) ATA Sanitize, (2) ATA Secure Erase (Enhanced), 
              (3) ATA Secure Erase (Standard), and (4) Zero Overwrite + Verify.
        3.  Verification: Executes 'udevadm settle' and 'sync' to ensure all operations are committed.
        
        Note: This is a DESTRUCTIVE operation. Solving two math problems is MANDATORY to proceed.

        WARNING: This operation is IRREVERSIBLE.
        '''
        parser = CmdArgumentParser(prog='erase', add_help=False)
        parser.add_argument('target', help='Target name or device')
        
        try:
            split_args = shlex.split(arg)
            args = parser.parse_args(split_args)
        except argparse.ArgumentError as e:
            log(str(e), 'ERROR')
            return
        except SystemExit:
            return

        name = args.target
        real_target = self.resolve_target(name, allow_id=False)
        
        if not real_target:
            log(f"Unknown mapping: '{name}'. You must 'map' a disk before you can erase it.", 'ERROR')
            return
        
        if not os.path.exists(real_target):
            log(f"Target not found: {real_target}", 'ERROR')
            return
            
        real_target = os.path.realpath(real_target)
        log(f"Target resolved: {real_target}")
        
        if self.is_root_disk(real_target):
            log(f"OPERATION BLOCKED: {real_target} is part of the system root drive!", 'ERROR')
            return

        if not self.extensive_confirm(real_target):
            return

        run_command(['sudo', '-v'])
        
        # Unmount dependencies?
        # TODO: checking mounts
        
        if secure_erase_disk(real_target):
            log("Secure erase completed successfully.")
        else:
            log("Secure erase failed.", 'ERROR')

    def do_clone(self, arg):
        '''Clone one disk or partition to another: clone <src_name> <dst_name>
        
        WARNING (DATA DESTRUCTION):
        - This command writes directly to the destination block device (like running dd).
        - The destination is overwritten starting at byte 0. Any existing partition table,
          filesystems, and files on the destination WILL BE DESTROYED.
        - If the destination is larger than the source, bytes beyond the source size are
          not overwritten. Old data may still physically exist there, but it will not be
          referenced by the cloned partition table.
        - diskmgr does NOT unmount the destination for you. Unmount/close it first to
          avoid live corruption.
        - If you need to sanitize the destination, run: erase <dst_name>

        Note: The target disk MUST be the same size or larger than the source.
        
        STEP-BY-STEP PROCESS:
        1.  Resolution: Maps both friendly names to their physical device nodes (PDP).
        2.  Size Validation: Queries 'blockdev --getsize64' for both. Aborts if dst < src.
        3.  Safety Audit: Verifies that the target is NOT the system root drive.
        4.  Confirmation: Requires solving two math problems to authorize data destruction.
        5.  Cloning: Executes 'dd' with 16MiB buffers and direct I/O for maximum throughput.
        6.  Sync: Flushes kernel buffers to ensure all data is physically committed to disk.

        Note: This is a DESTRUCTIVE operation. Solving two math problems is MANDATORY to proceed.

        SCENARIOS:
        - Drive to Drive: 
          Creates a 1:1 bit-perfect clone. The target disk becomes an identical twin, 
          including the Partition Table, UUIDs, and all partitions. 
          Note: If the target is larger, the extra space appears as 'free' at the end.
        - Partition to Partition: 
          Copies the internal data of the source partition into the target partition. 
          Useful for moving a LUKS container or a specific filesystem. 
          Warning: Filesystem UUIDs will be duplicated; avoid mounting both simultaneously.
        - Partition to Drive: 
          The source partition's content is written to the start of the physical disk. 
          This destroys the target's partition table and turns the disk into a 
          "partitionless" volume (e.g., a raw LUKS device).
        - Drive to Partition (DANGEROUS): 
          Writes the source's boot sectors and partition table into the target partition. 
          This usually results in an unreadable "nested" structure.

        CLONING & ENCRYPTION (CRITICAL):
        - Source is LOCKED (e.g., clone sda sdb): 
          Creates a bit-perfect "Encrypted Twin." The destination remains encrypted 
          and requires the same password. (Recommended for backups).
        - Source is OPEN (e.g., clone sda sdb): 
          Copies encrypted data but may capture a "dirty" filesystem state if 
          files are currently being written. (Close before cloning if possible).
        - Source is MAPPER (e.g., clone dm-0 sdb): 
          Performs a "Strip-and-Clone." The destination receives RAW DECRYPTED 
          DATA. The resulting clone will be completely UNENCRYPTED.
        '''
        args = arg.split()
        if len(args) != 2:
            log("Usage: clone <src_name> <dst_name>", 'ERROR')
            return

        src_name, dst_name = args
        src_path = self.resolve_target(src_name, allow_id=False)
        dst_path = self.resolve_target(dst_name, allow_id=False)

        if not src_path:
            log(f"Unknown source mapping: '{src_name}'", 'ERROR')
            return
        if not dst_path:
            log(f"Unknown target mapping: '{dst_name}'", 'ERROR')
            return

        src_real = os.path.realpath(src_path)
        dst_real = os.path.realpath(dst_path)

        if src_real == dst_real:
            log("Source and target are the same device!", 'ERROR')
            return

        if self.is_root_disk(dst_real):
            log(f"OPERATION BLOCKED: {dst_name} ({dst_real}) is the system root drive!", 'ERROR')
            return

        # Compare sizes
        try:
            src_bytes = int(run_command(['sudo', 'blockdev', '--getsize64', src_real], capture_output=True).stdout.strip())
            dst_bytes = int(run_command(['sudo', 'blockdev', '--getsize64', dst_real], capture_output=True).stdout.strip())
            
            if dst_bytes < src_bytes:
                log(f"Target disk is too small! (Source: {src_bytes}B, Target: {dst_bytes}B)", 'ERROR')
                return
        except Exception as e:
            log(f"Failed to verify disk sizes: {e}", 'ERROR')
            return

        # Confirmation
        if not self.extensive_confirm(f"{dst_name} ({dst_real})"):
            return

        run_command(['sudo', '-v'])
        log(f"Cloning {src_name} -> {dst_name}...")
        
        # Perform clone
        try:
            # dd if=src of=dst bs=16M status=progress oflag=direct conv=fsync
            cmd = ['dd', f'if={src_real}', f'of={dst_real}', 'bs=16M', 'status=progress', 'oflag=direct', 'conv=fsync']
            run_command(cmd, sudo=True)
            log("Cloning complete.")
        except Exception as e:
            log(f"Cloning failed: {e}", 'ERROR')

    def do_health(self, arg):
        '''Display SMART health for a mapped disk: health <name>

        Runs smartctl against the underlying DISK device for the mapping.
        - If the mapping points to a partition, diskmgr automatically targets the parent disk.
        - If the disk transport is USB and the device is /dev/sdX, diskmgr uses:
              smartctl -d sat -a /dev/sdX
          (common for USB-SATA bridges).
        '''
        args = arg.split()
        if len(args) != 1:
            log("Usage: health <name>", 'ERROR')
            return

        name = args[0]
        src = self.resolve_target(name, allow_id=False)
        if not src:
            log(f"Unknown mapping: '{name}'", 'ERROR')
            return

        if shutil.which('smartctl') is None:
            log("smartctl not found. Install 'smartmontools' and retry.", 'ERROR')
            return

        mapped_dev = os.path.realpath(src)

        # Always query SMART on the underlying whole-disk device (SMART is not partition-scoped).
        disk_dev = mapped_dev
        try:
            mapped_name = _sysfs_block_name(mapped_dev)
            disk_name = _sysfs_to_parent_disk_name(mapped_name)
            candidate = os.path.realpath(f"/dev/{disk_name}")
            if os.path.exists(candidate):
                disk_dev = candidate
        except Exception:
            # Fall back to the mapped device (best-effort) if sysfs probing fails.
            disk_dev = mapped_dev

        tran = ""
        try:
            res_tran = run_command(['lsblk', '-no', 'TRAN', disk_dev], check=False)
            tran = (getattr(res_tran, 'stdout', '') or '').strip().lower()
        except Exception:
            tran = ""

        use_sat = (tran == 'usb' and os.path.basename(disk_dev).startswith('sd'))
        cmd = ['smartctl', '-a', disk_dev]
        if use_sat:
            cmd = ['smartctl', '-d', 'sat', '-a', disk_dev]

        run_command(['sudo', '-v'])

        res = run_command(cmd, sudo=True, capture_output=True, check=False)
        out = (res.stdout or "")
        err = (res.stderr or "")

        # If SAT probing fails on a USB bridge, retry without -d sat as a best-effort fallback.
        if use_sat and res.returncode != 0 and ("Unknown USB bridge" in (out + err) or "Please specify device type" in (out + err)):
            log("smartctl -d sat failed on this USB bridge; retrying without '-d sat'...", 'WARN')
            cmd = ['smartctl', '-a', disk_dev]
            res = run_command(cmd, sudo=True, capture_output=True, check=False)
            out = (res.stdout or "")
            err = (res.stderr or "")

        def _find_first(patterns):
            for p in patterns:
                m = re.search(p, out, re.MULTILINE)
                if m:
                    return m.group(1).strip()
            return None

        overall = _find_first([
            r"^SMART overall-health self-assessment test result:\s*(.+)$",
            r"^SMART Health Status:\s*(.+)$",
        ])
        temp = _find_first([
            r"^Current Temperature:\s*([0-9]+)\s*C",
            r"^Temperature:\s*([0-9]+)\s*C",
            r"^\s*194\s+Temperature_Celsius\s+.*\s([0-9]+)\s*$",
            r"^\s*190\s+Airflow_Temperature_Cel\s+.*\s([0-9]+)\s*$",
        ])
        poh = _find_first([
            r"^Power On Hours:\s*([0-9,]+)",
            r"^\s*9\s+Power_On_Hours\s+.*\s([0-9]+)\s*$",
        ])
        realloc = _find_first([r"^\s*5\s+Reallocated_Sector_Ct\s+.*\s([0-9]+)\s*$"])
        pending = _find_first([r"^\s*197\s+Current_Pending_Sector\s+.*\s([0-9]+)\s*$"])
        offline_unc = _find_first([r"^\s*198\s+Offline_Uncorrectable\s+.*\s([0-9]+)\s*$"])

        mode = "-d sat" if ('-d' in cmd) else "-a"
        extra = f"{tran}" if tran else "unknown transport"
        print(f"\n{Colors.HEADER}--- SMART health: {name} ({extra}, smartctl {mode}) ---{Colors.ENDC}")
        print(f"{Colors.BOLD}Mapped device:{Colors.ENDC} {mapped_dev}")
        if mapped_dev != disk_dev:
            print(f"{Colors.BOLD}SMART queried on:{Colors.ENDC} {disk_dev} (SMART is disk-level, not partition-level)")
        else:
            print(f"{Colors.BOLD}SMART queried on:{Colors.ENDC} {disk_dev}")

        if overall or temp or poh or realloc or pending or offline_unc:
            if overall:
                print(f"{Colors.BOLD}Overall:{Colors.ENDC} {overall}")
            if temp:
                print(f"{Colors.BOLD}Temp:{Colors.ENDC} {temp} C")
            if poh:
                print(f"{Colors.BOLD}Power-on hours:{Colors.ENDC} {poh}")
            if realloc:
                print(f"{Colors.BOLD}Reallocated sectors:{Colors.ENDC} {realloc}")
            if pending:
                print(f"{Colors.BOLD}Pending sectors:{Colors.ENDC} {pending}")
            if offline_unc:
                print(f"{Colors.BOLD}Offline uncorrectable:{Colors.ENDC} {offline_unc}")
            print("")

        if out.strip():
            print(out.rstrip())
        if err.strip():
            print(err.rstrip(), file=sys.stderr)

        # smartctl uses a bitmask exit code; non-zero can mean "drive has issues" and is still useful output.
        if getattr(res, 'returncode', 0) != 0:
            log(f"smartctl exit status: {res.returncode} (non-zero may indicate SMART warnings).", 'WARN')

    def do_refresh(self, arg):
        '''Refresh a disk to combat bit rot: refresh <name>

        This is a DESTRUCTIVE operation. It performs a chronological process of elimination:

        1) Pre-Write Log (Baseline, read-only):
           ddrescue --readonly <dev> /dev/null baseline.map
           Any '-' blocks in baseline.map are classified as "natural" (pre-existing) bad sectors / bit rot.

        2) Refresh Pass (write):
           ddrescue --force <dev> <dev> refresh.map
           If refresh.map shows new '-' blocks not present in baseline.map, they are classified as
           "interruption" corruption (often power-loss / crash during the refresh).

        3) After ddrescue completes:
           Zero-fill the "natural" bad ranges to force the drive to remap sectors (best-effort).

        FILE MAPPING (ext* only):
        If debugfs is available and the target is an ext filesystem, diskmgr will attempt to map bad
        blocks to filenames using debugfs icheck/ncheck output.
        '''
        args = arg.split()
        if len(args) != 1:
            log("Usage: refresh <name>", 'ERROR')
            return

        name = args[0]
        src = self.resolve_target(name, allow_id=False)
        if not src:
            log(f"Unknown mapping: '{name}'", 'ERROR')
            return

        if shutil.which('ddrescue') is None:
            log("ddrescue not found. Install 'gddrescue' and retry.", 'ERROR')
            return

        mapped_dev = os.path.realpath(src)
        if not os.path.exists(mapped_dev):
            log(f"Device not found: {mapped_dev}", 'ERROR')
            return

        if self.is_root_disk(mapped_dev):
            log(f"OPERATION BLOCKED: {name} ({mapped_dev}) is part of the system root drive!", 'ERROR')
            return

        work_dev = _pick_refresh_device(name, mapped_dev)

        # Refuse to run while mounted (or with an active mount via aliases).
        if _device_is_mounted(work_dev):
            log(f"{work_dev} is mounted. Unmount/close it first (use 'close {name}').", 'ERROR')
            return

        # If we're about to write to a raw block device that has an active dm holder, abort.
        # (Example: writing to /dev/sda2 while dm-0 exists.)
        try:
            holders_dir = f"/sys/class/block/{_sysfs_block_name(mapped_dev)}/holders"
            if os.path.isdir(holders_dir):
                holders = [x for x in os.listdir(holders_dir) if x]
                if holders and work_dev == mapped_dev:
                    log(f"{mapped_dev} has active holders ({', '.join(holders)}). Close it first.", 'ERROR')
                    return
        except Exception:
            pass

        if not self.extensive_confirm(f"{name} ({work_dev})"):
            return

        run_command(['sudo', '-v'])

        # Log directory for this run
        ts = time.strftime("%Y%m%d-%H%M%S")
        logdir = get_script_dir() / "refresh_logs" / f"{name}-{ts}"
        os.makedirs(logdir, exist_ok=True)
        baseline_map = str(logdir / "baseline.map")
        refresh_map = str(logdir / "refresh.map")
        report_path = str(logdir / "report.txt")

        log(f"Refresh logs: {logdir}")
        log("Step A: Baseline read-only pass (pre-write log)...")

        # ddrescue option name differs by build; try --readonly then --ro-mode as fallback.
        baseline_cmd = ['ddrescue', '--readonly', work_dev, '/dev/null', baseline_map]
        res_b = run_command(baseline_cmd, sudo=True, capture_output=False, check=False)
        if getattr(res_b, 'returncode', 1) != 0:
            baseline_cmd = ['ddrescue', '--ro-mode', work_dev, '/dev/null', baseline_map]
            res_b = run_command(baseline_cmd, sudo=True, capture_output=False, check=False)
            if getattr(res_b, 'returncode', 1) != 0:
                log(f"Baseline ddrescue failed (map: {baseline_map}).", 'ERROR')
                return

        log("Step B: Refresh pass (in-place write)...")
        refresh_cmd = ['ddrescue', '--force', work_dev, work_dev, refresh_map]
        res_r = run_command(refresh_cmd, sudo=True, capture_output=False, check=False)
        if getattr(res_r, 'returncode', 1) != 0:
            log(f"Refresh ddrescue failed (map: {refresh_map}).", 'ERROR')
            return

        # Process maps
        baseline_bad = _parse_ddrescue_bad_intervals(baseline_map, bad_status='-')
        refresh_bad = _parse_ddrescue_bad_intervals(refresh_map, bad_status='-')

        # "Interruption" corruption is anything that appears after the refresh but wasn't present pre-write.
        interruption_bad = _subtract_intervals(refresh_bad, baseline_bad)

        # Best-effort file mapping (ext* only)
        debug_lines = []
        debugfs_bin = shutil.which('debugfs')
        fs_dev = work_dev
        fstype = ""
        try:
            res_fs = run_command(['lsblk', '-no', 'FSTYPE', fs_dev], check=False)
            fstype = (getattr(res_fs, 'stdout', '') or '').strip()
        except Exception:
            fstype = ""

        can_debugfs = bool(debugfs_bin) and (fstype.startswith('ext'))

        def _debugfs_block_size(dev):
            res = run_command(['debugfs', '-R', 'stats', dev], sudo=True, capture_output=True, check=False)
            out = getattr(res, 'stdout', '') or ''
            m = re.search(r"Block size:\s*([0-9]+)", out)
            if m:
                try:
                    return int(m.group(1))
                except ValueError:
                    return None
            return None

        def _debugfs_block_to_paths(dev, blockno, inode_cache):
            # icheck <block> -> inodes; then ncheck <inode> -> paths
            res_i = run_command(['debugfs', '-R', f'icheck {blockno}', dev], sudo=True, capture_output=True, check=False)
            out_i = getattr(res_i, 'stdout', '') or ''
            inodes = []
            for m in re.finditer(r"\binode\s+([0-9]+)\b", out_i):
                inodes.append(m.group(1))
            paths = []
            for ino in inodes[:5]:
                if ino in inode_cache:
                    paths.extend(inode_cache[ino])
                    continue
                res_n = run_command(['debugfs', '-R', f'ncheck {ino}', dev], sudo=True, capture_output=True, check=False)
                out_n = getattr(res_n, 'stdout', '') or ''
                found = []
                for line in out_n.splitlines():
                    line = line.strip()
                    if not line or line.lower().startswith('inode'):
                        continue
                    # Common format: "<ino>\t/path"
                    parts = line.split(None, 1)
                    if len(parts) == 2 and parts[0].isdigit():
                        found.append(parts[1].strip())
                inode_cache[ino] = found
                paths.extend(found)
            # de-dupe, keep order
            out = []
            for p in paths:
                if p and p not in out:
                    out.append(p)
            return out

        if can_debugfs and (baseline_bad or interruption_bad):
            bs = _debugfs_block_size(fs_dev)
            if not bs:
                can_debugfs = False
            else:
                inode_cache = {}
                debug_lines.append(f"debugfs device: {fs_dev} (block size {bs})")

                # Show up to a bounded number of blocks across all bad ranges.
                max_blocks = 120
                shown = 0

                def _emit_ranges(title, ranges):
                    nonlocal shown
                    if not ranges or shown >= max_blocks:
                        return
                    debug_lines.append("")
                    debug_lines.append(title)
                    for s, e in ranges:
                        if shown >= max_blocks:
                            break
                        # Convert byte range to filesystem block range.
                        b0 = s // bs
                        b1 = (e - 1) // bs
                        # Sample: first, last, and a few in the middle.
                        blocks = [b0]
                        if b1 != b0:
                            blocks.append(b1)
                        span = b1 - b0
                        for frac in [0.25, 0.5, 0.75]:
                            if shown + len(blocks) >= max_blocks:
                                break
                            if span > 8:
                                blocks.append(b0 + int(span * frac))
                        # De-dupe
                        uniq = []
                        for b in blocks:
                            if b not in uniq:
                                uniq.append(b)
                        for b in uniq:
                            if shown >= max_blocks:
                                break
                            paths = _debugfs_block_to_paths(fs_dev, b, inode_cache)
                            if paths:
                                debug_lines.append(f"  block {b} [{paths[0]}]")
                            else:
                                debug_lines.append(f"  block {b} [-]")
                            shown += 1

                _emit_ranges("Natural bit rot blocks (baseline '-'): ", baseline_bad)
                _emit_ranges("Interruption corruption blocks (new '-' after refresh): ", interruption_bad)
                if shown >= max_blocks:
                    debug_lines.append(f"... truncated at {max_blocks} blocks")

        # Print and write report
        def _fmt_bytes(n):
            try:
                n = int(n)
            except Exception:
                return str(n)
            for unit in ['B', 'KiB', 'MiB', 'GiB', 'TiB']:
                if n < 1024 or unit == 'TiB':
                    return f"{n:.0f}{unit}" if unit == 'B' else f"{n:.1f}{unit}"
                n /= 1024.0

        natural_bytes = sum((e - s) for s, e in baseline_bad)
        interruption_bytes = sum((e - s) for s, e in interruption_bad)

        lines = []
        lines.append(f"refresh report: {name}")
        lines.append(f"mapped_dev: {mapped_dev}")
        lines.append(f"work_dev:   {work_dev}")
        lines.append(f"baseline.map: {baseline_map}")
        lines.append(f"refresh.map:  {refresh_map}")
        lines.append("")
        lines.append(f"Natural bit rot (baseline '-'): {len(baseline_bad)} ranges, {_fmt_bytes(natural_bytes)}")
        lines.append(f"Interruption corruption (new '-'): {len(interruption_bad)} ranges, {_fmt_bytes(interruption_bytes)}")
        if interruption_bad:
            lines.append("NOTE: New '-' ranges appeared after refresh. These are more consistent with interruption/crash during the write pass.")
            lines.append("      Consider re-running refresh, checking cables/power, and restoring from backup rather than zero-filling blindly.")
        if not baseline_bad and not interruption_bad:
            lines.append("No '-' ranges detected in baseline/refresh maps.")

        if debug_lines:
            lines.append("")
            lines.extend(debug_lines)
        else:
            if (baseline_bad or interruption_bad) and not can_debugfs:
                lines.append("")
                lines.append("debugfs mapping skipped (debugfs missing or filesystem is not ext* on the refresh device).")

        with open(report_path, 'w', encoding='utf-8') as f:
            f.write("\n".join(lines) + "\n")

        print(f"\n{Colors.HEADER}--- Refresh Report: {name} ---{Colors.ENDC}")
        print("\n".join(lines))
        print(f"\n{Colors.OKGREEN}Report saved:{Colors.ENDC} {report_path}")

        # Zero-fill only the "natural" bad ranges by default (safer than zeroing newly-bad ranges).
        if baseline_bad:
            log("Zero-filling natural bad ranges to force sector remap (best-effort)...")
            for s, e in baseline_bad:
                # Align to 512B sectors.
                s2 = (s // 512) * 512
                e2 = ((e + 511) // 512) * 512
                if e2 <= s2:
                    continue
                seek = s2 // 512
                count = (e2 - s2) // 512
                try:
                    run_command(['dd', 'if=/dev/zero', f'of={work_dev}', 'bs=512',
                                 f'seek={seek}', f'count={count}', 'conv=notrunc', 'oflag=direct'],
                                sudo=True, capture_output=False)
                except Exception as ex:
                    log(f"Zero-fill failed at byte {s2}: {ex}", 'WARN')
            run_command(['sync'], sudo=True, check=False)
            log("Zero-fill complete.")

    def get_mountpoint(self, name):
        '''Resolves the current mountpoint for a friendly name.'''
        self.mappings = read_luks_map()
        if name not in self.mappings:
            return None
        
        src = self.mappings[name]
        devnode = os.path.realpath(src)
        
        # Check if it's LUKS and open
        mapper_path = f"/dev/mapper/{name}"
        target = mapper_path if os.path.exists(mapper_path) else devnode
        
        targets = find_mount_targets(target)
        if not targets:
            return None

        preferred = f"/media/{os.environ.get('USER', 'root')}/{name}"
        return preferred if preferred in targets else targets[0]

    def do_sync(self, arg):
        '''Synchronize two mounted disks: sync <secondary_name> <primary_name>
        
        UNDER THE HOOD:
        1.  Validation: Verifies both disks are mapped and currently mounted.
        2.  Confirmation: Requires solving two math problems (DESTRUCTIVE for secondary).
        3.  Execution: Runs 'rsync -avh --delete --progress <primary_mnt>/ <secondary_mnt>/'.
        
        Note: The SECONDARY disk will be modified to match the PRIMARY disk.
        All files on the secondary that do not exist on the primary will be DELETED.
        '''
        args = arg.split()
        if len(args) != 2:
            log("Usage: sync <secondary_name> <primary_name>", 'ERROR')
            return

        secondary, primary = args
        
        sec_mnt = self.get_mountpoint(secondary)
        pri_mnt = self.get_mountpoint(primary)
        
        if not sec_mnt:
            log(f"Secondary disk '{secondary}' is not mounted.", 'ERROR')
            return
        if not pri_mnt:
            log(f"Primary disk '{primary}' is not mounted.", 'ERROR')
            return

        print(f"Syncing: {Colors.BOLD}{pri_mnt}/{Colors.ENDC} -> {Colors.WARNING}{sec_mnt}/{Colors.ENDC}")
        
        if not self.extensive_confirm(secondary):
            return

        run_command(['sudo', '-v'])
        log(f"Starting rsync: {primary} -> {secondary}...")
        
        try:
            # Ensure trailing slashes for rsync to sync directory CONTENTS
            src_path = pri_mnt.rstrip('/') + '/'
            dst_path = sec_mnt.rstrip('/') + '/'
            
            cmd = ['rsync', '-avh', '--delete', '--progress', src_path, dst_path]
            # Use sudo if mountpoints are owned by root
            run_command(cmd, sudo=True, capture_output=False)
            log("Sync complete.")
        except Exception as e:
            log(f"Sync failed: {e}", 'ERROR')

    def do_create(self, arg):
        '''Initialize a disk: create <name> [options]
        
        Note: You must 'map' a disk first to give it a name before initializing it.
        
        NUANCES & SCOPE:
        1. Running create on a Partition (e.g., sda2)
           The Result: Container-in-a-Box.
           The script treats the existing partition as its "entire world."
           - Partitioning: It skips the GPT/MBR step because you've already given it a partition.
           - Encryption: It sets up LUKS directly inside the sda2 boundary.
           - Filesystem: It formats the area inside sda2.
           - The Big Picture: The rest of your disk (like sda1 or sda3) is untouched. 
             You are simply replacing whatever was inside partition #2 with a new encrypted volume.

        2. Running create on a Whole Disk (e.g., sda)
           The Result: Total Takeover.
           The script wipes the slate clean and rebuilds the drive from scratch.
           - Wipe: It deletes the Partition Table (GPT/MBR) at the start of the disk. 
             All existing partitions (sda1, sda2, etc.) are instantly lost.
           - Rebuild:
             * If you didn't use --gpt or --mbr: It formats the Entire Disk as one 
               giant LUKS container (no partition table).
             * If you used --gpt: It creates a fresh GPT table, creates a new 
               partition #1 spanning the whole drive, and puts LUKS inside that.
           - The Big Picture: You lose everything on the physical drive, and it 
             becomes a single, clean encrypted volume.

        3. Using --plain with --gpt or --mbr
           The Result: Standard Unencrypted Disk.
           - Partitioning: Creates a fresh GPT/MBR table and one primary partition.
           - Encryption: Skipped entirely.
           - Mapping: The friendly name in diskmap.tsv points directly to the 
             raw hardware partition (e.g., /dev/disk/by-id/...-part1).
           - The Big Picture: You get a standard unencrypted partitioned volume 
             manageable via diskmgr's persistent naming.
        
        Options:
          --fs <ext4|xfs>   Filesystem type (default: ext4)
          --label <label>   Set a different internal filesystem label (other than <name>)
          --plain           Create a non-encrypted disk (skips LUKS)
          --gpt             Create GPT partition table + 1 partition (Whole disk only)
          --mbr             Create MBR partition table + 1 partition (Whole disk only)
        
        UNDER THE HOOD:
        1.  Unmount: Forcefully unmounts any existing partitions on the target.
        2.  Wipe: Executes 'wipefs' to remove old filesystem signatures.
        3.  Partitioning (Optional): Uses 'sgdisk' (GPT) or 'sfdisk' (MBR) to create a single partition.
        4.  LUKS Format (Default):
            - Uses 'passgen' to generate a master key.
            - Runs 'cryptsetup luksFormat' with LUKS2 encryption.
        5.  Filesystem: 
            - Formats the cleartext device with ext4 or xfs.
            - (ext4 only): Reclaims the 5% reserved space for root using 'tune2fs -m 0'.
        6.  Persistence: Adds the new disk's PDP to diskmap.tsv automatically.

        Note: This is a DESTRUCTIVE operation. Solving two math problems is MANDATORY to proceed.
        '''
        parser = CmdArgumentParser(prog='create', add_help=False)
        parser.add_argument('args', nargs=1, help='<name>')
        parser.add_argument('--fs', default='ext4', choices=['ext4', 'xfs'])
        parser.add_argument('--label', help='Filesystem label')
        parser.add_argument('--plain', action='store_true', help='No LUKS encryption')
        parser.add_argument('--gpt', action='store_true')
        parser.add_argument('--mbr', action='store_true')

        try:
            split_args = shlex.split(arg)
            args = parser.parse_args(split_args)
        except argparse.ArgumentError as e:
            log(str(e), 'ERROR')
            return
        except SystemExit:
            return

        name = args.args[0]
        target = self.resolve_target(name, allow_id=False)
        if not target:
            log(f"Unknown mapping: '{name}'. You must 'map' a disk before you can initialize it.", 'ERROR')
            return

        # Wait/Verify target existence
        real_target = os.path.realpath(target)
        if not os.path.exists(real_target):
            log(f"Target device not found: {target} (resolved: {real_target})", 'ERROR')
            return
            
        if self.is_root_disk(real_target):
            log(f"OPERATION BLOCKED: {real_target} is part of the system root drive!", 'ERROR')
            return

        log(f"Target: {real_target}")
        log(f"Name: {name}")
        
        # Safety checks
        if not self.extensive_confirm(f"{name} ({real_target})"):
            return

        run_command(['sudo', '-v'])

        # Unmount anything on the disk
        log("Ensuring target is unmounted...")
        # (Simplified unmount check)
        
        # Always do a soft wipe for create
        run_command(['wipefs', '-a', real_target], sudo=True)

        crypt_target = real_target
        
        # Partitioning
        if args.gpt:
            log("Creating GPT partition...")
            run_command(['sgdisk', '--zap-all', real_target], sudo=True)
            run_command(['sgdisk', '-n', f'1:0:0', '-t', '1:8300', '-c', f'1:{name}', real_target], sudo=True)
            run_command(['udevadm', 'settle'], sudo=True)
            # Guess partition name
            if 'nvme' in real_target:
                crypt_target = f"{real_target}p1"
            else:
                crypt_target = f"{real_target}1"
        elif args.mbr:
            log("Creating MBR partition...")
            # using sfdisk scripting
            sfdisk_script = f"label: dos\n{real_target}1 : start=2048, type=83"
            run_command(['sfdisk', '--wipe', 'always', '--wipe-partitions', 'always', real_target], 
                       input_str=sfdisk_script, sudo=True)
            run_command(['udevadm', 'settle'], sudo=True)
             # Guess partition name
            if 'nvme' in real_target:
                crypt_target = f"{real_target}p1"
            else:
                crypt_target = f"{real_target}1"

        if not args.plain:
            # LUKS Format
            log(f"Formatting LUKS on {crypt_target}...")
            pg_cmd = subprocess.Popen([PASSGEN_BIN], stdout=subprocess.PIPE, text=True)
            try:
                run_command(
                    ['cryptsetup', 'luksFormat', '--type', 'luks2', '--batch-mode', '--key-file', '-', crypt_target],
                    input_str=pg_cmd.communicate()[0],
                    sudo=True,
                    check=True
                )
            except Exception as e:
                log(f"LUKS Format failed: {e}", 'ERROR')
                return

            # Open
            log("Opening new LUKS volume...")
            pg_cmd = subprocess.Popen([PASSGEN_BIN], stdout=subprocess.PIPE, text=True)
            run_command(
                ['cryptsetup', 'open', '--key-file', '-', crypt_target, name],
                input_str=pg_cmd.communicate()[0],
                sudo=True,
                check=True
            )
            fs_target = f"/dev/mapper/{name}"
        else:
            fs_target = crypt_target

        # Mkfs
        label = args.label if args.label else name
        log(f"Formatting filesystem {args.fs} (label={label}) on {fs_target}...")
        
        if args.fs == 'ext4':
            run_command(['mkfs.ext4', '-F', '-L', label, fs_target], sudo=True)
            log("Reclaiming 5% reserved space (tune2fs -m 0)...")
            run_command(['tune2fs', '-m', '0', fs_target], sudo=True)
        elif args.fs == 'xfs':
            run_command(['mkfs.xfs', '-f', '-L', label, fs_target], sudo=True)

        # Mount
        mountpoint = f"/media/{os.environ.get('USER', 'root')}/{label}"
        
        # Safety Check: Is this mountpoint already in use by another device?
        res_check = run_command(['findmnt', '-rn', '-M', mountpoint], check=False)
        if res_check.returncode == 0:
            res_src = run_command(['findmnt', '-rn', '-M', mountpoint, '-o', 'SOURCE'], capture_output=True)
            current_src = os.path.realpath(res_src.stdout.strip())
            if current_src != os.path.realpath(fs_target):
                log(f"MOUNT BLOCKED: Path {mountpoint} is already in use by {current_src}.", 'ERROR')
                log("Disk was initialized successfully, but could not be mounted at the preferred path.", 'WARN')
                return

        run_command(['mkdir', '-p', mountpoint], sudo=True)
        run_command(['mount', fs_target, mountpoint], sudo=True)

        # Update map if needed
        self.mappings = read_luks_map()
        if name not in self.mappings:
            stable_path = crypt_target
            # Try to find by-id
            pdp = self.find_persistent_path(os.path.basename(crypt_target))
            if pdp != '-':
                stable_path = pdp
            
            self.mappings[name] = stable_path
            save_luks_map(self.mappings)
            log(f"Added mapping: {name} -> {stable_path}")

        log("Disk initialization complete.")


if __name__ == '__main__':
    try:
        os.chmod(__file__, 0o755)
    except:
        pass
    try:
        DiskMgrShell().cmdloop()
    except KeyboardInterrupt:
        print("\nExiting...")
