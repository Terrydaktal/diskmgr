#!/usr/bin/env python3
import cmd
import subprocess
import os
import sys
import shlex
import csv
import json
import time
import argparse
import random
from pathlib import Path

# Configuration
MAP_FILENAME = 'luksmap.tsv'
PASSGEN_BIN = 'passgen'

# ANSI Colors
class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def log(msg, level='INFO'):
    if level == 'ERROR':
        print(f"{Colors.FAIL}ERROR: {msg}{Colors.ENDC}", file=sys.stderr)
    elif level == 'WARN':
        print(f"{Colors.WARNING}WARNING: {msg}{Colors.ENDC}", file=sys.stderr)
    else:
        print(f"{Colors.OKBLUE}diskmgr: {msg}{Colors.ENDC}")

def run_command(command, check=True, input_str=None, capture_output=True, sudo=False):
    if sudo:
        command = ['sudo'] + command
    
    try:
        result = subprocess.run(
            command,
            input=input_str,
            text=True,
            check=check,
            stdout=subprocess.PIPE if capture_output else None,
            stderr=subprocess.PIPE if capture_output else None
        )
        return result
    except subprocess.CalledProcessError as e:
        if check:
            log(f"Command failed: {' '.join(command)}", 'ERROR')
            if e.stderr:
                log(e.stderr.strip(), 'ERROR')
            raise
        return e

def get_script_dir():
    return Path(__file__).resolve().parent

def get_map_file_path():
    return get_script_dir() / MAP_FILENAME

def read_luks_map():
    map_file = get_map_file_path()
    if not map_file.exists():
        return {}
    
    mappings = {}
    with open(map_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            parts = line.split(None, 1) # Split on first whitespace
            if len(parts) == 2:
                name, path = parts
                mappings[name] = path
    return mappings

def save_luks_map(mappings):
    map_file = get_map_file_path()
    with open(map_file, 'w') as f:
        for name, path in mappings.items():
            f.write(f"{name}\t{path}\n")

def disk_base_name(dev_path):
    # Given /dev/sdb or /dev/sdb1 -> sdb
    try:
        dev_name = os.path.basename(dev_path)
        # simplistic, better to use lsblk
        res = run_command(['lsblk', '-no', 'PKNAME', dev_path], check=False)
        if res.stdout.strip():
            return res.stdout.strip()
        return dev_name
    except:
        return os.path.basename(dev_path)

def disk_is_nvme(dev_path):
    # Check if NVMe
    try:
        res = run_command(['lsblk', '-dno', 'TRAN', dev_path], check=False)
        if res.stdout.strip() == 'nvme':
            return True
        if 'nvme' in dev_path:
            return True
    except:
        pass
    return False

def disk_is_rotational(dev_path):
    try:
        base = disk_base_name(dev_path)
        p = Path(f"/sys/block/{base}/queue/rotational")
        if p.exists():
            return p.read_text().strip() == "1"
    except:
        pass
    return False

def disk_discard_supported(dev_path):
    try:
        res = run_command(['lsblk', '-dno', 'DISC-MAX', dev_path], check=False)
        val = res.stdout.strip()
        return val and val != "0B" and val != "0"
    except:
        return False

def secure_erase_disk(dev_path):
    if not os.path.exists(dev_path):
        log(f"Device not found: {dev_path}", 'ERROR')
        return False
        
    if disk_is_nvme(dev_path):
        log(f"Secure erase: NVMe detected ({dev_path}) -> nvme format --ses=1")
        # Ensure nvme-cli is present?
        try:
            run_command(['nvme', 'format', dev_path, '--ses=1'], sudo=True)
            run_command(['udevadm', 'settle'], sudo=True)
            return True
        except Exception as e:
            log(f"NVMe format failed: {e}", 'ERROR')
            return False

    if disk_is_rotational(dev_path):
        log(f"Secure erase: HDD detected ({dev_path}) -> full zero overwrite (dd)")
        try:
            # bs=16M status=progress
            run_command(['dd', 'if=/dev/zero', f'of={dev_path}', 'bs=16M', 'status=progress', 'oflag=direct'], sudo=True)
            run_command(['sync'], sudo=True)
            return True
        except Exception as e:
            log(f"DD overwrite failed: {e}", 'ERROR')
            return False

    # SSD/Flash
    log(f"Secure erase: SSD/Flash detected ({dev_path}) -> blkdiscard")
    if disk_discard_supported(dev_path):
        try:
            run_command(['blkdiscard', '-f', dev_path], sudo=True)
            run_command(['udevadm', 'settle'], sudo=True)
            return True
        except Exception as e:
            log(f"blkdiscard failed: {e}", 'ERROR')
            return False
    else:
        log("Discard not supported on this device. Cannot perform secure erase.", 'ERROR')
        return False

class CmdArgumentParser(argparse.ArgumentParser):
    def error(self, message):
        raise argparse.ArgumentError(None, message)

class DiskMgrShell(cmd.Cmd):
    intro = 'Welcome to diskmgr. Type help or ? to list commands.\n'
    prompt = f'{Colors.OKGREEN}(diskmgr) {Colors.ENDC}'
    
    def __init__(self):
        super().__init__()
        self.mappings = read_luks_map()
        self.unmapped_cache = []

    def get_disk_info(self):
        # Use lsblk -J for JSON output
        cmd = ['lsblk', '-J', '-e', '7', '-o', 'NAME,KNAME,TYPE,RM,SIZE,FSTYPE,LABEL,MOUNTPOINT,MODEL,WWN,PKNAME,TRAN,DISC-MAX']
        try:
            res = run_command(cmd, capture_output=True)
            data = json.loads(res.stdout)
            return data.get('blockdevices', [])
        except Exception as e:
            log(f"Failed to list disks: {e}", 'ERROR')
            return []

    def flatten_disks(self, devices):
        """Recursively flatten the lsblk tree structure."""
        flat = []
        for dev in devices:
            flat.append(dev)
            if 'children' in dev:
                flat.extend(self.flatten_disks(dev['children']))
        return flat

    def find_persistent_path(self, dev_node, wwn=None, type_='disk'):
        # Try to find /dev/disk/by-id/ match
        
        # 1. Try WWN logic from opendisk
        if wwn:
            prefix = "nvme-" if wwn.startswith("eui.") else "wwn-"
            path = f"/dev/disk/by-id/{prefix}{wwn}"
            try:
                if os.path.realpath(path) == os.path.realpath(f"/dev/{dev_node}"):
                    return path
            except:
                pass

        # 2. Brute force check /dev/disk/by-id
        by_id_dir = Path('/dev/disk/by-id')
        if by_id_dir.exists():
            for link in by_id_dir.iterdir():
                try:
                    if link.resolve() == Path(f"/dev/{dev_node}").resolve():
                        return str(link)
                except:
                    continue
        
        return "-"

    def do_help(self, arg):
        'List available commands with "help" or detailed help with "help cmd".'
        if arg:
            super().do_help(arg)
            return

        print(f"\n{Colors.HEADER}Disk Manager (diskmgr){Colors.ENDC}")
        print("A utility designed to simplify the management of encrypted and plain removable media.")
        print("It maps friendly labels to hardware-specific Persistent Device Paths (PDP), ensuring")
        print("that disks are recognized reliably even if device nodes change.\n")
        
        print(f"{Colors.BOLD}COMMANDS:{Colors.ENDC}")
        print(f"  {Colors.OKGREEN}list{Colors.ENDC}")
        print("      Shows all configured mappings and unmapped system disks in one table.")

        print(f"  {Colors.OKGREEN}layout{Colors.ENDC}")
        print("      Displays the physical partition layout and free space for all disks.")
        
        print(f"  {Colors.OKGREEN}map <id/name> <name>{Colors.ENDC}")
        print("      Assigns a friendly name to a disk or renames an existing mapping.")

        print(f"  {Colors.OKGREEN}unmap <name>{Colors.ENDC}")
        print("      Removes an existing mapping from the configuration.")
        
        print(f"  {Colors.OKGREEN}open <name>{Colors.ENDC}")
        print("      Unlocks LUKS (if encrypted) and mounts the disk.")
        print("      Mounts to /media/$USER/<label> (prefers label over mapping name).")
        
        print(f"  {Colors.OKGREEN}close <name>{Colors.ENDC}")
        print("      Unmounts and closes the disk.")

        print(f"  {Colors.OKGREEN}label <name> [new_label] [--remount]{Colors.ENDC}")
        print("      Get or set the filesystem label of an OPEN disk.")
        print("      Use --remount to immediately move the mount to the new label path.")

        print(f"  {Colors.OKGREEN}passwd <name>{Colors.ENDC}")
        print("      Changes the LUKS encryption passphrase for a disk.")
        
        print(f"  {Colors.OKGREEN}create <name> [options]{Colors.ENDC}")
        print("      Initializes a new disk (Erase -> LUKS -> Format -> Mount).")

        print(f"  {Colors.OKGREEN}erase <name>{Colors.ENDC}")
        print("      Securely erases a disk (NVMe format, blkdiscard, or dd overwrite).")

        print(f"  {Colors.OKGREEN}clone <src_name> <dst_name>{Colors.ENDC}")
        print("      Clones one disk to another (requires target >= source size).")
        
        print(f"  {Colors.OKGREEN}exit / quit / Ctrl+D{Colors.ENDC}")
        print("      Exit the application.")

        print("\nType 'help <command>' for more specific details.")

    def do_exit(self, arg):
        'Exit the application'
        return True

    def do_quit(self, arg):
        'Exit the application'
        return True

    def do_EOF(self, arg):
        'Exit the application'
        print("")
        return True

    def do_layout(self, arg):
        '''Display the physical partition layout and free space for all plugged-in disks.
        
        UNDER THE HOOD:
        1.  Hardware Scan: Identifies all physical 'disk' devices (excluding partitions).
        2.  Geometry Query: Runs 'sudo parted -m <dev> unit s print free' and 'blockdev --getsz'.
        3.  Parsing: 
            - Extracts Partition Table type (gpt/mbr) and sector sizes.
            - Calculates total logical sectors from blockdev output.
        4.  Formatting:
            - Adds GPT metadata blocks (Primary/Backup) if applicable.
            - Identifies 'free' space segments.
            - Calculates MiB and GiB values from sector counts.
        '''
        all_devs = self.get_disk_info()
        disks = [d for d in all_devs if d.get('type') == 'disk']
        
        if not disks:
            log("No physical disks found.", 'WARN')
            return

        for disk in disks:
            d_name = disk['name']
            dev_path = f"/dev/{d_name}"
            model = disk.get('model', 'Unknown')
            
            try:
                # 1. Get Geometry from parted
                res = run_command(['parted', '-m', '-s', dev_path, 'unit', 's', 'print', 'free'], sudo=True)
                lines = res.stdout.strip().splitlines()
                
                header_parts = lines[1].strip(';').split(':')
                logical_sector = int(header_parts[3])
                physical_sector = int(header_parts[4])
                ptable = header_parts[5]
                
                # 2. Get Total Size from blockdev (always in 512b units)
                res_sz = run_command(['blockdev', '--getsz', dev_path], sudo=True)
                total_512_sectors = int(res_sz.stdout.strip())
                total_logical_sectors = (total_512_sectors * 512) // logical_sector

                print(f"\n{Colors.BOLD}Disk: {dev_path} ({model}) [{ptable}] [Sector: L{logical_sector}/P{physical_sector}] [Total Sectors: {total_logical_sectors}]{Colors.ENDC}")

                # 4. Parse Data Lines from parted for visual blocks
                data_lines = [l for l in lines if l and not l.startswith('BYT') and not l.startswith('/')]
                
                segments = []
                
                # Dynamic Initial Overhead Detection
                if data_lines:
                    first_line_parts = data_lines[0].strip(';').split(':')
                    first_start = int(first_line_parts[1].strip('s'))
                    if first_start > 0:
                        overhead_size = first_start
                        overhead_bytes = overhead_size * logical_sector
                        
                        label = "Overhead"
                        if ptable == 'gpt': label = "GPT Primary"
                        elif ptable in ['msdos', 'mbr']: label = "MBR"
                        
                        segments.append(f"{Colors.FAIL}[ {label} {overhead_size}s ({overhead_bytes:.2f}B) ]{Colors.ENDC}")

                for line in data_lines:
                    parts = line.strip(';').split(':')
                    if len(parts) < 4: continue
                    
                    num = parts[0]
                    size_sectors = int(parts[3].strip('s'))
                    fs_or_type = parts[4] if len(parts) > 4 else ""
                    
                    size_bytes = size_sectors * logical_sector
                    # Use B, KiB, MiB, GiB based on size
                    if size_bytes < 1024:
                        size_info = f"{size_bytes:.2f}B"
                    elif size_bytes < 1024**2:
                        size_info = f"{size_bytes/1024:.2f}KiB"
                    elif size_bytes < 1024**3:
                        size_info = f"{size_bytes/(1024**2):.2f}MiB"
                    else:
                        size_info = f"{size_bytes/(1024**2):.2f}MiB â‰ˆ {size_bytes/(1024**3):.1f}GiB"

                    if fs_or_type == 'free' or (not fs_or_type and len(parts) == 5):
                        segments.append(f"{Colors.OKCYAN}[ free {size_sectors}s ({size_info}) ]{Colors.ENDC}")
                    else:
                        flags = parts[6] if len(parts) > 6 else ""
                        kname = f"{d_name}{num}"
                        if 'nvme' in d_name and not kname.startswith(f"{d_name}p"):
                            kname = f"{d_name}p{num}"
                        
                        dtype = fs_or_type if fs_or_type else "-"
                        flag_info = f" ({flags})" if flags else ""
                        segments.append(f"{Colors.OKGREEN}[ {kname} {dtype} {size_sectors}s ({size_info}){flag_info} ]{Colors.ENDC}")
                
                # GPT Backup Overhead
                if data_lines:
                    last_line_parts = data_lines[-1].strip(';').split(':')
                    last_end = int(last_line_parts[2].strip('s'))
                    if last_end < total_logical_sectors - 1:
                        overhead_size = total_logical_sectors - 1 - last_end
                        overhead_bytes = overhead_size * logical_sector
                        l_label = "Overhead"
                        if ptable == 'gpt': l_label = "GPT Backup"
                        segments.append(f"{Colors.FAIL}[ {l_label} {overhead_size}s ({overhead_bytes:.2f}B) ]{Colors.ENDC}")

                print(" ".join(segments))

                # 4. Print lsblk hierarchy at the bottom
                print("")
                try:
                    ls_res = run_command(['lsblk', '-f', dev_path], sudo=True, check=False)
                    if ls_res.stdout.strip():
                        print(ls_res.stdout.strip())
                except:
                    pass
                print("-" * 155)
            except Exception as e:
                print(f"\n{Colors.BOLD}Disk: {dev_path} ({model}){Colors.ENDC}")
                log(f"Could not read layout for {dev_path}: {e}", 'WARN')
        print("")

    def do_list(self, arg):
        '''List all configured mappings and available system disks in a single table.
        
        UNDER THE HOOD:
        1.  Resolution: Refreshes mappings from luksmap.tsv.
        2.  Hardware Discovery: Uses 'lsblk' to gather hardware properties and identifies 
            underlying physical partitions even when opened as virtual devices.
        3.  Zero-Sudo LUKS Detection: Queries the system 'udev' database via 'udevadm info' 
            to accurately identify encrypted disks without requiring root privileges.
        4.  Status Logic:
            - MISSING: Persistent path not found in /dev.
            - CLOSED: Present but locked (LUKS) or unmounted (Plain).
            - OPEN: Unlocked/Decrypted but not yet mounted.
            - MOUNTED: Active filesystem attached to the preferred path (/media/$USER/name).
        5.  Dynamic Formatting: Pre-calculates the maximum width of every column across 
            all rows for a perfectly aligned, readable table.
        6.  Exclusion Logic: Rigorously filters out virtual mapper devices and their 
            kernel aliases (dm-X) from the unmapped list once they are active.
        '''
        self.mappings = read_luks_map()
        mapped_rows = []
        unmapped_rows = []
        
        # 1. Collect Mapped Disks
        mapped_real_paths = set()
        mapped_names = set()
        i = 1
        for name, path in self.mappings.items():
            phys_device = "-"
            dm_device = ""
            fstype = "-"
            size = "-"
            label = "-"
            mountpoint = f"/media/{os.environ.get('USER', 'root')}/{name}"
            is_luks = "-"
            state = "MISSING"
            
            mapped_names.add(name)
            
            # Default mountpoint based on name
            mount_name = name

            if os.path.exists(path):
                real_path = os.path.realpath(path)
                mapped_real_paths.add(real_path)
                state = "CLOSED"
                is_luks = "N"
                
                # Get Physical Device Properties
                try:
                    cmd_p = ['lsblk', '-n', '-P', '-o', 'KNAME,PKNAME,FSTYPE,SIZE,LABEL', real_path]
                    res_p = run_command(cmd_p, check=False)
                    if res_p.stdout.strip():
                        props = {}
                        for part in shlex.split(res_p.stdout.strip()):
                            if '=' in part:
                                k, v = part.split('=', 1)
                                props[k] = v
                        
                        phys_device = props.get('KNAME', '-')
                        # If the 'physical' device is actually a DM device, try to get its parent
                        if phys_device.startswith('dm-'):
                            parent = props.get('PKNAME', '')
                            if parent: phys_device = parent

                        fstype = props.get('FSTYPE', '-')
                        size = props.get('SIZE', '-')
                        label = props.get('LABEL', '-')
                        
                        # Fallback to blkid for more reliable label (lsblk is often stale)
                        try:
                            res_b = run_command(['blkid', '-o', 'value', '-s', 'LABEL', real_path], sudo=True, check=False)
                            if res_b.stdout.strip():
                                label = res_b.stdout.strip()
                        except:
                            pass
                        
                        if label and label != '-':
                            mount_name = label

                        # Check LUKS status using udev (No sudo required)
                        res_u = run_command(['udevadm', 'info', '--query=property', f'--name={real_path}'], check=False)
                        if 'ID_FS_TYPE=crypto_LUKS' in res_u.stdout:
                            is_luks = "Y"
                        elif fstype == 'crypto_LUKS':
                            is_luks = "Y"
                except:
                    pass

            mountpoint = f"/media/{os.environ.get('USER', 'root')}/{mount_name}"

            mapper_path = f"/dev/mapper/{name}"
            target_to_mount = mapper_path

            if is_luks == "Y" and os.path.exists(mapper_path):
                mapped_real_paths.add(os.path.realpath(mapper_path))
                mapped_real_paths.add(mapper_path)
                mapped_names.add(name) # Hide '1a'
                
                state = "OPEN"
                try:
                    cmd_m = ['lsblk', '-n', '-P', '-o', 'KNAME,PKNAME,FSTYPE,LABEL,SIZE', mapper_path]
                    res_m = run_command(cmd_m, check=False)
                    if res_m.stdout.strip():
                        props = {}
                        for part in shlex.split(res_m.stdout.strip()):
                            if '=' in part:
                                k, v = part.split('=', 1)
                                props[k] = v
                        # Get mapper kernel name (e.g. dm-0)
                        dm_device = props.get('KNAME', '')
                        if dm_device: mapped_names.add(dm_device)
                        
                        # Also hide the physical parent of the DM device
                        dm_parent = props.get('PKNAME', '')
                        if dm_parent: 
                            mapped_names.add(dm_parent)
                            if phys_device == '-': phys_device = dm_parent
                        
                        # Use mapper properties for FS details
                        if props.get('FSTYPE'): fstype = props.get('FSTYPE')
                        if props.get('LABEL'): 
                            label = props.get('LABEL')
                            if label and label != '-':
                                mountpoint = f"/media/{os.environ.get('USER', 'root')}/{label}"
                        if props.get('SIZE'): size = props.get('SIZE')
                except:
                    pass
                
                res = run_command(['findmnt', '-rn', '-S', mapper_path, '-o', 'TARGET'], check=False)
                if res.returncode == 0 and res.stdout.strip():
                    mountpoint = res.stdout.strip()
                    state = "MOUNTED"
            elif is_luks == "N" and state != "MISSING":
                 res = run_command(['findmnt', '-rn', '-S', os.path.realpath(path), '-o', 'TARGET'], check=False)
                 if res.returncode == 0 and res.stdout.strip():
                     mountpoint = res.stdout.strip()
                     state = "MOUNTED"

            display_dev = phys_device
            if dm_device and dm_device != phys_device:
                display_dev = f"{phys_device}({dm_device})"

            mapped_rows.append({
                'idx': f"[{i}]", 'name': name, 'luks': is_luks, 'state': state, 
                'fstype': fstype, 'label': label if label else "-", 'mount': mountpoint, 
                'dev': display_dev, 'size': size, 'path': path
            })
            i += 1

        # 2. Collect Unmapped Disks
        all_disks = self.get_disk_info()
        flat_disks = self.flatten_disks(all_disks)
        self.unmapped_cache = []
        u_idx = 1
        for dev in flat_disks:
            d_name = dev.get('name') # Usually mapper name or short kernel name
            d_kname = dev.get('kname') # Kernel name (sda2, dm-0)
            if not d_name or d_name.startswith('loop'):
                continue
            
            # Hide if NAME or KNAME matches a known mapping (1a, dm-0, etc.)
            if d_name in mapped_names or d_kname in mapped_names:
                continue

            dev_path = f"/dev/{d_name}"
            real_dev_path = os.path.realpath(dev_path)
            
            # Hide if this is a known mapped physical device or mapper device path
            if real_dev_path in mapped_real_paths or dev_path in mapped_real_paths:
                continue
            
            # Check for /dev/mapper/ links appearing in dev nodes
            if os.path.exists(f"/dev/mapper/{d_name}"):
                continue

            fstype = dev.get('fstype') or '-'
            label = dev.get('label') or '-'
            
            # Fallback to blkid for more reliable label
            try:
                res_b = run_command(['blkid', '-o', 'value', '-s', 'LABEL', dev_path], sudo=True, check=False)
                if res_b.stdout.strip():
                    label = res_b.stdout.strip()
            except:
                pass

            size = dev.get('size') or '-'
            mountpoint = dev.get('mountpoint') or '-'
            pdp = self.find_persistent_path(d_name, dev.get('wwn'))
            
            self.unmapped_cache.append({
                'dev': dev_path, 'pdp': pdp if pdp != '-' else dev_path,
                'size': size, 'model': dev.get('model'), 'type': dev.get('type')
            })
            
            is_luks_u = "N"
            if fstype == 'crypto_LUKS':
                is_luks_u = "Y"
            else:
                # Check udev for unmapped too
                res_uu = subprocess.run(['udevadm', 'info', '--query=property', f'--name={dev_path}'], capture_output=True, text=True)
                if 'ID_FS_TYPE=crypto_LUKS' in res_uu.stdout:
                    is_luks_u = "Y"

            # Check if this device has any active LUKS children (is it open?)
            is_open = False
            has_mount = mountpoint != '-'
            
            # Look for crypt children in the flattened list
            # A bit inefficient but reliable: find if any device has this one as PKNAME
            for child in flat_disks:
                if child.get('pkname') == d_name or child.get('pkname') == d_kname:
                    if child.get('type') == 'crypt':
                        is_open = True
                        if child.get('mountpoint'):
                            has_mount = True
                            mountpoint = child.get('mountpoint')

            state_u = "UNMOUNTED"
            if has_mount:
                state_u = "MOUNTED"
            elif is_open:
                state_u = "OPEN"
            elif is_luks_u == "Y":
                state_u = "LOCKED"

            unmapped_rows.append({
                'idx': f"[U{u_idx}]", 'name': "-", 'luks': is_luks_u, 'state': state_u,
                'fstype': fstype, 'label': label, 'mount': mountpoint,
                'dev': d_kname if d_kname else d_name, 'size': size, 'path': pdp
            })
            u_idx += 1

        # 3. Calculate Widths and Print
        all_rows = mapped_rows + unmapped_rows
        headers = ["#", "NAME", "LUKS", "STATE", "FSTYPE", "LABEL", "MOUNTPOINT", "DEVICE", "SIZE", "PERSISTENT PATH"]
        keys = ['idx', 'name', 'luks', 'state', 'fstype', 'label', 'mount', 'dev', 'size', 'path']
        widths = {k: len(h) for k, h in zip(keys, headers)}
        
        for row in all_rows:
            for k in keys:
                widths[k] = max(widths[k], len(str(row[k])))
        
        fmt = "  ".join([f"{{:<{widths[k]}}}" for k in keys])

        print(f"\n{Colors.HEADER}--- Disk Management Table ({get_map_file_path()}) ---{Colors.ENDC}")
        print(fmt.format(*headers))
        print("-" * (sum(widths.values()) + len(keys)*2))
        for row in all_rows:
            print(fmt.format(*[row[k] for k in keys]))
        print("")

    def resolve_target(self, target_str, allow_id=True):
        '''Resolves a target string to a physical path.
        Only supports Discovery IDs (U1, [U1]) or existing mapping names.
        '''
        clean = target_str.strip('[]')
        
        # 1. Check Discovery ID
        if allow_id and clean.startswith('U') and clean[1:].isdigit():
            idx = int(clean[1:]) - 1
            if 0 <= idx < len(self.unmapped_cache):
                return self.unmapped_cache[idx]['pdp']
            return None
            
        # 2. Check Mapping Name
        self.mappings = read_luks_map()
        if target_str in self.mappings:
            return self.mappings[target_str]
            
        return None

    def extensive_confirm(self, target_name):
        print(f"\n{Colors.FAIL}{Colors.BOLD}!!! EXTENSIVE CONFIRMATION REQUIRED !!!{Colors.ENDC}")
        print(f"You are about to perform a DESTRUCTIVE operation on: {Colors.WARNING}{target_name}{Colors.ENDC}")
        print("To proceed, you must answer two math questions correctly.")
        
        for i in range(2):
            a = random.randint(11, 99)
            b = random.randint(11, 99)
            op = random.choice(['+', '-'])
            if op == '+':
                ans = a + b
            else:
                ans = a - b
            
            try:
                user_ans = input(f"Question {i+1}/2: What is {a} {op} {b}? ")
                if not user_ans or int(user_ans) != ans:
                    log("Incorrect answer. Aborting operation.", 'ERROR')
                    return False
            except ValueError:
                log("Invalid input. Aborting operation.", 'ERROR')
                return False
        
        print(f"{Colors.OKGREEN}Verification successful. Proceeding...{Colors.ENDC}")
        return True

    def is_root_disk(self, target_path):
        """Checks if the target path is the root disk or partition."""
        try:
            # Get the root device
            res = run_command(['findmnt', '-nro', 'SOURCE', '/'], capture_output=True)
            root_dev = os.path.realpath(res.stdout.strip())
            
            target_real = os.path.realpath(target_path)
            
            # 1. Direct match
            if target_real == root_dev:
                return True
                
            # 2. Parent disk match (if target is /dev/sda and root is /dev/sda2)
            res_p = run_command(['lsblk', '-no', 'PKNAME', root_dev], check=False)
            parent = res_p.stdout.strip()
            if parent and target_real == os.path.realpath(f"/dev/{parent}"):
                return True
                
            # 3. Child partition match (if target is /dev/sda2 and root is /dev/sda)
            res_c = run_command(['lsblk', '-no', 'PKNAME', target_real], check=False)
            target_parent = res_c.stdout.strip()
            if target_parent and root_dev == os.path.realpath(f"/dev/{target_parent}"):
                # This is actually covered by case 1 if root is the disk, 
                # but if root is a partition we don't want to wipe its siblings?
                # Actually, the most dangerous case is wiping the disk containing root.
                pass

        except:
            pass
        return False

    def do_map(self, arg):
        '''Create or modify a persistent mapping: map <name/id> <name>
        
        Usage:
          map [U1] backup    Assigns friendly name to discovery ID (e.g., map U1 backup)
          map 1a backup      Renames an existing mapping (e.g., map 1a backup)
        
        Note: Raw device paths (e.g., /dev/sdb) are NOT allowed.
        
        UNDER THE HOOD:
        1.  Input Resolution: 
            - discovery ID (e.g., [U1]): Resolves the temporary device to its Persistent Device Path (PDP).
            - mapping name (e.g., 1a): Selects an existing mapping for RENAME operations.
        2.  PDP Linking: Extracts the /dev/disk/by-id/ path for the target hardware.
        3.  Conflict Check: Ensures the new friendly name is not already in use.
        4.  Persistence: Writes the [Name <TAB> PDP] pair to luksmap.tsv.
        
        This ensures the disk is recognized correctly regardless of USB port or device node changes.
        '''
        args = arg.split()
        if len(args) != 2:
            log("Usage: map <id/name> <new_name>", 'ERROR')
            return

        target, name = args
        self.mappings = read_luks_map() # Refresh
        
        # 1. Check for Rename (target is a mapping name)
        if target in self.mappings:
            real_target = self.mappings[target]
            log(f"Renaming mapping {target} -> {name}")
            del self.mappings[target]
        else:
            # 2. Check for New Map (target is a discovery ID)
            real_target = self.resolve_target(target)
            if not real_target:
                log(f"Invalid target: '{target}'. Use a Discovery ID (e.g., [U1]) or an existing name.", 'ERROR')
                return
            log(f"Resolved {target} -> {real_target}")
        
        if name in self.mappings:
             log(f"Mapping '{name}' already exists.", 'ERROR')
             return

        # Collision Prevention: Prevent names that look like IDs
        clean_name = name.strip('[]')
        if (clean_name.startswith('U') and clean_name[1:].isdigit()) or clean_name.isdigit():
            log(f"Invalid name: '{name}'. Names cannot be simple numbers or match the 'U1' ID format.", 'ERROR')
            return

        self.mappings[name] = real_target
        save_luks_map(self.mappings)
        log(f"Mapping saved: {name} -> {real_target}")

    def do_unmap(self, arg):
        '''Remove a persistent mapping: unmap <name>
        
        UNDER THE HOOD:
        1.  Resolution: Verifies the mapping exists in luksmap.tsv.
        2.  Removal: Deletes the [Name <TAB> PDP] pair from the internal dictionary.
        3.  Persistence: Re-writes luksmap.tsv with the mapping removed.
        '''
        name = arg.strip()
        if not name:
            log("Usage: unmap <name>", 'ERROR')
            return

        self.mappings = read_luks_map()
        if name not in self.mappings:
            log(f"Unknown mapping: '{name}'", 'ERROR')
            return

        del self.mappings[name]
        save_luks_map(self.mappings)
        log(f"Mapping '{name}' removed successfully.")

    def do_open(self, arg):
        '''Unlock (if encrypted) and mount a disk: open <name>
        
        UNDER THE HOOD:
        1.  Identity Resolution: Looks up the friendly name in luksmap.tsv.
        2.  Hardware Wait: Polls for up to 10 seconds to allow for hardware spin-up/udev events.
        3.  Validation: 
            - Runs 'cryptsetup isLuks' to check for encryption.
            - If NOT encrypted, verifies the existence of a valid filesystem.
        4.  Decryption (LUKS only):
            - Executes 'passgen' to retrieve the passphrase.
            - Pipes the passphrase into 'cryptsetup open' to create a cleartext device in /dev/mapper/.
        5.  Mounting:
            - Identifies the preferred mountpoint: /media/$USER/<label> (falls back to mapping name).
            - Ensures the directory exists and attaches the device.
        6.  Policy Enforcement: If the disk is already mounted at a non-standard path, 
            it unmounts and remounts it to the preferred path.
        '''
        name = arg.strip()
        if not name:
             log("Usage: open <name>", 'ERROR')
             return
             
        self.mappings = read_luks_map()
        if name not in self.mappings:
            log(f"Unknown mapping: {name}. Use 'list' to find Discovery IDs and 'map' them first.", 'ERROR')
            return
            
        src = self.mappings[name]
        
        # Wait for device
        log(f"Waiting for device {src}...")
        for _ in range(50): # 10s wait
            if os.path.exists(src):
                break
            time.sleep(0.2)
            
        if not os.path.exists(src):
            log(f"Device not found: {src}", 'ERROR')
            return
            
        devnode = os.path.realpath(src)
        
        # Check LUKS
        is_luks = False
        try:
            res = run_command(['cryptsetup', 'isLuks', devnode], sudo=True, check=False)
            if res.returncode == 0:
                is_luks = True
        except:
             pass

        if not is_luks:
             # Not LUKS, check if it has a filesystem
             res = run_command(['lsblk', '-n', '-o', 'FSTYPE', devnode], check=False)
             if not res.stdout.strip():
                 log(f"Device {devnode} is not a valid LUKS device and has no recognizable filesystem.", 'ERROR')
                 return
             log(f"Device {devnode} is not LUKS, but has a filesystem. Proceeding with plain mount.")

        mapper_path = f"/dev/mapper/{name}"
        target_to_mount = mapper_path

        if is_luks:
            if not os.path.exists(mapper_path):
                log(f"Opening LUKS mapping {name}...")
                # Use passgen
                pg_cmd = subprocess.Popen([PASSGEN_BIN], stdout=subprocess.PIPE, text=True)
                # Pipe to cryptsetup
                try:
                    run_command(
                        ['cryptsetup', 'open', '--key-file', '-', src, name],
                        input_str=pg_cmd.communicate()[0],
                        sudo=True,
                        check=True
                    )
                    log("LUKS opened.")
                except Exception as e:
                    log(f"Failed to open LUKS: {e}", 'ERROR')
                    return
            else:
                log("Mapping already exists.")
        else:
            # Plain disk
            target_to_mount = devnode

        # Detect label for mountpoint
        mount_name = name
        try:
            res_b = run_command(['blkid', '-o', 'value', '-s', 'LABEL', target_to_mount], sudo=True, check=False)
            if res_b.stdout.strip():
                mount_name = res_b.stdout.strip()
        except:
            pass

        # Mount
        mountpoint = f"/media/{os.environ.get('USER', 'root')}/{mount_name}"
        if not os.path.exists(mountpoint):
            run_command(['mkdir', '-p', mountpoint], sudo=True)
            
        # Check if mounted
        res = run_command(['findmnt', '-rn', '-S', target_to_mount, '-o', 'TARGET'], check=False)
        current_mnt = res.stdout.strip()

        if not current_mnt:
            log(f"Mounting {target_to_mount} to {mountpoint}...")
            run_command(['mount', target_to_mount, mountpoint], sudo=True)
            log("Mounted.")
        elif current_mnt != mountpoint:
            log(f"Disk is mounted at {current_mnt} (system default). Overriding...")
            try:
                run_command(['umount', current_mnt], sudo=True)
                run_command(['mount', target_to_mount, mountpoint], sudo=True)
                log(f"Successfully moved mount to {mountpoint}")
            except Exception as e:
                log(f"Failed to override mount: {e}. It may be in use.", 'WARN')
        else:
            log(f"Already mounted at {mountpoint}.")

    def do_close(self, arg):
        '''Unmount and lock (if encrypted) a disk: close <name>
        
        UNDER THE HOOD:
        1.  Unmounting (Encrypted & Plain): 
            - Flushes all pending writes to the disk (data integrity).
            - Terminates active file handles to the device.
            - Attempts unmount by mapper path (LUKS), source path (Plain), or guessed mountpoint.
        2.  Locking (LUKS only):
            - Commands the kernel to wipe encryption keys from RAM.
            - Removes the virtual cleartext device from /dev/mapper/.
        3.  Audit: Checks and displays remaining active mappings for security awareness.
        '''
        name = arg.strip()
        if not name:
            log("Usage: close <name>", 'ERROR')
            return

        mapper_path = f"/dev/mapper/{name}"
        mount_guess = f"/media/{os.environ.get('USER', 'root')}/{name}"

        run_command(['sudo', '-v']) # Refresh sudo

        # Unmount
        unmounted = False
        # 1. Try by mapper
        res = run_command(['findmnt', '-rn', '-S', mapper_path, '-o', 'TARGET'], check=False)
        if res.returncode == 0 and res.stdout.strip():
            mp = res.stdout.strip()
            log(f"Unmounting {mp}...")
            run_command(['umount', mp], sudo=True)
            unmounted = True
        
        # 2. Try by source path (for non-LUKS)
        if not unmounted:
            self.mappings = read_luks_map()
            if name in self.mappings:
                src = self.mappings[name]
                res = run_command(['findmnt', '-rn', '-S', src, '-o', 'TARGET'], check=False)
                if res.returncode == 0 and res.stdout.strip():
                    mp = res.stdout.strip()
                    log(f"Unmounting {mp}...")
                    run_command(['umount', mp], sudo=True)
                    unmounted = True

        # 3. Try by guess
        if not unmounted:
            if run_command(['findmnt', '-rn', '-M', mount_guess], check=False).returncode == 0:
                 log(f"Unmounting {mount_guess}...")
                 run_command(['umount', mount_guess], sudo=True)
                 unmounted = True
        
        # Close
        if os.path.exists(mapper_path):
            log(f"Closing mapping {name}...")
            run_command(['cryptsetup', 'close', name], sudo=True)
            log("Closed.")
        else:
            log("Mapping not open or already closed.")

    def do_label(self, arg):
        '''Get or set the filesystem label of an OPEN disk: label <name> [new_label] [--remount]
        
        Options:
          --remount        Unmount and remount the disk to the new label's path.

        UNDER THE HOOD:
        1.  Validation: Verifies that the disk is currently open/unlocked.
        2.  Identification: Queries the filesystem type (ext4, xfs, etc.) via 'lsblk'.
        3.  Labeling:
            - ext4: Uses 'e2label' on the active device.
            - xfs: Requires a temporary unmount, then uses 'xfs_admin -L', then remounts.
        4.  Refresh: Executes 'udevadm trigger' to force tools like 'lsblk' to see the change.
        5.  Remount (Optional): If --remount is set, moves the mount to /media/$USER/new_label.
        
        The label is written directly to the disk hardware and persists across different computers.
        '''
        parser = CmdArgumentParser(prog='label', add_help=False)
        parser.add_argument('name')
        parser.add_argument('new_label', nargs='?')
        parser.add_argument('--remount', action='store_true')
        
        try:
            split_args = shlex.split(arg)
            args = parser.parse_args(split_args)
        except argparse.ArgumentError as e:
            log(str(e), 'ERROR')
            return
        except SystemExit:
            return

        name = args.name
        new_label = args.new_label
        
        # Resolve target device
        target_dev = None
        mapper_path = f"/dev/mapper/{name}"
        
        if os.path.exists(mapper_path):
            target_dev = mapper_path
        else:
            self.mappings = read_luks_map()
            if name in self.mappings:
                src = self.mappings[name]
                if not os.path.exists(src):
                    log(f"Device for mapping '{name}' is missing: {src}", 'ERROR')
                    return
                
                devnode = os.path.realpath(src)
                # Check if it's LUKS
                try:
                    res = run_command(['cryptsetup', 'isLuks', devnode], sudo=True, check=False)
                    if res.returncode == 0:
                        log(f"Mapping '{name}' is LUKS but not open. Please 'open {name}' first.", 'ERROR')
                        return
                    # if returncode != 0, it's not LUKS, which is what we want for a plain disk
                except:
                    pass
                
                target_dev = devnode
            else:
                log(f"Device not found or unknown mapping: {name}", 'ERROR')
                return
             
        # Get info
        try:
            cmd = ['lsblk', '-J', '-o', 'FSTYPE,MOUNTPOINT,LABEL', target_dev]
            res = run_command(cmd, capture_output=True)
            data = json.loads(res.stdout)
            dev = data.get('blockdevices', [{}])[0]
            fstype = dev.get('fstype')
            mountpoint = dev.get('mountpoint')
            current_label = dev.get('label')
        except Exception as e:
            log(f"Failed to inspect device: {e}", 'ERROR')
            return
            
        if not new_label:
            print(f"Label for {name} ({fstype}): {current_label if current_label else '<none>'}")
            return
            
        if current_label == new_label:
            log("Label is already set to that value.")
            # Still process remount if requested
        else:
            log(f"Changing label: '{current_label}' -> '{new_label}' ({fstype})")
            
            if fstype == 'ext4':
                try:
                    run_command(['e2label', target_dev, new_label], sudo=True)
                    run_command(['udevadm', 'trigger', '--name-match=' + target_dev], sudo=True)
                    run_command(['udevadm', 'settle'], sudo=True)
                    log("Label updated.")
                except:
                    pass # run_command logs error
            elif fstype == 'xfs':
                # XFS requires unmount
                remount_needed = False
                if mountpoint:
                    log(f"XFS requires unmounting to label. Unmounting {mountpoint}...")
                    try:
                        run_command(['umount', mountpoint], sudo=True)
                        remount_needed = True
                    except Exception as e:
                        log(f"Failed to unmount: {e}", 'ERROR')
                        return

                try:
                    run_command(['xfs_admin', '-L', new_label, target_dev], sudo=True)
                    run_command(['udevadm', 'trigger', '--name-match=' + target_dev], sudo=True)
                    run_command(['udevadm', 'settle'], sudo=True)
                    log("Label updated.")
                except:
                    pass
                finally:
                    if remount_needed:
                        log(f"Remounting {mountpoint}...")
                        try:
                             run_command(['mount', target_dev, mountpoint], sudo=True)
                             # Update mountpoint variable for the --remount logic below
                             mountpoint = run_command(['findmnt', '-rn', '-S', target_dev, '-o', 'TARGET'], check=False).stdout.strip()
                        except Exception as e:
                            log(f"Failed to remount: {e}. You may need to mount manually.", 'ERROR')

            else:
                log(f"Unsupported filesystem for labeling: {fstype}", 'ERROR')
                return

        if args.remount:
            new_mountpoint = f"/media/{os.environ.get('USER', 'root')}/{new_label}"
            
            # Get latest mountpoint after label changes (especially for XFS which we might have remounted)
            res = run_command(['findmnt', '-rn', '-S', target_dev, '-o', 'TARGET'], check=False)
            current_mp = res.stdout.strip()
            
            if current_mp == new_mountpoint:
                log(f"Already mounted at {new_mountpoint}.")
                return

            if current_mp:
                log(f"Unmounting {current_mp} for remount...")
                try:
                    run_command(['umount', current_mp], sudo=True)
                except Exception as e:
                    log(f"Failed to unmount {current_mp}: {e}", 'ERROR')
                    return

            log(f"Mounting {target_dev} to {new_mountpoint}...")
            try:
                run_command(['mkdir', '-p', new_mountpoint], sudo=True)
                run_command(['mount', target_dev, new_mountpoint], sudo=True)
                log(f"Remounted successfully at {new_mountpoint}")
            except Exception as e:
                log(f"Failed to mount at {new_mountpoint}: {e}", 'ERROR')

    def do_passwd(self, arg):
        '''Change the LUKS encryption passphrase: passwd <name>
        
        UNDER THE HOOD:
        1.  Resolution: Maps the friendly name to its physical device node.
        2.  Validation: Verifies the device is a valid LUKS container.
        3.  Execution: Runs 'cryptsetup luksChangeKey'. This is an interactive 
            process that prompts for the current passphrase and the new one.
        
        Note: This command communicates directly with the kernel to update the LUKS slot.
        '''
        name = arg.strip()
        if not name:
            log("Usage: passwd <name>", 'ERROR')
            return

        src = self.resolve_target(name, allow_id=False)
        if not src:
            log(f"Unknown mapping: '{name}'.", 'ERROR')
            return

        devnode = os.path.realpath(src)
        
        # Check LUKS
        try:
            run_command(['sudo', 'cryptsetup', 'isLuks', devnode])
        except subprocess.CalledProcessError:
            log(f"Device {name} ({devnode}) is not a LUKS encrypted device.", 'ERROR')
            return

        log(f"Starting passphrase change for {name} ({devnode})...")
        # Run interactively (capture_output=False)
        try:
            run_command(['cryptsetup', 'luksChangeKey', devnode], sudo=True, capture_output=False)
            log("Passphrase updated successfully.")
        except Exception as e:
            log(f"Failed to change passphrase: {e}", 'ERROR')

    def do_erase(self, arg):
        '''Securely erase a disk: erase <name> [options]
        
        Note: You must 'map' a disk first to give it a name before erasing it.
        
        NUANCES & SAFETY:
        - Whole Disk (sda): Wipes the Partition Table (GPT/MBR) and ALL partitions.
        - Partition (sda2): Wipes only that partition. Other partitions are safe.
        - Mapped Name (1a): Resolves to the physical partition. Wiping it destroys 
          the LUKS Header, making data recovery impossible even with the password.
        
        UNDER THE HOOD:
        1.  Target Resolution: Maps friendly name to a raw block device.
        2.  Destructive Wipe:
            - NVMe: Uses 'nvme format --ses=1' for firmware-level crypto-erase.
            - SSD: Uses 'blkdiscard' to inform the controller that all blocks are empty.
            - HDD: Uses 'dd' for a full zero-pass overwrite of the physical platters.
        3.  Verification: Executes 'udevadm settle' and 'sync' to ensure all operations are committed.
        
        WARNING: This operation is IRREVERSIBLE.
        '''
        parser = CmdArgumentParser(prog='erase', add_help=False)
        parser.add_argument('target', help='Target name or device')
        
        try:
            split_args = shlex.split(arg)
            args = parser.parse_args(split_args)
        except argparse.ArgumentError as e:
            log(str(e), 'ERROR')
            return
        except SystemExit:
            return

        name = args.target
        real_target = self.resolve_target(name, allow_id=False)
        
        if not real_target:
            log(f"Unknown mapping: '{name}'. You must 'map' a disk before you can erase it.", 'ERROR')
            return
        
        if not os.path.exists(real_target):
            log(f"Target not found: {real_target}", 'ERROR')
            return
            
        real_target = os.path.realpath(real_target)
        log(f"Target resolved: {real_target}")
        
        if self.is_root_disk(real_target):
            log(f"OPERATION BLOCKED: {real_target} is part of the system root drive!", 'ERROR')
            return

        if not self.extensive_confirm(real_target):
            return

        run_command(['sudo', '-v'])
        
        # Unmount dependencies?
        # TODO: checking mounts
        
        if secure_erase_disk(real_target):
            log("Secure erase completed successfully.")
        else:
            log("Secure erase failed.", 'ERROR')

    def do_clone(self, arg):
        '''Clone one disk or partition to another: clone <src_name> <dst_name>
        
        Note: The target disk MUST be the same size or larger than the source.
        
        STEP-BY-STEP PROCESS:
        1.  Resolution: Maps both friendly names to their physical device nodes (PDP).
        2.  Size Validation: Queries 'blockdev --getsize64' for both. Aborts if dst < src.
        3.  Safety Audit: Verifies that the target is NOT the system root drive.
        4.  Confirmation: Requires solving two math problems to authorize data destruction.
        5.  Cloning: Executes 'dd' with 16MiB buffers and direct I/O for maximum throughput.
        6.  Sync: Flushes kernel buffers to ensure all data is physically committed to disk.

        SCENARIOS:
        - Drive to Drive: 
          Creates a 1:1 bit-perfect clone. The target disk becomes an identical twin, 
          including the Partition Table, UUIDs, and all partitions. 
          Note: If the target is larger, the extra space appears as 'free' at the end.
        - Partition to Partition: 
          Copies the internal data of the source partition into the target partition. 
          Useful for moving a LUKS container or a specific filesystem. 
          Warning: Filesystem UUIDs will be duplicated; avoid mounting both simultaneously.
        - Partition to Drive: 
          The source partition's content is written to the start of the physical disk. 
          This destroys the target's partition table and turns the disk into a 
          "partitionless" volume (e.g., a raw LUKS device).
        - Drive to Partition (DANGEROUS): 
          Writes the source's boot sectors and partition table into the target partition. 
          This usually results in an unreadable "nested" structure.

        CLONING & ENCRYPTION (CRITICAL):
        - Source is LOCKED (e.g., clone sda sdb): 
          Creates a bit-perfect "Encrypted Twin." The destination remains encrypted 
          and requires the same password. (Recommended for backups).
        - Source is OPEN (e.g., clone sda sdb): 
          Copies encrypted data but may capture a "dirty" filesystem state if 
          files are currently being written. (Close before cloning if possible).
        - Source is MAPPER (e.g., clone dm-0 sdb): 
          Performs a "Strip-and-Clone." The destination receives RAW DECRYPTED 
          DATA. The resulting clone will be completely UNENCRYPTED.
        '''
        args = arg.split()
        if len(args) != 2:
            log("Usage: clone <src_name> <dst_name>", 'ERROR')
            return

        src_name, dst_name = args
        src_path = self.resolve_target(src_name, allow_id=False)
        dst_path = self.resolve_target(dst_name, allow_id=False)

        if not src_path:
            log(f"Unknown source mapping: '{src_name}'", 'ERROR')
            return
        if not dst_path:
            log(f"Unknown target mapping: '{dst_name}'", 'ERROR')
            return

        src_real = os.path.realpath(src_path)
        dst_real = os.path.realpath(dst_path)

        if src_real == dst_real:
            log("Source and target are the same device!", 'ERROR')
            return

        if self.is_root_disk(dst_real):
            log(f"OPERATION BLOCKED: {dst_name} ({dst_real}) is the system root drive!", 'ERROR')
            return

        # Compare sizes
        try:
            src_bytes = int(run_command(['sudo', 'blockdev', '--getsize64', src_real], capture_output=True).stdout.strip())
            dst_bytes = int(run_command(['sudo', 'blockdev', '--getsize64', dst_real], capture_output=True).stdout.strip())
            
            if dst_bytes < src_bytes:
                log(f"Target disk is too small! (Source: {src_bytes}B, Target: {dst_bytes}B)", 'ERROR')
                return
        except Exception as e:
            log(f"Failed to verify disk sizes: {e}", 'ERROR')
            return

        # Confirmation
        if not self.extensive_confirm(f"{dst_name} ({dst_real})"):
            return

        run_command(['sudo', '-v'])
        log(f"Cloning {src_name} -> {dst_name}...")
        
        # Perform clone
        try:
            # dd if=src of=dst bs=16M status=progress oflag=direct conv=fsync
            cmd = ['dd', f'if={src_real}', f'of={dst_real}', 'bs=16M', 'status=progress', 'oflag=direct', 'conv=fsync']
            run_command(cmd, sudo=True)
            log("Cloning complete.")
        except Exception as e:
            log(f"Cloning failed: {e}", 'ERROR')

    def do_create(self, arg):
        '''Initialize a disk: create <name> [options]
        
        Note: You must 'map' a disk first to give it a name before initializing it.
        
        NUANCES & SCOPE:
        1. Running create on a Partition (e.g., sda2)
           The Result: Container-in-a-Box.
           The script treats the existing partition as its "entire world."
           - Partitioning: It skips the GPT/MBR step because you've already given it a partition.
           - Encryption: It sets up LUKS directly inside the sda2 boundary.
           - Filesystem: It formats the area inside sda2.
           - The Big Picture: The rest of your disk (like sda1 or sda3) is untouched. 
             You are simply replacing whatever was inside partition #2 with a new encrypted volume.

        2. Running create on a Whole Disk (e.g., sda)
           The Result: Total Takeover.
           The script wipes the slate clean and rebuilds the drive from scratch.
           - Wipe: It deletes the Partition Table (GPT/MBR) at the start of the disk. 
             All existing partitions (sda1, sda2, etc.) are instantly lost.
           - Rebuild:
             * If you didn't use --gpt or --mbr: It formats the Entire Disk as one 
               giant LUKS container (no partition table).
             * If you used --gpt: It creates a fresh GPT table, creates a new 
               partition #1 spanning the whole drive, and puts LUKS inside that.
           - The Big Picture: You lose everything on the physical drive, and it 
             becomes a single, clean encrypted volume.
        
        Options:
          --fs <ext4|xfs>   Filesystem type (default: ext4)
          --label <label>   Set a different internal filesystem label (other than <name>)
          --plain           Create a non-encrypted disk (skips LUKS)
          --gpt             Create GPT partition table + 1 partition (Whole disk only)
          --mbr             Create MBR partition table + 1 partition (Whole disk only)
        
        UNDER THE HOOD:
        1.  Unmount: Forcefully unmounts any existing partitions on the target.
        2.  Wipe: Executes 'wipefs' to remove old filesystem signatures.
        3.  Partitioning (Optional): Uses 'sgdisk' (GPT) or 'sfdisk' (MBR) to create a single partition.
        4.  LUKS Format (Default):
            - Uses 'passgen' to generate a master key.
            - Runs 'cryptsetup luksFormat' with LUKS2 encryption.
        5.  Filesystem: 
            - Formats the cleartext device with ext4 or xfs.
            - (ext4 only): Reclaims the 5% reserved space for root using 'tune2fs -m 0'.
        6.  Persistence: Adds the new disk's PDP to luksmap.tsv automatically.
        '''
        parser = CmdArgumentParser(prog='create', add_help=False)
        parser.add_argument('args', nargs=1, help='<name>')
        parser.add_argument('--fs', default='ext4', choices=['ext4', 'xfs'])
        parser.add_argument('--label', help='Filesystem label')
        parser.add_argument('--plain', action='store_true', help='No LUKS encryption')
        parser.add_argument('--gpt', action='store_true')
        parser.add_argument('--mbr', action='store_true')

        try:
            split_args = shlex.split(arg)
            args = parser.parse_args(split_args)
        except argparse.ArgumentError as e:
            log(str(e), 'ERROR')
            return
        except SystemExit:
            return

        name = args.args[0]
        target = self.resolve_target(name, allow_id=False)
        if not target:
            log(f"Unknown mapping: '{name}'. You must 'map' a disk before you can initialize it.", 'ERROR')
            return

        # Wait/Verify target existence
        real_target = os.path.realpath(target)
        if not os.path.exists(real_target):
            log(f"Target device not found: {target} (resolved: {real_target})", 'ERROR')
            return
            
        if self.is_root_disk(real_target):
            log(f"OPERATION BLOCKED: {real_target} is part of the system root drive!", 'ERROR')
            return

        log(f"Target: {real_target}")
        log(f"Name: {name}")
        
        # Safety checks
        if not self.extensive_confirm(f"{name} ({real_target})"):
            return

        run_command(['sudo', '-v'])

        # Unmount anything on the disk
        log("Ensuring target is unmounted...")
        # (Simplified unmount check)
        
        # Always do a soft wipe for create
        run_command(['wipefs', '-a', real_target], sudo=True)

        crypt_target = real_target
        
        # Partitioning
        if args.gpt:
            log("Creating GPT partition...")
            run_command(['sgdisk', '--zap-all', real_target], sudo=True)
            run_command(['sgdisk', '-n', f'1:0:0', '-t', '1:8300', '-c', f'1:{name}', real_target], sudo=True)
            run_command(['udevadm', 'settle'], sudo=True)
            # Guess partition name
            if 'nvme' in real_target:
                crypt_target = f"{real_target}p1"
            else:
                crypt_target = f"{real_target}1"
        elif args.mbr:
            log("Creating MBR partition...")
            # using sfdisk scripting
            sfdisk_script = f"label: dos\n{real_target}1 : start=2048, type=83"
            run_command(['sfdisk', '--wipe', 'always', '--wipe-partitions', 'always', real_target], 
                       input_str=sfdisk_script, sudo=True)
            run_command(['udevadm', 'settle'], sudo=True)
             # Guess partition name
            if 'nvme' in real_target:
                crypt_target = f"{real_target}p1"
            else:
                crypt_target = f"{real_target}1"

        if not args.plain:
            # LUKS Format
            log(f"Formatting LUKS on {crypt_target}...")
            pg_cmd = subprocess.Popen([PASSGEN_BIN], stdout=subprocess.PIPE, text=True)
            try:
                run_command(
                    ['cryptsetup', 'luksFormat', '--type', 'luks2', '--batch-mode', '--key-file', '-', crypt_target],
                    input_str=pg_cmd.communicate()[0],
                    sudo=True,
                    check=True
                )
            except Exception as e:
                log(f"LUKS Format failed: {e}", 'ERROR')
                return

            # Open
            log("Opening new LUKS volume...")
            pg_cmd = subprocess.Popen([PASSGEN_BIN], stdout=subprocess.PIPE, text=True)
            run_command(
                ['cryptsetup', 'open', '--key-file', '-', crypt_target, name],
                input_str=pg_cmd.communicate()[0],
                sudo=True,
                check=True
            )
            fs_target = f"/dev/mapper/{name}"
        else:
            fs_target = crypt_target

        # Mkfs
        label = args.label if args.label else name
        log(f"Formatting filesystem {args.fs} (label={label}) on {fs_target}...")
        
        if args.fs == 'ext4':
            run_command(['mkfs.ext4', '-F', '-L', label, fs_target], sudo=True)
            log("Reclaiming 5% reserved space (tune2fs -m 0)...")
            run_command(['tune2fs', '-m', '0', fs_target], sudo=True)
        elif args.fs == 'xfs':
            run_command(['mkfs.xfs', '-f', '-L', label, fs_target], sudo=True)

        # Mount
        mountpoint = f"/media/{os.environ.get('USER', 'root')}/{label}"
        run_command(['mkdir', '-p', mountpoint], sudo=True)
        run_command(['mount', fs_target, mountpoint], sudo=True)

        # Update map if needed
        self.mappings = read_luks_map()
        if name not in self.mappings:
            stable_path = crypt_target
            # Try to find by-id
            pdp = self.find_persistent_path(os.path.basename(crypt_target))
            if pdp != '-':
                stable_path = pdp
            
            self.mappings[name] = stable_path
            save_luks_map(self.mappings)
            log(f"Added mapping: {name} -> {stable_path}")

        log("Disk initialization complete.")


if __name__ == '__main__':
    try:
        os.chmod(__file__, 0o755)
    except:
        pass
    try:
        DiskMgrShell().cmdloop()
    except KeyboardInterrupt:
        print("\nExiting...")
