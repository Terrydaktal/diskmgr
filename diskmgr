#!/usr/bin/env python3
import cmd
import subprocess
import os
import sys
import shlex
import csv
import json
import time
import argparse
import random
from pathlib import Path

# Configuration
MAP_FILENAME = 'luksmap.tsv'
PASSGEN_BIN = 'passgen'

# ANSI Colors
class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def log(msg, level='INFO'):
    if level == 'ERROR':
        print(f"{Colors.FAIL}ERROR: {msg}{Colors.ENDC}", file=sys.stderr)
    elif level == 'WARN':
        print(f"{Colors.WARNING}WARNING: {msg}{Colors.ENDC}", file=sys.stderr)
    else:
        print(f"{Colors.OKBLUE}diskmgr: {msg}{Colors.ENDC}")

def run_command(command, check=True, input_str=None, capture_output=True, sudo=False):
    if sudo:
        command = ['sudo'] + command
    
    try:
        result = subprocess.run(
            command,
            input=input_str,
            text=True,
            check=check,
            stdout=subprocess.PIPE if capture_output else None,
            stderr=subprocess.PIPE if capture_output else None
        )
        return result
    except subprocess.CalledProcessError as e:
        if check:
            log(f"Command failed: {' '.join(command)}", 'ERROR')
            if e.stderr:
                log(e.stderr.strip(), 'ERROR')
            raise
        return e

def get_script_dir():
    return Path(__file__).parent.resolve()

def get_map_file_path():
    return get_script_dir() / MAP_FILENAME

def read_luks_map():
    map_file = get_map_file_path()
    if not map_file.exists():
        return {}
    
    mappings = {}
    with open(map_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            parts = line.split(None, 1) # Split on first whitespace
            if len(parts) == 2:
                name, path = parts
                mappings[name] = path
    return mappings

def save_luks_map(mappings):
    map_file = get_map_file_path()
    with open(map_file, 'w') as f:
        for name, path in mappings.items():
            f.write(f"{name}\t{path}\n")

def disk_base_name(dev_path):
    # Given /dev/sdb or /dev/sdb1 -> sdb
    try:
        dev_name = os.path.basename(dev_path)
        # simplistic, better to use lsblk
        res = run_command(['lsblk', '-no', 'PKNAME', dev_path], check=False)
        if res.stdout.strip():
            return res.stdout.strip()
        return dev_name
    except:
        return os.path.basename(dev_path)

def disk_is_nvme(dev_path):
    # Check if NVMe
    try:
        res = run_command(['lsblk', '-dno', 'TRAN', dev_path], check=False)
        if res.stdout.strip() == 'nvme':
            return True
        if 'nvme' in dev_path:
            return True
    except:
        pass
    return False

def disk_is_rotational(dev_path):
    try:
        base = disk_base_name(dev_path)
        p = Path(f"/sys/block/{base}/queue/rotational")
        if p.exists():
            return p.read_text().strip() == "1"
    except:
        pass
    return False

def disk_discard_supported(dev_path):
    try:
        res = run_command(['lsblk', '-dno', 'DISC-MAX', dev_path], check=False)
        val = res.stdout.strip()
        return val and val != "0B" and val != "0"
    except:
        return False

def secure_erase_disk(dev_path):
    if not os.path.exists(dev_path):
        log(f"Device not found: {dev_path}", 'ERROR')
        return False
        
    if disk_is_nvme(dev_path):
        log(f"Secure erase: NVMe detected ({dev_path}) -> nvme format --ses=1")
        # Ensure nvme-cli is present?
        try:
            run_command(['nvme', 'format', dev_path, '--ses=1'], sudo=True)
            run_command(['udevadm', 'settle'], sudo=True)
            return True
        except Exception as e:
            log(f"NVMe format failed: {e}", 'ERROR')
            return False

    if disk_is_rotational(dev_path):
        log(f"Secure erase: HDD detected ({dev_path}) -> full zero overwrite (dd)")
        try:
            # bs=16M status=progress
            run_command(['dd', 'if=/dev/zero', f'of={dev_path}', 'bs=16M', 'status=progress', 'oflag=direct'], sudo=True)
            run_command(['sync'], sudo=True)
            return True
        except Exception as e:
            log(f"DD overwrite failed: {e}", 'ERROR')
            return False

    # SSD/Flash
    log(f"Secure erase: SSD/Flash detected ({dev_path}) -> blkdiscard")
    if disk_discard_supported(dev_path):
        try:
            run_command(['blkdiscard', '-f', dev_path], sudo=True)
            run_command(['udevadm', 'settle'], sudo=True)
            return True
        except Exception as e:
            log(f"blkdiscard failed: {e}", 'ERROR')
            return False
    else:
        log("Discard not supported on this device. Cannot perform secure erase.", 'ERROR')
        return False

class CmdArgumentParser(argparse.ArgumentParser):
    def error(self, message):
        raise argparse.ArgumentError(None, message)

class DiskMgrShell(cmd.Cmd):
    intro = 'Welcome to diskmgr. Type help or ? to list commands.\n'
    prompt = f'{Colors.OKGREEN}(diskmgr) {Colors.ENDC}'
    
    def __init__(self):
        super().__init__()
        self.mappings = read_luks_map()
        self.unmapped_cache = []

    def do_help(self, arg):
        'List available commands with "help" or detailed help with "help cmd".'
        if arg:
            super().do_help(arg)
            return

        print(f"\n{Colors.HEADER}Disk Manager (diskmgr){Colors.ENDC}")
        print("A utility designed to simplify the management of encrypted and plain removable media.")
        print("It maps friendly labels to hardware-specific Persistent Device Paths (PDP), ensuring")
        print("that disks are recognized reliably even if device nodes (like /dev/sdb) change.\n")
        
        print(f"{Colors.BOLD}COMMANDS:{Colors.ENDC}")
        print(f"  {Colors.OKGREEN}list{Colors.ENDC}")
        print("      Shows all configured mappings and their status (Open/Mounted).")
        print("      Also lists unmapped system disks with discovery IDs (e.g., U1, U2).")
        
        print(f"  {Colors.OKGREEN}map <id> <name>{Colors.ENDC}")
        print("      Assigns a friendly name to a disk.")
        print("      <id> can be a discovery ID (U1) or an existing index (1).")
        print("      Example: 'map U1 backup_drive'")
        
        print(f"  {Colors.OKGREEN}open <name>{Colors.ENDC}")
        print("      Unlocks LUKS (if encrypted) and mounts the disk.")
        
        print(f"  {Colors.OKGREEN}close <name>{Colors.ENDC}")
        print("      Unmounts and closes the disk.")

        print(f"  {Colors.OKGREEN}label <name> [new_label]{Colors.ENDC}")
        print("      Get or set the filesystem label of an OPEN disk.")
        
        print(f"  {Colors.OKGREEN}create <name> [options]{Colors.ENDC}")
        print("      Initializes a new disk (Erase -> LUKS -> Format -> Mount).")
        print("      Use 'help create' for full options.")

        print(f"  {Colors.OKGREEN}erase <name/target>{Colors.ENDC}")
        print("      Securely erases a disk (NVMe format, blkdiscard, or dd overwrite).")
        print("      WARNING: Destructive!")
        
        print(f"  {Colors.OKGREEN}exit / quit / Ctrl+D{Colors.ENDC}")
        print("      Exit the application.")

        print("\nType 'help <command>' for more specific details.")

    def do_exit(self, arg):
        'Exit the application'
        return True

    def do_quit(self, arg):
        'Exit the application'
        return True

    def do_EOF(self, arg):
        'Exit the application'
        print("")
        return True

    def get_disk_info(self):
        # Use lsblk -J for JSON output
        cmd = ['lsblk', '-J', '-e', '7', '-o', 'NAME,KNAME,TYPE,RM,SIZE,FSTYPE,LABEL,MOUNTPOINT,MODEL,WWN,PKNAME,TRAN,DISC-MAX']
        try:
            res = run_command(cmd, capture_output=True)
            data = json.loads(res.stdout)
            return data.get('blockdevices', [])
        except Exception as e:
            log(f"Failed to list disks: {e}", 'ERROR')
            return []

    def flatten_disks(self, devices):
        """Recursively flatten the lsblk tree structure."""
        flat = []
        for dev in devices:
            flat.append(dev)
            if 'children' in dev:
                flat.extend(self.flatten_disks(dev['children']))
        return flat

    def find_persistent_path(self, dev_node, wwn=None, type_='disk'):
        # Try to find /dev/disk/by-id/ match
        
        # 1. Try WWN logic from opendisk
        if wwn:
            prefix = "nvme-" if wwn.startswith("eui.") else "wwn-"
            path = f"/dev/disk/by-id/{prefix}{wwn}"
            try:
                if os.path.realpath(path) == os.path.realpath(f"/dev/{dev_node}"):
                    return path
            except:
                pass

        # 2. Brute force check /dev/disk/by-id
        by_id_dir = Path('/dev/disk/by-id')
        if by_id_dir.exists():
            for link in by_id_dir.iterdir():
                try:
                    if link.resolve() == Path(f"/dev/{dev_node}").resolve():
                        return str(link)
                except:
                    continue
        
        return "-"

    def do_list(self, arg):
        '''List all configured mappings and available system disks in a single table.
        
        UNDER THE HOOD:
        1.  Resolution: Refreshes mappings from luksmap.tsv.
        2.  Hardware Discovery: Uses 'lsblk' to gather hardware properties and identifies 
            underlying physical partitions even when opened as virtual devices.
        3.  Zero-Sudo LUKS Detection: Queries the system 'udev' database via 'udevadm info' 
            to accurately identify encrypted disks without requiring root privileges.
        4.  Status Logic:
            - MISSING: Persistent path not found in /dev.
            - CLOSED: Present but locked (LUKS) or unmounted (Plain).
            - OPEN: Unlocked/Decrypted but not yet mounted.
            - MOUNTED: Active filesystem attached to the preferred path (/media/$USER/name).
        5.  Dynamic Formatting: Pre-calculates the maximum width of every column across 
            all rows for a perfectly aligned, readable table.
        6.  Exclusion Logic: Rigorously filters out virtual mapper devices and their 
            kernel aliases (dm-X) from the unmapped list once they are active.
        '''
        self.mappings = read_luks_map()
        mapped_rows = []
        unmapped_rows = []
        
        # 1. Collect Mapped Disks
        mapped_real_paths = set()
        mapped_names = set()
        i = 1
        for name, path in self.mappings.items():
            phys_device = "-"
            dm_device = ""
            fstype = "-"
            size = "-"
            label = "-"
            mountpoint = f"/media/{os.environ.get('USER', 'root')}/{name}"
            is_luks = "-"
            state = "MISSING"
            
            mapped_names.add(name)

            if os.path.exists(path):
                real_path = os.path.realpath(path)
                mapped_real_paths.add(real_path)
                state = "CLOSED"
                is_luks = "N"
                
                # Get Physical Device Properties
                try:
                    cmd_p = ['lsblk', '-n', '-P', '-o', 'KNAME,PKNAME,FSTYPE,SIZE,LABEL', real_path]
                    res_p = run_command(cmd_p, check=False)
                    if res_p.stdout.strip():
                        props = {}
                        for part in shlex.split(res_p.stdout.strip()):
                            if '=' in part:
                                k, v = part.split('=', 1)
                                props[k] = v
                        
                        phys_device = props.get('KNAME', '-')
                        # If the 'physical' device is actually a DM device, try to get its parent
                        if phys_device.startswith('dm-'):
                            parent = props.get('PKNAME', '')
                            if parent: phys_device = parent

                        fstype = props.get('FSTYPE', '-')
                        size = props.get('SIZE', '-')
                        label = props.get('LABEL', '-')
                        
                        # Check LUKS status using udev (No sudo required)
                        res_u = run_command(['udevadm', 'info', '--query=property', f'--name={real_path}'], check=False)
                        if 'ID_FS_TYPE=crypto_LUKS' in res_u.stdout:
                            is_luks = "Y"
                        elif fstype == 'crypto_LUKS':
                            is_luks = "Y"
                except:
                    pass

            mapper_path = f"/dev/mapper/{name}"
            if is_luks == "Y" and os.path.exists(mapper_path):
                mapped_real_paths.add(os.path.realpath(mapper_path))
                mapped_real_paths.add(mapper_path)
                mapped_names.add(name) # Hide '1a'
                
                state = "OPEN"
                try:
                    cmd_m = ['lsblk', '-n', '-P', '-o', 'KNAME,PKNAME,FSTYPE,LABEL,SIZE', mapper_path]
                    res_m = run_command(cmd_m, check=False)
                    if res_m.stdout.strip():
                        props = {}
                        for part in shlex.split(res_m.stdout.strip()):
                            if '=' in part:
                                k, v = part.split('=', 1)
                                props[k] = v
                        # Get mapper kernel name (e.g. dm-0)
                        dm_device = props.get('KNAME', '')
                        if dm_device: mapped_names.add(dm_device)
                        
                        # Also hide the physical parent of the DM device
                        dm_parent = props.get('PKNAME', '')
                        if dm_parent: 
                            mapped_names.add(dm_parent)
                            if phys_device == '-': phys_device = dm_parent
                        
                        # Use mapper properties for FS details
                        if props.get('FSTYPE'): fstype = props.get('FSTYPE')
                        if props.get('LABEL'): label = props.get('LABEL')
                        if props.get('SIZE'): size = props.get('SIZE')
                except:
                    pass
                
                res = run_command(['findmnt', '-rn', '-S', mapper_path, '-o', 'TARGET'], check=False)
                if res.returncode == 0 and res.stdout.strip():
                    mountpoint = res.stdout.strip()
                    state = "MOUNTED"
            elif is_luks == "N" and state != "MISSING":
                 res = run_command(['findmnt', '-rn', '-S', os.path.realpath(path), '-o', 'TARGET'], check=False)
                 if res.returncode == 0 and res.stdout.strip():
                     mountpoint = res.stdout.strip()
                     state = "MOUNTED"

            display_dev = phys_device
            if dm_device and dm_device != phys_device:
                display_dev = f"{phys_device}({dm_device})"

            mapped_rows.append({
                'idx': f"[{i}]", 'name': name, 'luks': is_luks, 'state': state, 
                'fstype': fstype, 'label': label if label else "-", 'mount': mountpoint, 
                'dev': display_dev, 'size': size, 'path': path
            })
            i += 1

        # 2. Collect Unmapped Disks
        all_disks = self.get_disk_info()
        flat_disks = self.flatten_disks(all_disks)
        self.unmapped_cache = []
        u_idx = 1
        for dev in flat_disks:
            d_name = dev.get('name') # Usually mapper name or short kernel name
            d_kname = dev.get('kname') # Kernel name (sda2, dm-0)
            if not d_name or d_name.startswith('loop'):
                continue
            
            # Hide if NAME or KNAME matches a known mapping (1a, dm-0, etc.)
            if d_name in mapped_names or d_kname in mapped_names:
                continue

            dev_path = f"/dev/{d_name}"
            real_dev_path = os.path.realpath(dev_path)
            
            # Hide if this is a known mapped physical device or mapper device path
            if real_dev_path in mapped_real_paths or dev_path in mapped_real_paths:
                continue
            
            # Check for /dev/mapper/ links appearing in dev nodes
            if os.path.exists(f"/dev/mapper/{d_name}"):
                continue

            fstype = dev.get('fstype') or '-'
            label = dev.get('label') or '-'
            size = dev.get('size') or '-'
            mountpoint = dev.get('mountpoint') or '-'
            pdp = self.find_persistent_path(d_name, dev.get('wwn'))
            
            self.unmapped_cache.append({
                'dev': dev_path, 'pdp': pdp if pdp != '-' else dev_path,
                'size': size, 'model': dev.get('model'), 'type': dev.get('type')
            })
            
            is_luks_u = "N"
            if fstype == 'crypto_LUKS':
                is_luks_u = "Y"
            else:
                # Check udev for unmapped too
                res_uu = subprocess.run(['udevadm', 'info', '--query=property', f'--name={dev_path}'], capture_output=True, text=True)
                if 'ID_FS_TYPE=crypto_LUKS' in res_uu.stdout:
                    is_luks_u = "Y"

            state_u = "MOUNTED" if mountpoint != '-' else "UNMOUNTED"
            if is_luks_u == "Y": state_u = "LOCKED"

            unmapped_rows.append({
                'idx': f"[U{u_idx}]", 'name': "-", 'luks': is_luks_u, 'state': state_u,
                'fstype': fstype, 'label': label, 'mount': mountpoint,
                'dev': d_kname if d_kname else d_name, 'size': size, 'path': pdp
            })
            u_idx += 1

        # 3. Calculate Widths and Print
        all_rows = mapped_rows + unmapped_rows
        headers = ["#", "NAME", "LUKS", "STATE", "FSTYPE", "LABEL", "MOUNTPOINT", "DEVICE", "SIZE", "PERSISTENT PATH"]
        keys = ['idx', 'name', 'luks', 'state', 'fstype', 'label', 'mount', 'dev', 'size', 'path']
        widths = {k: len(h) for k, h in zip(keys, headers)}
        
        for row in all_rows:
            for k in keys:
                widths[k] = max(widths[k], len(str(row[k])))
        
        fmt = "  ".join([f"{{:<{widths[k]}}}" for k in keys])

        print(f"\n{Colors.HEADER}--- Disk Management Table ({get_map_file_path()}) ---{Colors.ENDC}")
        print(fmt.format(*headers))
        print("-" * (sum(widths.values()) + len(keys)*2))
        for row in all_rows:
            print(fmt.format(*[row[k] for k in keys]))
        print("")

    def resolve_target(self, target_str):
        '''Resolves a target string to a physical path.
        Only supports Discovery IDs (U1, [U1]) or existing mapping names.
        '''
        clean = target_str.strip('[]')
        
        # 1. Check Discovery ID
        if clean.startswith('U') and clean[1:].isdigit():
            idx = int(clean[1:]) - 1
            if 0 <= idx < len(self.unmapped_cache):
                return self.unmapped_cache[idx]['pdp']
            return None
            
        # 2. Check Mapping Name
        self.mappings = read_luks_map()
        if target_str in self.mappings:
            return self.mappings[target_str]
            
        return None

    def extensive_confirm(self, target_name):
        print(f"\n{Colors.FAIL}{Colors.BOLD}!!! EXTENSIVE CONFIRMATION REQUIRED !!!{Colors.ENDC}")
        print(f"You are about to perform a DESTRUCTIVE operation on: {Colors.WARNING}{target_name}{Colors.ENDC}")
        print("To proceed, you must answer two math questions correctly.")
        
        for i in range(2):
            a = random.randint(11, 99)
            b = random.randint(11, 99)
            op = random.choice(['+', '-'])
            if op == '+':
                ans = a + b
            else:
                ans = a - b
            
            try:
                user_ans = input(f"Question {i+1}/2: What is {a} {op} {b}? ")
                if not user_ans or int(user_ans) != ans:
                    log("Incorrect answer. Aborting operation.", 'ERROR')
                    return False
            except ValueError:
                log("Invalid input. Aborting operation.", 'ERROR')
                return False
        
        print(f"{Colors.OKGREEN}Verification successful. Proceeding...{Colors.ENDC}")
        return True

    def do_map(self, arg):
        '''Create or modify a persistent mapping: map <id/name> <new_name>
        
        Usage:
          map [U1] backup    Assigns friendly name to discovery ID (e.g., map U1 backup)
          map 1a backup      Renames an existing mapping (e.g., map 1a backup)
        
        Note: Raw device paths (e.g., /dev/sdb) are NOT allowed.
        
        UNDER THE HOOD:
        1.  Input Resolution: 
            - discovery ID (e.g., [U1]): Resolves the temporary device to its Persistent Device Path (PDP).
            - mapping name (e.g., 1a): Selects an existing mapping for RENAME operations.
        2.  PDP Linking: Extracts the /dev/disk/by-id/ path for the target hardware.
        3.  Conflict Check: Ensures the new friendly name is not already in use.
        4.  Persistence: Writes the [Name <TAB> PDP] pair to luksmap.tsv.
        '''
        args = arg.split()
        if len(args) != 2:
            log("Usage: map <id/name> <new_name>", 'ERROR')
            return

        target, name = args
        self.mappings = read_luks_map() # Refresh
        
        # 1. Check for Rename (target is a mapping name)
        if target in self.mappings:
            real_target = self.mappings[target]
            log(f"Renaming mapping {target} -> {name}")
            del self.mappings[target]
        else:
            # 2. Check for New Map (target is a discovery ID)
            real_target = self.resolve_target(target)
            if not real_target:
                log(f"Invalid target: '{target}'. Use a Discovery ID (e.g., [U1]) or an existing name.", 'ERROR')
                return
            log(f"Resolved {target} -> {real_target}")
        
        if name in self.mappings:
             log(f"Mapping '{name}' already exists.", 'ERROR')
             return

        # Collision Prevention: Prevent names that look like IDs
        clean_name = name.strip('[]')
        if (clean_name.startswith('U') and clean_name[1:].isdigit()) or clean_name.isdigit():
            log(f"Invalid name: '{name}'. Names cannot be simple numbers or match the 'U1' ID format.", 'ERROR')
            return

        self.mappings[name] = real_target
        save_luks_map(self.mappings)
        log(f"Mapping saved: {name} -> {real_target}")

    def do_open(self, arg):
        '''Unlock (if encrypted) and mount a disk: open <name>
        
        UNDER THE HOOD:
        1.  Identity Resolution: Looks up the friendly name in luksmap.tsv to find the PDP.
        2.  Hardware Wait: Polls for up to 10 seconds to allow for hardware spin-up/udev events.
        3.  Validation: 
            - Runs 'cryptsetup isLuks' to check for encryption.
            - If NOT encrypted, verifies the existence of a valid filesystem.
        4.  Decryption (LUKS only):
            - Executes 'passgen' to retrieve the passphrase.
            - Pipes the passphrase into 'cryptsetup open' to create a cleartext device in /dev/mapper/.
        5.  Mounting:
            - Ensures the directory /media/$USER/<name> exists.
            - Attaches the (decrypted) device to the mountpoint.
        6.  Policy Enforcement: If the disk is already mounted at a non-standard path, 
            it unmounts and remounts it to the preferred /media/$USER/<name> path.
        '''
        name = arg.strip()
        if not name:
             log("Usage: open <name>", 'ERROR')
             return
             
        self.mappings = read_luks_map()
        if name not in self.mappings:
            log(f"Unknown mapping: {name}. Use 'list' to find Discovery IDs and 'map' them first.", 'ERROR')
            return
            
        src = self.mappings[name]
        
        # Wait for device
        log(f"Waiting for device {src}...")
        for _ in range(50): # 10s wait
            if os.path.exists(src):
                break
            time.sleep(0.2)
            
        if not os.path.exists(src):
            log(f"Device not found: {src}", 'ERROR')
            return
            
        devnode = os.path.realpath(src)
        
        # Check LUKS
        is_luks = False
        try:
            run_command(['sudo', 'cryptsetup', 'isLuks', devnode])
            is_luks = True
        except subprocess.CalledProcessError:
             # Not LUKS, check if it has a filesystem
             res = run_command(['lsblk', '-n', '-o', 'FSTYPE', devnode], check=False)
             if not res.stdout.strip():
                 log(f"Device {devnode} is not a valid LUKS device and has no recognizable filesystem.", 'ERROR')
                 return
             log(f"Device {devnode} is not LUKS, but has a filesystem. Proceeding with plain mount.")

        mapper_path = f"/dev/mapper/{name}"
        target_to_mount = mapper_path

        if is_luks:
            if not os.path.exists(mapper_path):
                log(f"Opening LUKS mapping {name}...")
                # Use passgen
                pg_cmd = subprocess.Popen([PASSGEN_BIN], stdout=subprocess.PIPE, text=True)
                # Pipe to cryptsetup
                try:
                    run_command(
                        ['cryptsetup', 'open', '--key-file', '-', src, name],
                        input_str=pg_cmd.communicate()[0],
                        sudo=True,
                        check=True
                    )
                    log("LUKS opened.")
                except Exception as e:
                    log(f"Failed to open LUKS: {e}", 'ERROR')
                    return
            else:
                log("Mapping already exists.")
        else:
            # Plain disk
            target_to_mount = devnode

        # Mount
        mountpoint = f"/media/{os.environ.get('USER', 'root')}/{name}"
        if not os.path.exists(mountpoint):
            run_command(['mkdir', '-p', mountpoint], sudo=True)
            
        # Check if mounted
        res = run_command(['findmnt', '-rn', '-S', target_to_mount, '-o', 'TARGET'], check=False)
        current_mnt = res.stdout.strip()

        if not current_mnt:
            log(f"Mounting {target_to_mount} to {mountpoint}...")
            run_command(['mount', target_to_mount, mountpoint], sudo=True)
            log("Mounted.")
        elif current_mnt != mountpoint:
            log(f"Disk is mounted at {current_mnt} (system default). Overriding...")
            try:
                run_command(['umount', current_mnt], sudo=True)
                run_command(['mount', target_to_mount, mountpoint], sudo=True)
                log(f"Successfully moved mount to {mountpoint}")
            except Exception as e:
                log(f"Failed to override mount: {e}. It may be in use.", 'WARN')
        else:
            log(f"Already mounted at {mountpoint}.")

    def do_close(self, arg):
        '''Unmount and lock (if encrypted) a disk: close <name>
        
        UNDER THE HOOD:
        1.  Unmounting (Encrypted & Plain): 
            - Flushes all pending writes to the disk (data integrity).
            - Terminates active file handles to the device.
            - Attempts unmount by mapper path (LUKS), source path (Plain), or guessed mountpoint.
        2.  Locking (LUKS only):
            - Commands the kernel to wipe encryption keys from RAM.
            - Removes the virtual cleartext device from /dev/mapper/.
        3.  Audit: Checks and displays remaining active mappings for security awareness.
        '''
        name = arg.strip()
        if not name:
            log("Usage: close <name>", 'ERROR')
            return

        mapper_path = f"/dev/mapper/{name}"
        mount_guess = f"/media/{os.environ.get('USER', 'root')}/{name}"

        run_command(['sudo', '-v']) # Refresh sudo

        # Unmount
        unmounted = False
        # 1. Try by mapper
        res = run_command(['findmnt', '-rn', '-S', mapper_path, '-o', 'TARGET'], check=False)
        if res.returncode == 0 and res.stdout.strip():
            mp = res.stdout.strip()
            log(f"Unmounting {mp}...")
            run_command(['umount', mp], sudo=True)
            unmounted = True
        
        # 2. Try by source path (for non-LUKS)
        if not unmounted:
            self.mappings = read_luks_map()
            if name in self.mappings:
                src = self.mappings[name]
                res = run_command(['findmnt', '-rn', '-S', src, '-o', 'TARGET'], check=False)
                if res.returncode == 0 and res.stdout.strip():
                    mp = res.stdout.strip()
                    log(f"Unmounting {mp}...")
                    run_command(['umount', mp], sudo=True)
                    unmounted = True

        # 3. Try by guess
        if not unmounted:
            if run_command(['findmnt', '-rn', '-M', mount_guess], check=False).returncode == 0:
                 log(f"Unmounting {mount_guess}...")
                 run_command(['umount', mount_guess], sudo=True)
                 unmounted = True
        
        # Close
        if os.path.exists(mapper_path):
            log(f"Closing mapping {name}...")
            run_command(['cryptsetup', 'close', name], sudo=True)
            log("Closed.")
        else:
            log("Mapping not open or already closed.")

    def do_label(self, arg):
        '''Get or set the filesystem label of an OPEN disk: label <name> [new_label]
        
        UNDER THE HOOD:
        1.  Validation: Verifies that the disk is currently open/unlocked.
        2.  Identification: Queries the filesystem type (ext4, xfs, etc.) via 'lsblk'.
        3.  Labeling:
            - ext4: Uses 'e2label' on the active mapper device.
            - xfs: Requires a temporary unmount, then uses 'xfs_admin -L', then remounts.
        
        The label is written directly to the disk hardware and persists across different computers.
        '''
        args = arg.split()
        if not args:
            log("Usage: label <name> [new_label]", 'ERROR')
            return
            
        name = args[0]
        new_label = args[1] if len(args) > 1 else None
        
        # Check mapping
        mapper_path = f"/dev/mapper/{name}"
        if not os.path.exists(mapper_path):
             # check if it is a known mapping
             self.mappings = read_luks_map()
             if name in self.mappings:
                 log(f"Mapping '{name}' is not open. Please 'open {name}' first.", 'ERROR')
                 return
             log(f"Device not found: {mapper_path}. Is it an open mapping?", 'ERROR')
             return
             
        # Get info
        try:
            cmd = ['lsblk', '-J', '-o', 'FSTYPE,MOUNTPOINT,LABEL', mapper_path]
            res = run_command(cmd, capture_output=True)
            data = json.loads(res.stdout)
            dev = data.get('blockdevices', [{}])[0]
            fstype = dev.get('fstype')
            mountpoint = dev.get('mountpoint')
            current_label = dev.get('label')
        except Exception as e:
            log(f"Failed to inspect device: {e}", 'ERROR')
            return
            
        if not new_label:
            print(f"Label for {name} ({fstype}): {current_label if current_label else '<none>'}")
            return
            
        if current_label == new_label:
            log("Label is already set to that value.")
            return
            
        log(f"Changing label: '{current_label}' -> '{new_label}' ({fstype})")
        
        if fstype == 'ext4':
            try:
                run_command(['e2label', mapper_path, new_label], sudo=True)
                log("Label updated.")
            except:
                pass # run_command logs error
        elif fstype == 'xfs':
            # XFS requires unmount
            remount_needed = False
            if mountpoint:
                log(f"XFS requires unmounting to label. Unmounting {mountpoint}...")
                try:
                    run_command(['umount', mountpoint], sudo=True)
                    remount_needed = True
                except Exception as e:
                    log(f"Failed to unmount: {e}", 'ERROR')
                    return

            try:
                run_command(['xfs_admin', '-L', new_label, mapper_path], sudo=True)
                log("Label updated.")
            except:
                pass
            finally:
                if remount_needed:
                    log(f"Remounting {mountpoint}...")
                    try:
                         run_command(['mount', mapper_path, mountpoint], sudo=True)
                    except Exception as e:
                        log(f"Failed to remount: {e}. You may need to mount manually.", 'ERROR')

        else:
            log(f"Unsupported filesystem for labeling: {fstype}", 'ERROR')

    def do_erase(self, arg):
        '''Securely erase a disk: erase <target> [options]
        
        Target can be:
          - A mapping name (e.g., backup)
          - A discovery ID (e.g., [U1])
        
        Note: Raw device paths (e.g., /dev/sdb) are NOT allowed.
        
        Options:
          -y, --yes         Skip math confirmation questions
        
        UNDER THE HOOD:
        1.  Target Resolution: Maps friendly name or ID to a raw block device.
        2.  Destructive Wipe:
            - NVMe: Uses 'nvme format --ses=1' for firmware-level crypto-erase.
            - SSD: Uses 'blkdiscard' to inform the controller that all blocks are empty.
            - HDD: Uses 'dd' for a full zero-pass overwrite of the physical platters.
        3.  Verification: Executes 'udevadm settle' and 'sync' to ensure all operations are committed.
        
        WARNING: This operation is IRREVERSIBLE.
        '''
        parser = CmdArgumentParser(prog='erase', add_help=False)
        parser.add_argument('target', help='Target name or device')
        parser.add_argument('-y', '--yes', action='store_true')
        
        try:
            split_args = shlex.split(arg)
            args = parser.parse_args(split_args)
        except argparse.ArgumentError as e:
            log(str(e), 'ERROR')
            return
        except SystemExit:
            return

        target_arg = args.target
        real_target = self.resolve_target(target_arg)
        
        if not real_target:
            log(f"Invalid target: '{target_arg}'. Use a Discovery ID (e.g., [U1]) or an existing name.", 'ERROR')
            return
        
        if not os.path.exists(real_target):
            log(f"Target not found: {real_target}", 'ERROR')
            return
            
        real_target = os.path.realpath(real_target)
        log(f"Target resolved: {real_target}")
        
        if not args.yes:
            if not self.extensive_confirm(real_target):
                return

        run_command(['sudo', '-v'])
        
        # Unmount dependencies?
        # TODO: checking mounts
        
        if secure_erase_disk(real_target):
            log("Secure erase completed successfully.")
        else:
            log("Secure erase failed.", 'ERROR')


    def do_create(self, arg):
        '''Initialize a new disk: create <target> <name> [options]
        
        Parameters:
          <target>          Discovery ID from the list command (e.g., [U1])
          <name>            The permanent MAPPING NAME (used for mounting and commands).
                            This will also be used as the default filesystem LABEL.
        
        Note: Raw device paths (e.g., /dev/sdb) are NOT allowed.
        
        Options:
          --fs <ext4|xfs>   Filesystem type (default: ext4)
          --label <label>   Set a different internal filesystem label (other than <name>)
          --plain           Create a non-encrypted disk (skips LUKS)
          --gpt             Create GPT partition table + 1 partition
          --mbr             Create MBR partition table + 1 partition
          -y, --yes         Skip math confirmation questions
        
        UNDER THE HOOD:
        1.  Unmount: Forcefully unmounts any existing partitions on the target.
        2.  Wipe: Executes 'wipefs' to remove old filesystem signatures.
        3.  Partitioning (Optional): Uses 'sgdisk' (GPT) or 'sfdisk' (MBR) to create a single partition.
        4.  LUKS Format (Default):
            - Uses 'passgen' to generate a master key.
            - Runs 'cryptsetup luksFormat' with LUKS2 encryption.
        5.  Filesystem: Formats the cleartext device with ext4 or xfs.
        6.  Persistence: Adds the new disk's PDP to luksmap.tsv automatically.
        '''
        parser = CmdArgumentParser(prog='create', add_help=False)
        parser.add_argument('args', nargs='+', help='<name> or <target> <name>')
        parser.add_argument('--fs', default='ext4', choices=['ext4', 'xfs'])
        parser.add_argument('--label', help='Filesystem label')
        parser.add_argument('--plain', action='store_true', help='No LUKS encryption')
        parser.add_argument('--gpt', action='store_true')
        parser.add_argument('--mbr', action='store_true')
        parser.add_argument('-y', '--yes', action='store_true')

        try:
            split_args = shlex.split(arg)
            args = parser.parse_args(split_args)
        except argparse.ArgumentError as e:
            log(str(e), 'ERROR')
            return
        except SystemExit:
            return

        target_arg = None
        name = None

        if len(args.args) == 1:
            name = args.args[0]
            # Must already exist in map
            self.mappings = read_luks_map()
            if name not in self.mappings:
                log(f"Name '{name}' not found in map. Use 'create <target> <name>' to initialize it.", 'ERROR')
                return
            target_arg = name # Will be resolved to path
        elif len(args.args) == 2:
            target_arg = args.args[0]
            name = args.args[1]
        else:
            log("Invalid arguments. Usage: create <target> <name>", 'ERROR')
            return

        # Resolve target
        target = self.resolve_target(target_arg)
        if not target:
            log(f"Invalid target: '{target_arg}'. Use a Discovery ID (e.g., [U1]) or an existing name.", 'ERROR')
            return

        # Wait/Verify target existence
        real_target = os.path.realpath(target)
        if not os.path.exists(real_target):
            log(f"Target device not found: {target} (resolved: {real_target})", 'ERROR')
            return
            
        log(f"Target: {real_target}")
        log(f"Name: {name}")
        
        # Safety checks
        if not args.yes:
            if not self.extensive_confirm(f"{name} ({real_target})"):
                return

        run_command(['sudo', '-v'])

        # Unmount anything on the disk
        log("Ensuring target is unmounted...")
        # (Simplified unmount check)
        
        # Always do a soft wipe for create
        run_command(['wipefs', '-a', real_target], sudo=True)

        crypt_target = real_target
        
        # Partitioning
        if args.gpt:
            log("Creating GPT partition...")
            run_command(['sgdisk', '--zap-all', real_target], sudo=True)
            run_command(['sgdisk', '-n', f'1:0:0', '-t', '1:8300', '-c', f'1:{name}', real_target], sudo=True)
            run_command(['udevadm', 'settle'], sudo=True)
            # Guess partition name
            if 'nvme' in real_target:
                crypt_target = f"{real_target}p1"
            else:
                crypt_target = f"{real_target}1"
        elif args.mbr:
            log("Creating MBR partition...")
            # using sfdisk scripting
            sfdisk_script = f"label: dos\n{real_target}1 : start=2048, type=83"
            run_command(['sfdisk', '--wipe', 'always', '--wipe-partitions', 'always', real_target], 
                       input_str=sfdisk_script, sudo=True)
            run_command(['udevadm', 'settle'], sudo=True)
             # Guess partition name
            if 'nvme' in real_target:
                crypt_target = f"{real_target}p1"
            else:
                crypt_target = f"{real_target}1"

        if not args.plain:
            # LUKS Format
            log(f"Formatting LUKS on {crypt_target}...")
            pg_cmd = subprocess.Popen([PASSGEN_BIN], stdout=subprocess.PIPE, text=True)
            try:
                run_command(
                    ['cryptsetup', 'luksFormat', '--type', 'luks2', '--batch-mode', '--key-file', '-', crypt_target],
                    input_str=pg_cmd.communicate()[0],
                    sudo=True,
                    check=True
                )
            except Exception as e:
                log(f"LUKS Format failed: {e}", 'ERROR')
                return

            # Open
            log("Opening new LUKS volume...")
            pg_cmd = subprocess.Popen([PASSGEN_BIN], stdout=subprocess.PIPE, text=True)
            run_command(
                ['cryptsetup', 'open', '--key-file', '-', crypt_target, name],
                input_str=pg_cmd.communicate()[0],
                sudo=True,
                check=True
            )
            fs_target = f"/dev/mapper/{name}"
        else:
            fs_target = crypt_target

        # Mkfs
        label = args.label if args.label else name
        log(f"Formatting filesystem {args.fs} (label={label}) on {fs_target}...")
        
        if args.fs == 'ext4':
            run_command(['mkfs.ext4', '-F', '-L', label, fs_target], sudo=True)
        elif args.fs == 'xfs':
            run_command(['mkfs.xfs', '-f', '-L', label, fs_target], sudo=True)

        # Mount
        mountpoint = f"/media/{os.environ.get('USER', 'root')}/{name}"
        run_command(['mkdir', '-p', mountpoint], sudo=True)
        run_command(['mount', fs_target, mountpoint], sudo=True)

        # Update map if needed
        self.mappings = read_luks_map()
        if name not in self.mappings:
            stable_path = crypt_target
            # Try to find by-id
            pdp = self.find_persistent_path(os.path.basename(crypt_target))
            if pdp != '-':
                stable_path = pdp
            
            self.mappings[name] = stable_path
            save_luks_map(self.mappings)
            log(f"Added mapping: {name} -> {stable_path}")

        log("Disk initialization complete.")


if __name__ == '__main__':
    try:
        os.chmod(__file__, 0o755)
    except:
        pass
    try:
        DiskMgrShell().cmdloop()
    except KeyboardInterrupt:
        print("\nExiting...")
