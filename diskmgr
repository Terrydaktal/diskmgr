#!/usr/bin/env python3
import cmd
import subprocess
import os
import sys
import shlex
import csv
import json
import time
import argparse
import random
import re
import shutil
from pathlib import Path

# Configuration
MAP_FILENAME = 'diskmap.tsv'
PASSGEN_BIN = 'passgen'

# ANSI Colors
class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def log(msg, level='INFO'):
    if level == 'ERROR':
        print(f"{Colors.FAIL}ERROR: {msg}{Colors.ENDC}", file=sys.stderr)
    elif level == 'WARN':
        print(f"{Colors.WARNING}WARNING: {msg}{Colors.ENDC}", file=sys.stderr)
    else:
        print(f"{Colors.OKBLUE}diskmgr: {msg}{Colors.ENDC}")

def run_command(command, check=True, input_str=None, capture_output=True, sudo=False):
    if sudo:
        command = ['sudo'] + command
    
    try:
        result = subprocess.run(
            command,
            input=input_str,
            text=True,
            check=check,
            stdout=subprocess.PIPE if capture_output else None,
            stderr=subprocess.PIPE if capture_output else None
        )
        return result
    except subprocess.CalledProcessError as e:
        if check:
            log(f"Command failed: {' '.join(command)}", 'ERROR')
            if e.stderr:
                log(e.stderr.strip(), 'ERROR')
            raise
        return e

def _split_nonempty_lines(s):
    if not s:
        return []
    out = []
    for line in str(s).splitlines():
        line = line.strip()
        if line and line not in out:
            out.append(line)
    return out

def find_mount_targets(source):
    """
    Return a list of mount TARGETs for a given SOURCE.

    Notes:
    - A single filesystem can be mounted at multiple targets; findmnt will then
      return multiple lines. Callers must not treat stdout as a single path.
    - We resolve the source to a real path so /dev/mapper/<name> and /dev/dm-X
      match the same mount.
    """
    src_real = os.path.realpath(source)
    res = run_command(['findmnt', '-rn', '-S', src_real, '-o', 'TARGET'], check=False)
    if getattr(res, 'returncode', 1) != 0:
        return []
    return _split_nonempty_lines(getattr(res, 'stdout', ''))

def cleanup_mountpoint_dir(mountpoint):
    """
    Best-effort cleanup of a mountpoint directory after unmount.

    Only attempts removal for mountpoints under /media/$USER/ and only if the
    directory is no longer a mount target. Uses rmdir (so it only removes empty
    directories) to avoid deleting real data.
    """
    if not mountpoint:
        return

    user = os.environ.get('USER', 'root')
    media_root = os.path.realpath(f"/media/{user}")
    mp_real = os.path.realpath(mountpoint)
    if not (mp_real == media_root or mp_real.startswith(media_root + os.sep)):
        return

    # Still mounted? Don't touch it.
    if run_command(['findmnt', '-rn', '-M', mountpoint], check=False).returncode == 0:
        return

    res = run_command(['rmdir', mountpoint], sudo=True, check=False)
    if getattr(res, 'returncode', 1) == 0:
        log(f"Removed mountpoint directory {mountpoint}")

def _sysfs_block_name(dev_path):
    """Return kernel block name (e.g. sda2, nvme0n1p1, dm-0) for a /dev path."""
    return os.path.basename(os.path.realpath(dev_path))

def _sysfs_to_parent_disk_name(block_name, max_hops=16):
    """
    Best-effort: resolve a block device name to its underlying whole-disk name.

    - Partitions: sda2 -> sda, nvme0n1p1 -> nvme0n1
    - dm devices: dm-0 -> first slave (often sda2), then keep resolving
    """
    cur = block_name
    for _ in range(max_hops):
        sys_path = f"/sys/class/block/{cur}"
        if not os.path.exists(sys_path):
            break

        # If it's a device-mapper node, walk down to its first slave.
        if cur.startswith("dm-"):
            slaves_dir = os.path.join(sys_path, "slaves")
            try:
                slaves = sorted(os.listdir(slaves_dir)) if os.path.isdir(slaves_dir) else []
            except Exception:
                slaves = []
            if slaves:
                cur = slaves[0]
                continue
            break

        # If it's a partition, its parent is the directory above in sysfs.
        if os.path.exists(os.path.join(sys_path, "partition")):
            parent = os.path.basename(os.path.realpath(os.path.join(sys_path, "..")))
            if parent and parent != cur:
                cur = parent
                continue
            break

        # Already a whole-disk node (or at least not a partition we can detect).
        break

    return cur

#
# NOTE: refresh-related helpers were removed along with the refresh command.
#

def _parse_smart_attr_raw(out, attr_id):
    """
    Parse a smartctl -a attribute table RAW_VALUE for a given attribute ID.
    Returns a string (raw value) or None.
    """
    if not out:
        return None
    for line in str(out).splitlines():
        s = line.strip()
        if not s:
            continue
        # Attribute table rows typically start with the numeric ID.
        if not s.startswith(str(attr_id) + " "):
            continue
        parts = s.split()
        if len(parts) < 2:
            continue
        if parts[0] != str(attr_id):
            continue
        # RAW_VALUE is conventionally the last column.
        return parts[-1]
    return None

def _parse_smart_attr_row(out, attr_id):
    """
    Parse a smartctl -a attribute table row for a given attribute ID.

    Typical format:
      ID# ATTRIBUTE_NAME FLAG VALUE WORST THRESH TYPE UPDATED WHEN_FAILED RAW_VALUE
    RAW_VALUE may contain spaces (e.g. temperatures with Min/Max), so we capture the tail.
    """
    if not out:
        return None
    m = re.search(
        rf"(?m)^\s*{attr_id}\s+(\S+)\s+0x[0-9a-fA-F]+\s+(\d+)\s+(\d+)\s+(\d+)\s+\S+\s+\S+\s+\S+\s+(.+)$",
        str(out),
    )
    if not m:
        return None
    return {
        "id": int(attr_id),
        "name": m.group(1),
        "value": int(m.group(2)),
        "worst": int(m.group(3)),
        "thresh": int(m.group(4)),
        "raw": m.group(5).strip(),
    }

def _first_int_from_text(s):
    if s is None:
        return None
    m = re.search(r"([0-9][0-9,]*)", str(s))
    if not m:
        return None
    try:
        return int(m.group(1).replace(",", ""), 10)
    except ValueError:
        return None

def _parse_smart_error_log_count(out):
    if not out:
        return None
    lines = str(out).splitlines()
    for i, line in enumerate(lines):
        if "SMART Error Log" in line:
            # Fast-path: "No Errors Logged"
            for j in range(i, min(i + 40, len(lines))):
                if lines[j].strip() == "No Errors Logged":
                    return 0
            # Otherwise count "Error N occurred at" lines in the next chunk.
            cnt = 0
            for j in range(i, min(i + 300, len(lines))):
                if re.search(r"^\s*Error\s+[0-9]+\s+occurred\s+at\b", lines[j]):
                    cnt += 1
            return cnt
    return None

def _parse_smart_last_error_poh(out):
    """
    Parse the most recent ATA SMART Error Log entry's power-on lifetime (hours).

    smartctl typically formats the most recent entry as:
      "Error 667 occurred at disk power-on lifetime: 20140 hours (839 days + 4 hours)"
    Note: The error number is not necessarily "1" (it can be a running counter).

    Returns (error_number, power_on_hours) or (None, None) if not found / not an ATA SMART error log.
    """
    if not out:
        return (None, None)
    m = re.search(
        r"(?m)^\s*Error\s+([0-9]+)\s+occurred\s+at\s+disk\s+power-on\s+lifetime:\s*([0-9,]+)\s*(?:hours|h)\b",
        str(out),
    )
    if not m:
        return (None, None)
    try:
        n = int(m.group(1), 10)
        h = int(m.group(2).replace(",", ""), 10)
        return (n, h)
    except ValueError:
        return (None, None)

def _smartctl_looks_seagate(out):
    if not out:
        return False
    # Common smartctl identifiers for Seagate HDDs.
    if re.search(r"(?im)^Model Family:.*Seagate", out):
        return True
    if re.search(r"(?im)^(Device Model|Product):\s*Seagate", out):
        return True
    # Most Seagate HDDs report model starting with "ST".
    if re.search(r"(?im)^Device Model:\s*ST[0-9A-Z]", out):
        return True
    return False

def _decode_seagate_command_timeout(raw_val):
    """
    Seagate often packs SMART 188 into 6 bytes (3x 16-bit counters).

    smartctl prints the entire 48-bit value as a decimal integer, which can look huge.
    Decode it as:
      hi word:  >7.5s bucket (included in >5s)
      mid word: >5s bucket
      lo word:  total command timeouts
    """
    if raw_val is None:
        return None
    s = str(raw_val).strip().replace(",", "")
    if not s or not re.fullmatch(r"[0-9]+", s):
        return None
    try:
        v = int(s, 10)
    except ValueError:
        return None
    if v < 0 or v >= (1 << 48):
        return None
    hx = f"{v:012x}"  # 6 bytes
    hi = int(hx[0:4], 16)
    mid = int(hx[4:8], 16)
    lo = int(hx[8:12], 16)
    return {
        "raw_int": v,
        "hex": "0x" + hx,
        "timeouts": lo,
        "gt_5s": mid,
        "gt_7_5s": hi,
    }

def _decode_seagate_hi16_lo32(raw_val):
    """
    Common Seagate packing for some SMART RAW fields:
      RAW = (hi16_error_count << 32) | lo32_operation_count

    This is often seen for attribute 1 (Raw_Read_Error_Rate) and 7 (Seek_Error_Rate),
    where RAW is not "number of errors" in the intuitive sense.

    Returns dict with raw_int, hex, errors, ops; or None if not parseable.
    """
    if raw_val is None:
        return None
    s = str(raw_val).strip().replace(",", "")
    if not s or not re.fullmatch(r"[0-9]+", s):
        return None
    try:
        v = int(s, 10)
    except ValueError:
        return None
    if v < 0 or v >= (1 << 48):
        return None
    return {
        "raw_int": v,
        "hex": f"0x{v:012x}",
        "errors": (v >> 32) & 0xFFFF,
        "ops": v & 0xFFFFFFFF,
    }

def _parse_smart_long_selftest_failures(out):
    """
    Count non-success statuses in the SMART Self-test log for extended/long tests.
    Returns an int or None if the section isn't present.
    """
    if not out:
        return None
    lines = str(out).splitlines()
    start = None
    for i, line in enumerate(lines):
        if "SMART Self-test log" in line:
            start = i
            break
    if start is None:
        return None

    # Find the table header line with "#"
    header = None
    for i in range(start, min(start + 60, len(lines))):
        if lines[i].lstrip().startswith("#"):
            header = i
            break
        if "No self-tests have been logged" in lines[i]:
            return 0
    if header is None:
        # Section exists but we couldn't find the table.
        return None

    fail = 0
    for i in range(header + 1, min(header + 200, len(lines))):
        line = lines[i].strip()
        if not line:
            break
        if not line.startswith("#"):
            continue
        # Common format: "# 1  Extended offline  Completed without error  00%  1234  -"
        cols = line.split()
        if len(cols) < 4:
            continue
        desc = " ".join(cols[2:4])  # "Extended offline" or "Short offline"
        if "Extended offline" not in desc and "Long offline" not in desc:
            continue
        # Status begins after description; search the raw line for "Completed without error"
        if "Completed without error" in line:
            continue
        fail += 1
    return fail

def _find_tool_or_common_paths(tool_name, common_paths):
    """
    Find an executable by PATH, or fall back to common sbin locations.

    This avoids failures when running as a normal user with /usr/sbin not in PATH.
    Returns an absolute path or None.
    """
    p = shutil.which(tool_name)
    if p:
        return p
    for cp in common_paths:
        try:
            if cp and os.path.exists(cp) and os.access(cp, os.X_OK):
                return cp
        except Exception:
            continue
    return None

def _parse_ddrescue_failed_ranges(map_path, sector_size=512):
    """
    Return a list of failed ranges from a ddrescue mapfile.

    ddrescue map lines are typically: <start_hex> <size_hex> <status_char>
    We treat status '-' as "unrecovered".
    Ranges are returned as dicts with byte and sector offsets.
    """
    if not map_path or not os.path.exists(map_path):
        return []
    try:
        ss = int(sector_size)
        if ss <= 0:
            ss = 512
    except Exception:
        ss = 512

    out = []
    try:
        with open(map_path, 'r', encoding='utf-8', errors='replace') as f:
            for raw in f:
                line = raw.strip()
                if not line or line.startswith('#'):
                    continue
                parts = line.split()
                if len(parts) < 3:
                    continue
                a, b, st = parts[0], parts[1], parts[2]
                if not (a.startswith('0x') and b.startswith('0x') and st):
                    continue
                if st[0] != '-':
                    continue
                try:
                    start_b = int(a, 16)
                    size_b = int(b, 16)
                except ValueError:
                    continue
                if size_b <= 0:
                    continue
                end_b = start_b + size_b
                # Prefer reporting in sectors, but keep bytes if not aligned.
                start_lba = start_b // ss
                end_lba = (end_b + ss - 1) // ss  # ceil
                out.append({
                    "start_b": start_b,
                    "end_b": end_b,
                    "size_b": size_b,
                    "start_lba": start_lba,
                    "end_lba": end_lba,
                    "count_lba": max(0, end_lba - start_lba),
                })
    except Exception:
        return []
    return out

def _lsblk_type(dev_path):
    res = run_command(['lsblk', '-no', 'TYPE', dev_path], check=False)
    return (getattr(res, 'stdout', '') or '').strip()

def _lsblk_fstype(dev_path):
    res = run_command(['lsblk', '-no', 'FSTYPE', dev_path], check=False)
    return (getattr(res, 'stdout', '') or '').strip()

def _lsblk_partitions(dev_path):
    """
    Return a list of partitions under a disk device (NAME, FSTYPE).
    """
    res = run_command(['lsblk', '-nr', '-o', 'NAME,TYPE,FSTYPE', dev_path], check=False)
    rows = []
    for raw in (getattr(res, 'stdout', '') or '').splitlines():
        line = raw.strip()
        if not line:
            continue
        parts = line.split(None, 2)
        if len(parts) < 2:
            continue
        n, t = parts[0], parts[1]
        fs = parts[2].strip() if len(parts) >= 3 else ""
        if t == 'part':
            rows.append({"name": n, "fstype": fs})
    return rows

def get_script_dir():
    return Path(__file__).resolve().parent

def get_map_file_path():
    return get_script_dir() / MAP_FILENAME

def read_luks_map():
    map_file = get_map_file_path()
    if not map_file.exists():
        return {}
    
    mappings = {}
    with open(map_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            parts = line.split(None, 1) # Split on first whitespace
            if len(parts) == 2:
                name, path = parts
                mappings[name] = path
    return mappings

def save_luks_map(mappings):
    map_file = get_map_file_path()
    with open(map_file, 'w') as f:
        for name, path in mappings.items():
            f.write(f"{name}\t{path}\n")

def disk_base_name(dev_path):
    # Given /dev/sdb or /dev/sdb1 -> sdb
    try:
        dev_name = os.path.basename(dev_path)
        # simplistic, better to use lsblk
        res = run_command(['lsblk', '-no', 'PKNAME', dev_path], check=False)
        if res.stdout.strip():
            return res.stdout.strip()
        return dev_name
    except:
        return os.path.basename(dev_path)

def disk_is_nvme(dev_path):
    # Check if NVMe
    try:
        res = run_command(['lsblk', '-dno', 'TRAN', dev_path], check=False)
        if res.stdout.strip() == 'nvme':
            return True
        if 'nvme' in dev_path:
            return True
    except:
        pass
    return False

def disk_is_rotational(dev_path):
    try:
        base = disk_base_name(dev_path)
        p = Path(f"/sys/block/{base}/queue/rotational")
        if p.exists():
            return p.read_text().strip() == "1"
    except:
        pass
    return False

def disk_discard_supported(dev_path):
    try:
        res = run_command(['lsblk', '-dno', 'DISC-MAX', dev_path], check=False)
        val = res.stdout.strip()
        return val and val != "0B" and val != "0"
    except:
        return False

def secure_erase_disk(dev_path):
    if not os.path.exists(dev_path):
        log(f"Device not found: {dev_path}", 'ERROR')
        return False

    # Detect if partition or disk
    is_part = False
    try:
        res = run_command(['lsblk', '-dno', 'TYPE', dev_path], capture_output=True)
        if res.stdout.strip() == 'part':
            is_part = True
    except:
        pass

    target_type = "PARTITION" if is_part else "FULL DISK"
    log(f"Starting secure erase on {dev_path} ({target_type})")

    if disk_is_nvme(dev_path):
        if is_part:
            log("NVMe hardware-level erase (Sanitize/Format) skipped: Target is a partition, not a full disk.", 'WARN')
        else:
            # Query capabilities
            try:
                res = run_command(['nvme', 'id-ctrl', '-o', 'json', dev_path], sudo=True, capture_output=True)
                ctrl_data = json.loads(res.stdout)
                oacs = ctrl_data.get('oacs', 0)
                sanicap = ctrl_data.get('sanicap', 0)
                fna = ctrl_data.get('fna', 0)
                
                can_format = bool(oacs & 0x02)
                can_format_block = can_format # Baseline if Format is supported
                can_format_crypto = can_format and bool(fna & 0x04)
                can_sanitize_block = bool(sanicap & 0x02)
                can_sanitize_crypto = bool(sanicap & 0x01)
                
                # 1. Sanitize Crypto Erase (Priority 1)
                if can_sanitize_crypto:
                    log(f"Attempting NVMe Sanitize Crypto Erase (Action 4) on {dev_path}...")
                    try:
                        run_command(['nvme', 'sanitize', dev_path, '-a', '4'], sudo=True)
                        run_command(['udevadm', 'settle'], sudo=True)
                        log("NVMe Sanitize Crypto Erase completed successfully.")
                        return True
                    except Exception as e:
                        log(f"NVMe Sanitize Crypto Erase failed: {e}. Falling back...", 'WARN')

                # 2. Sanitize Block Erase (Priority 2)
                if can_sanitize_block:
                    log(f"Attempting NVMe Sanitize Block Erase (Action 2) on {dev_path}...")
                    try:
                        run_command(['nvme', 'sanitize', dev_path, '-a', '2'], sudo=True)
                        run_command(['udevadm', 'settle'], sudo=True)
                        log("NVMe Sanitize Block Erase completed successfully.")
                        return True
                    except Exception as e:
                        log(f"NVMe Sanitize Block Erase failed: {e}. Falling back...", 'WARN')

                # 3. Format Crypto Erase (Priority 3)
                if can_format_crypto:
                    log(f"Attempting NVMe Format Crypto Erase (SES 2) on {dev_path}...")
                    try:
                        run_command(['nvme', 'format', dev_path, '--ses=2'], sudo=True)
                        run_command(['udevadm', 'settle'], sudo=True)
                        log("NVMe Format Crypto Erase completed successfully.")
                        return True
                    except Exception as e:
                        log(f"NVMe Format Crypto Erase failed: {e}. Falling back...", 'WARN')

                # 4. Format Block Erase (Last NVMe Fallback)
                if can_format_block:
                    log(f"Attempting NVMe Format Block Erase (SES 1) on {dev_path}...")
                    try:
                        run_command(['nvme', 'format', dev_path, '--ses=1'], sudo=True)
                        run_command(['udevadm', 'settle'], sudo=True)
                        log("NVMe Format Block Erase completed successfully.")
                        return True
                    except Exception as e:
                        log(f"NVMe Format Block Erase failed: {e}. Falling back...", 'WARN')
                
                log("No supported NVMe hardware erase methods found. Falling back to software discard/overwrite.")

            except Exception as e:
                log(f"Failed to query NVMe capabilities: {e}. Falling back to software methods.", 'WARN')

    elif not disk_is_rotational(dev_path):
        # SSD/Flash (SATA/SAS)
        if is_part:
            log("SATA SSD hardware-level erase (ATA Sanitize/Secure Erase) skipped: Target is a partition.", 'WARN')
        else:
            # 1. PSID Revert / TCG Opal (Placeholder)
            log(f"Checking for PSID Revert / TCG Opal support (Currently Unimplemented)...")

            # 2. ATA Sanitize
            try:
                res = run_command(['hdparm', '-I', dev_path], sudo=True, capture_output=True)
                if "sanitize" in res.stdout.lower():
                     log(f"Attempting ATA Sanitize Block Erase on {dev_path}...")
                     try:
                         run_command(['hdparm', '--sanitize-block-erase', dev_path], sudo=True)
                         log("ATA Sanitize Block Erase completed successfully.")
                         return True
                     except Exception as e:
                         log(f"ATA Sanitize failed: {e}. Falling back...", 'WARN')
            except:
                pass

            # 3. ATA Secure Erase (Enhanced & Standard)
            try:
                res = run_command(['hdparm', '-I', dev_path], sudo=True, capture_output=True)
                if "supported" in res.stdout.lower() and "security:" in res.stdout.lower():
                    if "frozen" in res.stdout.lower():
                        log("ATA Secure Erase is FROZEN by BIOS/EFI. Skipping...", 'WARN')
                    else:
                        log("ATA Secure Erase supported. Setting temporary password 'diskmgr'...")
                        try:
                            pw = "diskmgr"
                            run_command(['hdparm', '--user-master', 'u', '--security-set-pass', pw, dev_path], sudo=True)
                            
                            # Enhanced
                            if "enhanced" in res.stdout.lower():
                                log(f"Attempting ATA Secure Erase (Enhanced) on {dev_path}...")
                                try:
                                    run_command(['hdparm', '--user-master', 'u', '--security-erase-enhanced', pw, dev_path], sudo=True)
                                    log("ATA Secure Erase (Enhanced) completed successfully.")
                                    return True
                                except Exception as e:
                                    log(f"ATA Secure Erase (Enhanced) failed: {e}. Falling back...", 'WARN')

                            # Standard
                            log(f"Attempting ATA Secure Erase (Standard) on {dev_path}...")
                            try:
                                run_command(['hdparm', '--user-master', 'u', '--security-erase', pw, dev_path], sudo=True)
                                log("ATA Secure Erase (Standard) completed successfully.")
                                return True
                            except Exception as e:
                                log(f"ATA Secure Erase (Standard) failed: {e}. Falling back...", 'WARN')
                        except Exception as e:
                            log(f"Failed to set security password: {e}. Falling back...", 'WARN')
            except:
                pass

    if disk_is_rotational(dev_path):
        if not is_part:
            # Try ATA methods for HDD too
            try:
                res = run_command(['hdparm', '-I', dev_path], sudo=True, capture_output=True)
                if "sanitize" in res.stdout.lower():
                     log(f"Attempting ATA Sanitize on HDD {dev_path}...")
                     try:
                         run_command(['hdparm', '--sanitize-block-erase', dev_path], sudo=True)
                         log("HDD ATA Sanitize completed successfully.")
                         return True
                     except Exception as e:
                         log(f"HDD ATA Sanitize failed: {e}. Falling back...", 'WARN')
                
                if "supported" in res.stdout.lower() and "security:" in res.stdout.lower() and "frozen" not in res.stdout.lower():
                    log(f"Attempting ATA Secure Erase on HDD {dev_path}...")
                    try:
                        pw = "diskmgr"
                        run_command(['hdparm', '--user-master', 'u', '--security-set-pass', pw, dev_path], sudo=True)
                        erase_cmd = '--security-erase-enhanced' if "enhanced" in res.stdout.lower() else '--security-erase'
                        run_command(['hdparm', '--user-master', 'u', erase_cmd, pw, dev_path], sudo=True)
                        log("HDD ATA Secure Erase completed successfully.")
                        return True
                    except Exception as e:
                        log(f"HDD ATA Secure Erase failed: {e}. Falling back...", 'WARN')
            except:
                pass

        # Final HDD Fallback
        log(f"Performing software zero-overwrite (dd) on {dev_path}...")
        try:
            run_command(['dd', 'if=/dev/zero', f'of={dev_path}', 'bs=16M', 'status=progress', 'oflag=direct'], sudo=True, capture_output=False)
            run_command(['sync'], sudo=True)
            log("Zero overwrite completed. Verifying first 1MB...")
            res_v = run_command(['dd', f'if={dev_path}', 'bs=1M', 'count=1'], sudo=True, capture_output=True)
            if any(b != 0 for b in res_v.stdout.encode('latin1') if isinstance(b, int)):
                 log("Verification failed: First 1MB is not zeroed.", 'ERROR')
                 return False
            log("Verification successful.")
            return True
        except Exception as e:
            log(f"Software overwrite failed: {e}", 'ERROR')
            return False

    # SSD Software Fallbacks
    log(f"Attempting blkdiscard --secure on {dev_path}...")
    try:
        run_command(['blkdiscard', '--secure', dev_path], sudo=True)
        run_command(['udevadm', 'settle'], sudo=True)
        log("blkdiscard --secure completed successfully.")
        return True
    except Exception as e:
        log(f"blkdiscard --secure not supported or failed: {e}. Falling back...", 'WARN')

    log(f"Attempting standard blkdiscard on {dev_path}...")
    if disk_discard_supported(dev_path):
        try:
            run_command(['blkdiscard', dev_path], sudo=True)
            run_command(['udevadm', 'settle'], sudo=True)
            log("Standard blkdiscard completed successfully.")
            return True
        except Exception as e:
            log(f"Standard blkdiscard failed: {e}", 'ERROR')
            return False
    else:
        log("Discard not supported on this device. Final software overwrite attempted.", 'WARN')
        try:
            run_command(['dd', 'if=/dev/zero', f'of={dev_path}', 'bs=16M', 'status=progress', 'oflag=direct'], sudo=True, capture_output=False)
            return True
        except:
            return False

class CmdArgumentParser(argparse.ArgumentParser):
    def error(self, message):
        raise argparse.ArgumentError(None, message)

class DiskMgrShell(cmd.Cmd):
    intro = 'Welcome to diskmgr. Type help or ? to list commands.\n'
    prompt = f'{Colors.OKGREEN}(diskmgr) {Colors.ENDC}'
    
    def __init__(self):
        super().__init__()
        self.mappings = read_luks_map()
        self.unmapped_cache = []

    def get_disk_info(self):
        # Use lsblk -J for JSON output
        cmd = ['lsblk', '-J', '-e', '7', '-o', 'NAME,KNAME,TYPE,RM,SIZE,FSTYPE,LABEL,MOUNTPOINT,MODEL,WWN,PKNAME,TRAN,DISC-MAX']
        try:
            res = run_command(cmd, capture_output=True)
            data = json.loads(res.stdout)
            return data.get('blockdevices', [])
        except Exception as e:
            log(f"Failed to list disks: {e}", 'ERROR')
            return []

    def flatten_disks(self, devices):
        """Recursively flatten the lsblk tree structure."""
        flat = []
        for dev in devices:
            flat.append(dev)
            if 'children' in dev:
                flat.extend(self.flatten_disks(dev['children']))
        return flat

    def find_persistent_path(self, dev_node, wwn=None, type_='disk'):
        # Try to find /dev/disk/by-id/ match
        
        # 1. Try WWN logic from opendisk
        if wwn:
            prefix = "nvme-" if wwn.startswith("eui.") else "wwn-"
            path = f"/dev/disk/by-id/{prefix}{wwn}"
            try:
                if os.path.realpath(path) == os.path.realpath(f"/dev/{dev_node}"):
                    return path
            except:
                pass

        # 2. Brute force check /dev/disk/by-id
        by_id_dir = Path('/dev/disk/by-id')
        if by_id_dir.exists():
            for link in by_id_dir.iterdir():
                try:
                    if link.resolve() == Path(f"/dev/{dev_node}").resolve():
                        return str(link)
                except:
                    continue
        
        return "-"

    def do_help(self, arg):
        'List available commands with "help" or detailed help with "help cmd".'
        if arg:
            super().do_help(arg)
            return

        print(f"\n{Colors.HEADER}Disk Manager (diskmgr){Colors.ENDC}")
        print("A utility designed to simplify the management of encrypted and plain removable media.")
        print("It maps friendly labels to hardware-specific Persistent Device Paths (PDP), ensuring")
        print("that disks are recognized reliably even if device nodes change.\n")
        
        print(f"{Colors.BOLD}COMMANDS:{Colors.ENDC}")
        print(f"  {Colors.OKGREEN}list{Colors.ENDC}")
        print("      Shows all configured mappings and unmapped system disks in one table.")

        print(f"  {Colors.OKGREEN}layout{Colors.ENDC}")
        print("      Displays the physical partition layout and free space for all disks.")

        print(f"  {Colors.OKGREEN}boot{Colors.ENDC}")
        print("      Displays all boot entries and submenus from GRUB.")
        
        print(f"  {Colors.OKGREEN}map <id/name> <name>{Colors.ENDC}")
        print("      Assigns a friendly name to a disk or renames an existing mapping.")

        print(f"  {Colors.OKGREEN}unmap <name>{Colors.ENDC}")
        print("      Removes an existing mapping from the configuration.")
        
        print(f"  {Colors.OKGREEN}open <name>{Colors.ENDC}")
        print("      Unlocks LUKS (if encrypted) and mounts the disk.")
        print("      Mounts to /media/$USER/<label> (prefers label over mapping name).")
        
        print(f"  {Colors.OKGREEN}close <name>{Colors.ENDC}")
        print("      Unmounts and closes the disk.")

        print(f"  {Colors.OKGREEN}label <name> [new_label]{Colors.ENDC}")
        print("      Get or set the filesystem label of an OPEN disk.")

        print(f"  {Colors.OKGREEN}remount <name>{Colors.ENDC}")
        print("      Move an OPEN disk's mount to /media/$USER/<label> (and clean up old mountpoint dirs).")

        print(f"  {Colors.OKGREEN}luks <passwd|backup|restore>{Colors.ENDC}")
        print("      LUKS management: change password, backup/restore headers.")
        
        print(f"  {Colors.OKGREEN}create <name> [options]{Colors.ENDC}")
        print("      Initializes a new disk (Erase -> LUKS -> Format -> Mount).")

        print(f"  {Colors.OKGREEN}erase <name>{Colors.ENDC}")
        print("      Securely erases a disk (multi-step hardware-aware wipe).")

        print(f"  {Colors.OKGREEN}clone <src_name> <dst_name>{Colors.ENDC}")
        print("      Clones one disk to another (requires target >= source size).")

        print(f"  {Colors.OKGREEN}sync <sec_name> <pri_name>{Colors.ENDC}")
        print("      Syncs two mounted disks (rsync pri -> sec).")

        print(f"  {Colors.OKGREEN}defrag <name>{Colors.ENDC}")
        print("      Defragments a mounted filesystem and records the timestamp in xattrs (user.last_defrag).")

        print(f"  {Colors.OKGREEN}fsdiag <name>{Colors.ENDC}")
        print("      Shows filesystem diagnostics, last_defrag xattr, and (ext4 only) a fragmentation score.")

        print(f"  {Colors.OKGREEN}health <name>{Colors.ENDC}")
        print("      Shows SMART health (smartctl -a) for the underlying disk (USB uses -d sat).")

        print(f"  {Colors.OKGREEN}scrub <name>{Colors.ENDC}")
        print("      Runs a blocking btrfs scrub on a mounted filesystem and records user.last_scrub in xattrs.")

        print(f"  {Colors.OKGREEN}selftest <name>{Colors.ENDC}")
        print("      Starts a SMART long self-test (smartctl -t long) for the underlying disk (USB uses -d sat).")


        print(f"  {Colors.OKGREEN}exit / quit / Ctrl+D{Colors.ENDC}")
        print("      Exit the application.")

        print("\nType 'help <command>' for more specific details.")

    def do_exit(self, arg):
        'Exit the application'
        return True

    def do_quit(self, arg):
        'Exit the application'
        return True

    def do_EOF(self, arg):
        'Exit the application'
        print("")
        return True

    def do_layout(self, arg):
        '''Display the physical partition layout and free space for all plugged-in disks.
        
        UNDER THE HOOD:
        1.  Hardware Scan: Identifies all physical 'disk' devices (excluding partitions).
        2.  Geometry Query: Runs 'sudo parted -m <dev> unit s print free' and 'blockdev --getsz'.
        3.  Parsing: 
            - Extracts Partition Table type (gpt/mbr) and sector sizes.
            - Calculates total logical sectors from blockdev output.
        4.  Formatting:
            - Adds GPT metadata blocks (Primary/Backup) if applicable.
            - Identifies 'free' space segments.
            - Calculates MiB and GiB values from sector counts.
        '''
        all_devs = self.get_disk_info()
        disks = [d for d in all_devs if d.get('type') == 'disk']
        
        if not disks:
            log("No physical disks found.", 'WARN')
            return

        for disk in disks:
            d_name = disk['name']
            dev_path = f"/dev/{d_name}"
            model = disk.get('model', 'Unknown')
            
            try:
                # 1. Get Geometry from parted
                res = run_command(['parted', '-m', '-s', dev_path, 'unit', 's', 'print', 'free'], sudo=True, check=False)
                if getattr(res, 'returncode', 1) != 0:
                    # Common case: blank disk or missing/corrupt partition table.
                    # Avoid noisy "Command failed" logs and present a human-readable reason.
                    stderr = (getattr(res, 'stderr', '') or '').strip()

                    # Fall back to blockdev sector sizes for a useful header.
                    ls = run_command(['blockdev', '--getss', dev_path], sudo=True, check=False).stdout.strip()
                    ps = run_command(['blockdev', '--getpbsz', dev_path], sudo=True, check=False).stdout.strip()
                    logical_sector = int(ls) if ls.isdigit() else 512
                    physical_sector = int(ps) if ps.isdigit() else logical_sector

                    res_sz = run_command(['blockdev', '--getsz', dev_path], sudo=True, check=False)
                    total_512_sectors = int(res_sz.stdout.strip()) if (res_sz.stdout or "").strip().isdigit() else 0
                    total_logical_sectors = (total_512_sectors * 512) // logical_sector if logical_sector else 0

                    print(f"\n{Colors.BOLD}Disk: {dev_path} ({model}) [none] [Sector: L{logical_sector}/P{physical_sector}] [Total Sectors: {total_logical_sectors}]{Colors.ENDC}")
                    if stderr:
                        if "unrecognised disk label" in stderr.lower():
                            log(f"{dev_path}: no partition table (unrecognized disk label).", 'WARN')
                        else:
                            log(f"{dev_path}: could not read partition layout: {stderr}", 'WARN')

                    # Still show lsblk hierarchy so the user can see what's on the disk.
                    print("")
                    try:
                        ls_res = run_command(['lsblk', '-J', '-f', dev_path], sudo=True, check=False)
                        if ls_res.stdout.strip():
                            data = json.loads(ls_res.stdout)
                            if 'blockdevices' in data:
                                print(f"{Colors.BOLD}{'NAME':<25} {'FSTYPE':<12} {'FSVER':<6} {'LABEL':<12} {'UUID':<38} {'FSAVAIL':<10} {'FSUSE%':<8} {'MOUNTPOINTS'}{Colors.ENDC}")
                                self.render_lsblk_json(data['blockdevices'])
                    except Exception as e:
                        log(f"Could not render lsblk tree: {e}", 'DEBUG')
                    print("-" * 155)
                    continue

                lines = res.stdout.strip().splitlines()
                
                header_parts = lines[1].strip(';').split(':')
                logical_sector = int(header_parts[3])
                physical_sector = int(header_parts[4])
                ptable = header_parts[5]
                
                # 2. Get Total Size from blockdev (always in 512b units)
                res_sz = run_command(['blockdev', '--getsz', dev_path], sudo=True)
                total_512_sectors = int(res_sz.stdout.strip())
                total_logical_sectors = (total_512_sectors * 512) // logical_sector

                print(f"\n{Colors.BOLD}Disk: {dev_path} ({model}) [{ptable}] [Sector: L{logical_sector}/P{physical_sector}] [Total Sectors: {total_logical_sectors}]{Colors.ENDC}")

                # 4. Parse Data Lines from parted for visual blocks
                data_lines = [l for l in lines if l and not l.startswith('BYT') and not l.startswith('/')]
                
                segments = []
                
                # Dynamic Initial Overhead Detection
                if data_lines:
                    first_line_parts = data_lines[0].strip(';').split(':')
                    first_start = int(first_line_parts[1].strip('s'))
                    if first_start > 0:
                        overhead_size = first_start
                        overhead_bytes = overhead_size * logical_sector
                        
                        label = "Overhead"
                        if ptable == 'gpt': label = "GPT Primary"
                        elif ptable in ['msdos', 'mbr']: label = "MBR"
                        
                        segments.append(f"{Colors.FAIL}[ {label} {overhead_size}s ({overhead_bytes:.2f}B) ]{Colors.ENDC}")

                for line in data_lines:
                    parts = line.strip(';').split(':')
                    if len(parts) < 4: continue
                    
                    num = parts[0]
                    size_sectors = int(parts[3].strip('s'))
                    fs_or_type = parts[4] if len(parts) > 4 else ""
                    
                    size_bytes = size_sectors * logical_sector
                    # Use B, KiB, MiB, GiB based on size
                    if size_bytes < 1024:
                        size_info = f"{size_bytes:.2f}B"
                    elif size_bytes < 1024**2:
                        size_info = f"{size_bytes/1024:.2f}KiB"
                    elif size_bytes < 1024**3:
                        size_info = f"{size_bytes/(1024**2):.2f}MiB"
                    else:
                        size_info = f"{size_bytes/(1024**2):.2f}MiB ≈ {size_bytes/(1024**3):.1f}GiB"

                    if fs_or_type == 'free' or (not fs_or_type and len(parts) == 5):
                        segments.append(f"{Colors.OKCYAN}[ free {size_sectors}s ({size_info}) ]{Colors.ENDC}")
                    else:
                        flags = parts[6] if len(parts) > 6 else ""
                        kname = f"{d_name}{num}"
                        if 'nvme' in d_name and not kname.startswith(f"{d_name}p"):
                            kname = f"{d_name}p{num}"
                        
                        dtype = fs_or_type if fs_or_type else "-"
                        flag_info = f" ({flags})" if flags else ""
                        segments.append(f"{Colors.OKGREEN}[ {kname} {dtype} {size_sectors}s ({size_info}){flag_info} ]{Colors.ENDC}")
                
                # GPT Backup Overhead
                if data_lines:
                    last_line_parts = data_lines[-1].strip(';').split(':')
                    last_end = int(last_line_parts[2].strip('s'))
                    if last_end < total_logical_sectors - 1:
                        overhead_size = total_logical_sectors - 1 - last_end
                        overhead_bytes = overhead_size * logical_sector
                        l_label = "Overhead"
                        if ptable == 'gpt': l_label = "GPT Backup"
                        segments.append(f"{Colors.FAIL}[ {l_label} {overhead_size}s ({overhead_bytes:.2f}B) ]{Colors.ENDC}")

                print(" ".join(segments))

                # 4. Print lsblk hierarchy at the bottom
                print("")
                try:
                    # Use JSON output for absolute reliability in data capture
                    ls_res = run_command(['lsblk', '-J', '-f', dev_path], sudo=True, check=False)
                    if ls_res.stdout.strip():
                        data = json.loads(ls_res.stdout)
                        if 'blockdevices' in data:
                            print(f"{Colors.BOLD}{'NAME':<25} {'FSTYPE':<12} {'FSVER':<6} {'LABEL':<12} {'UUID':<38} {'FSAVAIL':<10} {'FSUSE%':<8} {'MOUNTPOINTS'}{Colors.ENDC}")
                            self.render_lsblk_json(data['blockdevices'])
                except Exception as e:
                    log(f"Could not render lsblk tree: {e}", 'DEBUG')
                print("-" * 155)
            except Exception as e:
                print(f"\n{Colors.BOLD}Disk: {dev_path} ({model}){Colors.ENDC}")
                log(f"Could not read layout for {dev_path}: {e}", 'WARN')
        print("")

    def render_lsblk_json(self, devices, indent="", is_root=True):
        for i, dev in enumerate(devices):
            is_last = (i == len(devices) - 1)
            
            name = dev.get('name', '')
            fstype = dev.get('fstype') or ""
            fsver = dev.get('fsver') or ""
            label = dev.get('label') or ""
            uuid = dev.get('uuid') or ""
            fsavail = dev.get('fsavail') or ""
            fsuse = dev.get('fsuse%') or ""
            mounts = ", ".join([m for m in dev.get('mountpoints', []) if m])

            # Tree characters
            if is_root:
                tree_part = name
                next_indent = ""
            else:
                char = "└─" if is_last else "├─"
                tree_part = indent + char + name
                next_indent = indent + ("    " if is_last else "│   ")

            # Print row
            # NAME(25) FSTYPE(12) FSVER(6) LABEL(12) UUID(38) FSAVAIL(10) FSUSE(8) MOUNTPOINTS
            print(f"{tree_part:<25} {fstype:<12} {fsver:<6} {label:<12} {uuid:<38} {fsavail:<10} {fsuse:<8} {mounts}".rstrip())
            
            if 'children' in dev:
                self.render_lsblk_json(dev['children'], next_indent, is_root=False)

    def resolve_uuid_to_dev(self, uuid):
        '''Resolves a UUID to a short device name like sda1 or nvme0n1p1.'''
        uuid = uuid.strip()
        if not uuid or uuid == "(firmware)":
            return ""
        try:
            # Use check=False to avoid noisy logs if UUID doesn't resolve
            res = run_command(['blkid', '-U', uuid], sudo=True, capture_output=True, check=False)
            path = res.stdout.strip()
            if path:
                return os.path.basename(path)
        except:
            pass
        return ""

    def do_boot(self, arg):
        '''Display boot entries from the GRUB configuration of all disks.
        
        UNDER THE HOOD:
        Scans all block devices. If mounted, it parses /boot/grub/grub.cfg.
        If unmounted or encrypted, it explains why it cannot yet read the config.
        '''
        all_devs = self.get_disk_info()
        flat_disks = self.flatten_disks(all_devs)
        
        # AWK script parses Title <TAB> Entry <TAB> SEARCH <TAB> ROOT
        awk_script = r"""
  /search[[:space:]].*--fs-uuid/ {g_search=$NF}

  /^[[:space:]]*submenu / {
    submenu_title=$2
    next
  }

  /^[[:space:]]*menuentry / {
    e=$2; search_u=""; root_u=""; in_entry=1
    next
  }

  in_entry && search_u=="" && /search[[:space:]].*--fs-uuid/ {search_u=$NF}
  in_entry && root_u=="" && /(linux|linuxefi)[[:space:]].*root=UUID=/ {
    match($0,/root=UUID=[0-9a-fA-F-]+/)
    if (RSTART) root_u=substr($0,RSTART+10,RLENGTH-10)
  }

  in_entry && /^[[:space:]]*}/ {
    if (submenu_title=="") submenu_title="Top-level"
    s = (search_u!="" ? search_u : g_search)
    r = (root_u!=""   ? root_u   : "-")
    if (e ~ /UEFI Firmware Settings/) { s="(firmware)"; r="(firmware)" }
    
    print submenu_title "\t" e "\t" s "\t" r
    in_entry=0
  }
"""
        processed_devs = set()

        print(f"\n{Colors.HEADER}{Colors.BOLD}--- System Boot Configuration Scan ---{Colors.ENDC}")

        for dev in flat_disks:
            d_name = dev.get('name')
            d_kname = dev.get('kname', d_name)
            d_path = f"/dev/{d_kname}"
            d_type = dev.get('type')
            fstype = dev.get('fstype')
            mountpoint = dev.get('mountpoint')

            if d_type == 'loop' or (d_type == 'disk' and 'children' in dev):
                continue
            
            if d_path in processed_devs:
                continue
            processed_devs.add(d_path)

            print(f"\n{Colors.OKBLUE}Device: {d_path} ({fstype or 'unknown FS'}){Colors.ENDC}")

            if fstype == 'crypto_LUKS':
                print(f"  {Colors.WARNING}Result: LUKS container is LOCKED. Please 'open' this disk to scan for boot entries.{Colors.ENDC}")
            elif not mountpoint:
                if fstype and fstype != '-':
                    print(f"  {Colors.WARNING}Result: Disk is UNMOUNTED. Please 'open' or mount the disk to scan for boot entries.{Colors.ENDC}")
                else:
                    print(f"  {Colors.WARNING}Result: No recognizable filesystem found.{Colors.ENDC}")
            else:
                cfg_path = Path(mountpoint) / "boot/grub/grub.cfg"
                display_path = str(cfg_path).replace("//", "/")
                try:
                    if cfg_path.exists():
                        print(f"  {Colors.OKGREEN}Result: Found GRUB config at {display_path}{Colors.ENDC}")
                        cmd = ['sudo', 'awk', '-F', "'", awk_script, str(cfg_path)]
                        res = run_command(cmd, capture_output=True)
                        
                        if res.stdout.strip():
                            entries = {}
                            for line in res.stdout.strip().splitlines():
                                if '\t' in line:
                                    parts = [x.strip() for x in line.split('\t')]
                                    if len(parts) == 4:
                                        sub, title, s_uuid, r_uuid = parts
                                        if sub not in entries: entries[sub] = []
                                        entries[sub].append((title, s_uuid, r_uuid))
                            
                            for sub, items in entries.items():
                                print(f"\n{sub}")
                                for i, (title, s_uuid, r_uuid) in enumerate(items):
                                    connector = "  └─" if i == len(items) - 1 else "  ├─"
                                    
                                    s_dev = self.resolve_uuid_to_dev(s_uuid)
                                    r_dev = self.resolve_uuid_to_dev(r_uuid)
                                    
                                    s_info = f"SEARCH={s_uuid:<36} [{s_dev if s_dev else '-'}]"
                                    r_info = f"ROOT={r_uuid:<36} [{r_dev if r_dev else '-'}]"
                                    
                                    print(f"{connector} {title:<72}  {Colors.OKCYAN}{s_info}  {r_info}{Colors.ENDC}")
                        else:
                            print("  (No menu entries found in config)")
                    else:
                        print(f"  {Colors.OKCYAN}Result: Mounted at {mountpoint}, but no GRUB configuration found.{Colors.ENDC}")
                except PermissionError:
                    print(f"  {Colors.FAIL}Result: Permission denied scanning {mountpoint} (System protected path).{Colors.ENDC}")
                except Exception as e:
                    print(f"  {Colors.FAIL}Result: Error checking path: {e}{Colors.ENDC}")
            
            print("-" * 60)

    def do_list(self, arg):
        '''List all configured mappings and available system disks in a single table.
        
        UNDER THE HOOD:
        1.  Resolution: Refreshes mappings from diskmap.tsv.
        2.  Hardware Discovery: Uses 'lsblk' to gather hardware properties and identifies 
            underlying physical partitions even when opened as virtual devices.
        3.  Zero-Sudo LUKS Detection: Queries the system 'udev' database via 'udevadm info' 
            to accurately identify encrypted disks without requiring root privileges.
        4.  Status Logic:
            - MISSING: Persistent path not found in /dev.
            - CLOSED: Present but locked (LUKS) or unmounted (Plain).
            - OPEN: Unlocked/Decrypted but not yet mounted.
            - MOUNTED: Active filesystem attached to the preferred path (/media/$USER/name).
        5.  Dynamic Formatting: Pre-calculates the maximum width of every column across 
            all rows for a perfectly aligned, readable table.
        6.  Exclusion Logic: Rigorously filters out virtual mapper devices and their 
            kernel aliases (dm-X) from the unmapped list once they are active.
        '''
        self.mappings = read_luks_map()
        mapped_rows = []
        unmapped_rows = []
        
        # 1. Collect Mapped Disks
        mapped_real_paths = set()
        mapped_names = set()
        i = 1
        for name, path in self.mappings.items():
            phys_device = "-"
            dm_device = ""
            fstype = "-"
            size = "-"
            label = "-"
            mountpoint = f"/media/{os.environ.get('USER', 'root')}/{name}"
            is_luks = "-"
            state = "MISSING"
            
            mapped_names.add(name)
            
            # Default mountpoint based on name
            mount_name = name

            if os.path.exists(path):
                real_path = os.path.realpath(path)
                mapped_real_paths.add(real_path)
                state = "CLOSED"
                is_luks = "N"
                
                # Get Physical Device Properties
                try:
                    cmd_p = ['lsblk', '-n', '-P', '-o', 'KNAME,PKNAME,FSTYPE,SIZE,LABEL', real_path]
                    res_p = run_command(cmd_p, check=False)
                    if res_p.stdout.strip():
                        props = {}
                        for part in shlex.split(res_p.stdout.strip()):
                            if '=' in part:
                                k, v = part.split('=', 1)
                                props[k] = v
                        
                        phys_device = props.get('KNAME', '-')
                        # If the 'physical' device is actually a DM device, try to get its parent
                        if phys_device.startswith('dm-'):
                            parent = props.get('PKNAME', '')
                            if parent: phys_device = parent

                        fstype = props.get('FSTYPE', '-')
                        size = props.get('SIZE', '-')
                        label = props.get('LABEL', '-')
                        
                        # Fallback to blkid for more reliable label (lsblk is often stale)
                        try:
                            res_b = run_command(['blkid', '-o', 'value', '-s', 'LABEL', real_path], sudo=True, check=False)
                            if res_b.stdout.strip():
                                label = res_b.stdout.strip()
                        except:
                            pass
                        
                        if label and label != '-':
                            mount_name = label

                        # Check LUKS status using udev (No sudo required)
                        res_u = run_command(['udevadm', 'info', '--query=property', f'--name={real_path}'], check=False)
                        if 'ID_FS_TYPE=crypto_LUKS' in res_u.stdout:
                            is_luks = "Y"
                        elif fstype == 'crypto_LUKS':
                            is_luks = "Y"
                except:
                    pass

            mountpoint = f"/media/{os.environ.get('USER', 'root')}/{mount_name}"

            mapper_path = f"/dev/mapper/{name}"
            target_to_mount = mapper_path

            if is_luks == "Y" and os.path.exists(mapper_path):
                mapped_real_paths.add(os.path.realpath(mapper_path))
                mapped_real_paths.add(mapper_path)
                mapped_names.add(name) # Hide '1a'
                
                state = "OPEN"
                try:
                    cmd_m = ['lsblk', '-n', '-P', '-o', 'KNAME,PKNAME,FSTYPE,LABEL,SIZE', mapper_path]
                    res_m = run_command(cmd_m, check=False)
                    if res_m.stdout.strip():
                        props = {}
                        for part in shlex.split(res_m.stdout.strip()):
                            if '=' in part:
                                k, v = part.split('=', 1)
                                props[k] = v
                        # Get mapper kernel name (e.g. dm-0)
                        dm_device = props.get('KNAME', '')
                        if dm_device: mapped_names.add(dm_device)
                        
                        # Also hide the physical parent of the DM device
                        dm_parent = props.get('PKNAME', '')
                        if dm_parent: 
                            mapped_names.add(dm_parent)
                            if phys_device == '-': phys_device = dm_parent
                        
                        # Use mapper properties for FS details
                        if props.get('FSTYPE'): fstype = props.get('FSTYPE')
                        if props.get('LABEL'): 
                            label = props.get('LABEL')
                            if label and label != '-':
                                mountpoint = f"/media/{os.environ.get('USER', 'root')}/{label}"
                        if props.get('SIZE'): size = props.get('SIZE')
                except:
                    pass
                
                targets = find_mount_targets(mapper_path)
                if targets:
                    mountpoint = ", ".join(targets)
                    state = "MOUNTED"
            elif is_luks == "N" and state != "MISSING":
                 targets = find_mount_targets(path)
                 if targets:
                     mountpoint = ", ".join(targets)
                     state = "MOUNTED"

            # Only show mountpoint if actually MOUNTED
            if state != "MOUNTED":
                mountpoint = "-"

            display_dev = phys_device
            if dm_device and dm_device != phys_device:
                display_dev = f"{phys_device}({dm_device})"

            mapped_rows.append({
                'idx': f"[{i}]", 'name': name, 'luks': is_luks, 'state': state, 
                'fstype': fstype, 'label': label if label else "-", 'mount': mountpoint, 
                'dev': display_dev, 'size': size, 'path': path
            })
            i += 1

        # 2. Collect Unmapped Disks
        all_disks = self.get_disk_info()
        flat_disks = self.flatten_disks(all_disks)
        self.unmapped_cache = []
        u_idx = 1
        for dev in flat_disks:
            d_name = dev.get('name') # Usually mapper name or short kernel name
            d_kname = dev.get('kname') # Kernel name (sda2, dm-0)
            if not d_name or d_name.startswith('loop'):
                continue
            
            # Hide if NAME or KNAME matches a known mapping (1a, dm-0, etc.)
            if d_name in mapped_names or d_kname in mapped_names:
                continue

            dev_path = f"/dev/{d_name}"
            real_dev_path = os.path.realpath(dev_path)
            
            # Hide if this is a known mapped physical device or mapper device path
            if real_dev_path in mapped_real_paths or dev_path in mapped_real_paths:
                continue
            
            # Check for /dev/mapper/ links appearing in dev nodes
            if os.path.exists(f"/dev/mapper/{d_name}"):
                continue

            fstype = dev.get('fstype') or '-'
            label = dev.get('label') or '-'
            
            # Fallback to blkid for more reliable label
            try:
                res_b = run_command(['blkid', '-o', 'value', '-s', 'LABEL', dev_path], sudo=True, check=False)
                if res_b.stdout.strip():
                    label = res_b.stdout.strip()
            except:
                pass

            size = dev.get('size') or '-'
            mountpoint = dev.get('mountpoint') or '-'
            pdp = self.find_persistent_path(d_name, dev.get('wwn'))
            
            self.unmapped_cache.append({
                'dev': dev_path, 'pdp': pdp if pdp != '-' else dev_path,
                'size': size, 'model': dev.get('model'), 'type': dev.get('type')
            })
            
            is_luks_u = "N"
            if fstype == 'crypto_LUKS':
                is_luks_u = "Y"
            else:
                # Check udev for unmapped too
                res_uu = subprocess.run(['udevadm', 'info', '--query=property', f'--name={dev_path}'], capture_output=True, text=True)
                if 'ID_FS_TYPE=crypto_LUKS' in res_uu.stdout:
                    is_luks_u = "Y"

            # Check if this device has any active LUKS children (is it open?)
            is_open = False
            has_mount = mountpoint != '-'
            
            # Look for crypt children in the flattened list
            # A bit inefficient but reliable: find if any device has this one as PKNAME
            for child in flat_disks:
                if child.get('pkname') == d_name or child.get('pkname') == d_kname:
                    if child.get('type') == 'crypt':
                        is_open = True
                        if child.get('mountpoint'):
                            has_mount = True
                            mountpoint = child.get('mountpoint')

            state_u = "UNMOUNTED"
            if has_mount:
                state_u = "MOUNTED"
            elif is_open:
                state_u = "OPEN"
            elif is_luks_u == "Y":
                state_u = "LOCKED"

            unmapped_rows.append({
                'idx': f"[U{u_idx}]", 'name': "-", 'luks': is_luks_u, 'state': state_u,
                'fstype': fstype, 'label': label, 'mount': mountpoint,
                'dev': d_kname if d_kname else d_name, 'size': size, 'path': pdp
            })
            u_idx += 1

        # 3. Calculate Widths and Print
        all_rows = mapped_rows + unmapped_rows
        headers = ["#", "NAME", "LUKS", "STATE", "FSTYPE", "LABEL", "MOUNTPOINT", "DEVICE", "SIZE", "PERSISTENT PATH"]
        keys = ['idx', 'name', 'luks', 'state', 'fstype', 'label', 'mount', 'dev', 'size', 'path']
        widths = {k: len(h) for k, h in zip(keys, headers)}
        
        for row in all_rows:
            for k in keys:
                widths[k] = max(widths[k], len(str(row[k])))
        
        fmt = "  ".join([f"{{:<{widths[k]}}}" for k in keys])

        print(f"\n{Colors.HEADER}--- Disk Management Table ({get_map_file_path()}) ---{Colors.ENDC}")
        print(fmt.format(*headers))
        print("-" * (sum(widths.values()) + len(keys)*2))
        for row in all_rows:
            print(fmt.format(*[row[k] for k in keys]))
        print("")

    def resolve_target(self, target_str, allow_id=True):
        '''Resolves a target string to a physical path.
        Only supports Discovery IDs (U1, [U1]) or existing mapping names.
        '''
        clean = target_str.strip('[]')
        
        # 1. Check Discovery ID
        if allow_id and clean.startswith('U') and clean[1:].isdigit():
            idx = int(clean[1:]) - 1
            if 0 <= idx < len(self.unmapped_cache):
                return self.unmapped_cache[idx]['pdp']
            return None
            
        # 2. Check Mapping Name
        self.mappings = read_luks_map()
        if target_str in self.mappings:
            return self.mappings[target_str]
            
        return None

    def extensive_confirm(self, target_name, destructive=True):
        print(f"\n{Colors.FAIL}{Colors.BOLD}!!! EXTENSIVE CONFIRMATION REQUIRED !!!{Colors.ENDC}")
        if destructive:
            print(f"You are about to perform a DESTRUCTIVE operation on: {Colors.WARNING}{target_name}{Colors.ENDC}")
        else:
            print(f"You are about to perform a HIGH-IMPACT operation on: {Colors.WARNING}{target_name}{Colors.ENDC}")
        print("To proceed, you must answer two math questions correctly.")
        
        for i in range(2):
            a = random.randint(11, 99)
            b = random.randint(11, 99)
            op = random.choice(['+', '-'])
            if op == '+':
                ans = a + b
            else:
                ans = a - b
            
            try:
                user_ans = input(f"Question {i+1}/2: What is {a} {op} {b}? ")
                if not user_ans or int(user_ans) != ans:
                    log("Incorrect answer. Aborting operation.", 'ERROR')
                    return False
            except ValueError:
                log("Invalid input. Aborting operation.", 'ERROR')
                return False
        
        print(f"{Colors.OKGREEN}Verification successful. Proceeding...{Colors.ENDC}")
        return True

    def is_root_disk(self, target_path):
        """Checks if the target path is the root disk or partition."""
        try:
            # Root SOURCE can be a partition (/dev/nvme0n1p1) or a dm-crypt device (/dev/dm-0).
            res = run_command(['findmnt', '-nro', 'SOURCE', '/'], capture_output=True)
            root_source = os.path.realpath(res.stdout.strip())

            target_real = os.path.realpath(target_path)

            def _top_level_disk(dev_path):
                """Return the top-level /dev/<disk> for any block device (partition/dm/crypt), or None."""
                cur = os.path.realpath(dev_path)
                seen = set()
                for _ in range(16):
                    if cur in seen:
                        return None
                    seen.add(cur)

                    if _lsblk_type(cur) == 'disk':
                        return cur

                    res_pk = run_command(['lsblk', '-no', 'PKNAME', cur], check=False)
                    pk = (getattr(res_pk, 'stdout', '') or '').strip()
                    if not pk:
                        return None
                    cur = os.path.realpath(f"/dev/{pk}")
                return None

            root_disk = _top_level_disk(root_source)
            target_disk = _top_level_disk(target_real)

            # Direct match against the root source (e.g., /dev/nvme0n1p1 or /dev/dm-0).
            if target_real == root_source:
                return True

            # Anything that resolves to the same physical disk as '/' counts as "root drive".
            if root_disk and target_disk and target_disk == root_disk:
                return True

        except:
            pass
        return False

    def _block_if_root_drive(self, target_path, operation):
        """Return True (and log) if target_path is on the system root drive."""
        try:
            if self.is_root_disk(target_path):
                log(f"OPERATION BLOCKED: {operation} is not allowed on the system root drive ({target_path}).", 'ERROR')
                return True
        except Exception:
            pass
        return False

    def do_map(self, arg):
        '''Create or modify a persistent mapping: map <name/id> <name>
        
        Usage:
          map [U1] backup    Assigns friendly name to discovery ID (e.g., map U1 backup)
          map 1a backup      Renames an existing mapping (e.g., map 1a backup)
        
        Note: Raw device paths (e.g., /dev/sdb) are NOT allowed.
        
        UNDER THE HOOD:
        1.  Input Resolution: 
            - discovery ID (e.g., [U1]): Resolves the temporary device to its Persistent Device Path (PDP).
            - mapping name (e.g., 1a): Selects an existing mapping for RENAME operations.
        2.  PDP Linking: Extracts the /dev/disk/by-id/ path for the target hardware.
        3.  Conflict Check: Ensures the new friendly name is not already in use.
        4.  Persistence: Writes the [Name <TAB> PDP] pair to diskmap.tsv.
        
        This ensures the disk is recognized correctly regardless of USB port or device node changes.
        '''
        args = arg.split()
        if len(args) != 2:
            log("Usage: map <id/name> <new_name>", 'ERROR')
            return

        target, name = args
        self.mappings = read_luks_map() # Refresh
        
        # 1. Check for Rename (target is a mapping name)
        if target in self.mappings:
            real_target = self.mappings[target]
            log(f"Renaming mapping {target} -> {name}")
            del self.mappings[target]
        else:
            # 2. Check for New Map (target is a discovery ID)
            real_target = self.resolve_target(target)
            if not real_target:
                log(f"Invalid target: '{target}'. Use a Discovery ID (e.g., [U1]) or an existing name.", 'ERROR')
                return
            log(f"Resolved {target} -> {real_target}")
        
        if name in self.mappings:
             log(f"Mapping '{name}' already exists.", 'ERROR')
             return

        # Collision Prevention: Prevent names that look like IDs
        clean_name = name.strip('[]')
        if (clean_name.startswith('U') and clean_name[1:].isdigit()) or clean_name.isdigit():
            log(f"Invalid name: '{name}'. Names cannot be simple numbers or match the 'U1' ID format.", 'ERROR')
            return

        self.mappings[name] = real_target
        save_luks_map(self.mappings)
        log(f"Mapping saved: {name} -> {real_target}")

    def do_unmap(self, arg):
        '''Remove a persistent mapping: unmap <name>
        
        UNDER THE HOOD:
        1.  Resolution: Verifies the mapping exists in diskmap.tsv.
        2.  Removal: Deletes the [Name <TAB> PDP] pair from the internal dictionary.
        3.  Persistence: Re-writes diskmap.tsv with the mapping removed.
        '''
        name = arg.strip()
        if not name:
            log("Usage: unmap <name>", 'ERROR')
            return

        self.mappings = read_luks_map()
        if name not in self.mappings:
            log(f"Unknown mapping: '{name}'", 'ERROR')
            return

        del self.mappings[name]
        save_luks_map(self.mappings)
        log(f"Mapping '{name}' removed successfully.")

    def do_open(self, arg):
        '''Unlock (if encrypted) and mount a disk: open <name>
        
        UNDER THE HOOD:
        1.  Identity Resolution: Looks up the friendly name in diskmap.tsv.
        2.  Hardware Wait: Polls for up to 10 seconds to allow for hardware spin-up/udev events.
        3.  Validation: 
            - Runs 'cryptsetup isLuks' to check for encryption.
            - If NOT encrypted (Plain Disk): 
              * Skips decryption step.
              * Verifies the existence of a valid filesystem.
              * Proceeds to label detection and mounting.
        4.  Decryption (LUKS only):
            - Executes 'passgen' to retrieve the passphrase.
            - Pipes the passphrase into 'cryptsetup open' to create a cleartext device in /dev/mapper/.
        5.  Mounting:
            - Identifies the preferred mountpoint: /media/$USER/<label>.
            - If no hardware label is present, falls back to /media/$USER/<mapping_name>.
            - Note: Prioritizing the label ensures that the disk mounts to the same 
              path used by standard OS automounters for plain removable media.
            - Ensures the directory exists and attaches the device.
        6.  Policy Enforcement: If the disk is already mounted at a non-standard path, 
            it unmounts and remounts it to the preferred path.

        SAFETY NOTE:
        - If your mapping points to a whole disk (e.g. /dev/sda) but the actual LUKS/filesystem
          lives on a partition (e.g. /dev/sda2), diskmgr will only auto-select a partition when
          it is unambiguous (exactly one candidate). Otherwise it will refuse and ask you to map
          the correct partition explicitly.
        '''
        name = arg.strip()
        if not name:
             log("Usage: open <name>", 'ERROR')
             return
             
        self.mappings = read_luks_map()
        if name not in self.mappings:
            log(f"Unknown mapping: {name}. Use 'list' to find Discovery IDs and 'map' them first.", 'ERROR')
            return
            
        src = self.mappings[name]
        
        # Wait for device
        log(f"Waiting for device {src}...")
        for _ in range(50): # 10s wait
            if os.path.exists(src):
                break
            time.sleep(0.2)
            
        if not os.path.exists(src):
            log(f"Device not found: {src}", 'ERROR')
            return
            
        mapped_devnode = os.path.realpath(src)
        if self._block_if_root_drive(mapped_devnode, f"open {name}"):
            return
        devnode = mapped_devnode

        # Check LUKS / filesystem, with safe partition auto-detection when mapping points at a disk.
        is_luks = False
        try:
            res = run_command(['cryptsetup', 'isLuks', devnode], sudo=True, check=False)
            if res.returncode == 0:
                is_luks = True
        except Exception:
            pass

        if not is_luks:
            dev_type = _lsblk_type(devnode)

            # If mapping points at a whole disk, try to locate the real payload on a partition.
            if dev_type == 'disk':
                disk_fs = _lsblk_fstype(devnode)
                if disk_fs:
                    log(f"Device {devnode} is a whole-disk filesystem ({disk_fs}). Proceeding with plain mount.")
                else:
                    parts = _lsblk_partitions(devnode)
                    luks_parts = [p for p in parts if p.get('fstype') == 'crypto_LUKS']
                    fs_parts = [p for p in parts if p.get('fstype') and p.get('fstype') != 'crypto_LUKS']

                    if len(luks_parts) == 1:
                        part_path = os.path.realpath(f"/dev/{luks_parts[0]['name']}")
                        log(f"Mapping '{name}' points to disk {mapped_devnode}, but LUKS was detected on {part_path}. Using the partition for open.")
                        devnode = part_path
                        is_luks = True
                    elif len(luks_parts) > 1:
                        log(f"Mapping '{name}' points to disk {mapped_devnode}, but multiple LUKS partitions were found.", 'ERROR')
                        for p in luks_parts:
                            log(f"  candidate: /dev/{p['name']} (fstype={p.get('fstype')})", 'ERROR')
                        log(f"Please map the correct partition (e.g. map <id> {name}_part) and open that mapping.", 'ERROR')
                        return
                    elif len(fs_parts) == 1:
                        part_path = os.path.realpath(f"/dev/{fs_parts[0]['name']}")
                        log(f"Mapping '{name}' points to disk {mapped_devnode}, but a filesystem was detected on {part_path} ({fs_parts[0].get('fstype')}). Using the partition for open.")
                        devnode = part_path
                    elif len(fs_parts) > 1:
                        log(f"Mapping '{name}' points to disk {mapped_devnode}, but multiple filesystem partitions were found.", 'ERROR')
                        for p in fs_parts:
                            log(f"  candidate: /dev/{p['name']} (fstype={p.get('fstype')})", 'ERROR')
                        log("Please map the correct partition explicitly and open that mapping.", 'ERROR')
                        return
                    else:
                        log(f"Device {devnode} is not a valid LUKS device and has no recognizable filesystem (disk has partitions but none look mountable).", 'ERROR')
                        return

            # Re-check LUKS if we switched from disk -> partition.
            if devnode != mapped_devnode and not is_luks:
                try:
                    res = run_command(['cryptsetup', 'isLuks', devnode], sudo=True, check=False)
                    if res.returncode == 0:
                        is_luks = True
                except Exception:
                    pass

            if not is_luks:
                # Not LUKS, check if it has a filesystem
                fs = _lsblk_fstype(devnode)
                if not fs:
                    log(f"Device {devnode} is not a valid LUKS device and has no recognizable filesystem.", 'ERROR')
                    return
                log(f"Device {devnode} is not LUKS, but has a filesystem ({fs}). Proceeding with plain mount.")

        mapper_path = f"/dev/mapper/{name}"
        target_to_mount = mapper_path

        if is_luks:
            if not os.path.exists(mapper_path):
                log(f"Opening LUKS mapping {name}...")
                # Use passgen
                pg_cmd = subprocess.Popen([PASSGEN_BIN], stdout=subprocess.PIPE, text=True)
                # Pipe to cryptsetup
                try:
                    run_command(
                        ['cryptsetup', 'open', '--key-file', '-', src, name],
                        input_str=pg_cmd.communicate()[0],
                        sudo=True,
                        check=True
                    )
                    log("LUKS opened.")
                except Exception as e:
                    log(f"Failed to open LUKS: {e}", 'ERROR')
                    return
            else:
                log("Mapping already exists.")
        else:
            # Plain disk
            target_to_mount = devnode

        # Detect label for mountpoint
        mount_name = name
        try:
            res_b = run_command(['blkid', '-o', 'value', '-s', 'LABEL', target_to_mount], sudo=True, check=False)
            if res_b.stdout.strip():
                mount_name = res_b.stdout.strip()
        except:
            pass

        # Mount
        mountpoint = f"/media/{os.environ.get('USER', 'root')}/{mount_name}"
        
        # Safety Check: Is this mountpoint already in use by another device?
        res_check = run_command(['findmnt', '-rn', '-M', mountpoint], check=False)
        if res_check.returncode == 0:
            # Check if it's a DIFFERENT device
            res_src = run_command(['findmnt', '-rn', '-M', mountpoint, '-o', 'SOURCE'], capture_output=True)
            current_src = os.path.realpath(res_src.stdout.strip())
            if current_src != os.path.realpath(target_to_mount):
                log(f"MOUNT BLOCKED: Path {mountpoint} is already in use by {current_src}.", 'ERROR')
                return

        if not os.path.exists(mountpoint):
            run_command(['mkdir', '-p', mountpoint], sudo=True)
            
        # Check if mounted (may have multiple mount targets)
        current_targets = find_mount_targets(target_to_mount)

        if not current_targets:
            log(f"Mounting {target_to_mount} to {mountpoint}...")
            run_command(['mount', target_to_mount, mountpoint], sudo=True)
            log("Mounted.")
        elif mountpoint in current_targets:
            extra = [t for t in current_targets if t != mountpoint]
            if extra:
                log(f"Disk is also mounted at {', '.join(extra)}. Unmounting extra mount(s)...")
                for mp in extra:
                    try:
                        run_command(['umount', mp], sudo=True)
                    except Exception as e:
                        log(f"Failed to unmount {mp}: {e}. It may be in use.", 'WARN')
            log(f"Already mounted at {mountpoint}.")
        else:
            log(f"Disk is mounted at {', '.join(current_targets)} (system default). Overriding...")
            try:
                for mp in current_targets:
                    run_command(['umount', mp], sudo=True)
                run_command(['mount', target_to_mount, mountpoint], sudo=True)
                log(f"Successfully moved mount to {mountpoint}")
            except Exception as e:
                log(f"Failed to override mount: {e}. It may be in use.", 'WARN')

    def do_close(self, arg):
        '''Unmount and lock (if encrypted) a disk: close <name>
        
        UNDER THE HOOD:
        1.  Unmounting (Encrypted & Plain): 
            - Flushes all pending writes to the disk (data integrity).
            - Terminates active file handles to the device.
            - Attempts unmount by mapper path (LUKS), source path (Plain), or guessed mountpoint.
        2.  Locking (LUKS only):
            - Commands the kernel to wipe encryption keys from RAM.
            - Removes the virtual cleartext device from /dev/mapper/.
        3.  Audit: Checks and displays remaining active mappings for security awareness.
        '''
        name = arg.strip()
        if not name:
            log("Usage: close <name>", 'ERROR')
            return

        # Never attempt unmount/close operations on the system root drive.
        self.mappings = read_luks_map()
        if name in self.mappings:
            real_src = os.path.realpath(self.mappings[name])
            if self._block_if_root_drive(real_src, f"close {name}"):
                return

        mapper_path = f"/dev/mapper/{name}"
        mount_guess = f"/media/{os.environ.get('USER', 'root')}/{name}"

        run_command(['sudo', '-v']) # Refresh sudo

        # Unmount
        unmounted = False
        unmounted_targets = []
        # 1. Try by mapper
        targets = find_mount_targets(mapper_path)
        if targets:
            for mp in targets:
                log(f"Unmounting {mp}...")
                run_command(['umount', mp], sudo=True)
                unmounted_targets.append(mp)
            unmounted = True
        
        # 2. Try by source path (for non-LUKS)
        if not unmounted:
            self.mappings = read_luks_map()
            if name in self.mappings:
                src = self.mappings[name]
                targets = find_mount_targets(src)
                if targets:
                    for mp in targets:
                        log(f"Unmounting {mp}...")
                        run_command(['umount', mp], sudo=True)
                        unmounted_targets.append(mp)
                    unmounted = True

        # 3. Try by guess
        if not unmounted:
            if run_command(['findmnt', '-rn', '-M', mount_guess], check=False).returncode == 0:
                 log(f"Unmounting {mount_guess}...")
                 run_command(['umount', mount_guess], sudo=True)
                 unmounted_targets.append(mount_guess)
                 unmounted = True

        # Cleanup mountpoint dir(s) (best-effort)
        for mp in unmounted_targets:
            cleanup_mountpoint_dir(mp)
        
        # Close
        if os.path.exists(mapper_path):
            log(f"Closing mapping {name}...")
            run_command(['cryptsetup', 'close', name], sudo=True)
            log("Closed.")
        else:
            log("Mapping not open or already closed.")

    def do_label(self, arg):
        '''Get or set the filesystem label of an OPEN disk: label <name> [new_label]

        UNDER THE HOOD:
        1.  Validation: Verifies that the disk is currently open/unlocked.
        2.  Identification: Queries the filesystem type (ext4, xfs, etc.) via 'lsblk'.
        3.  Labeling:
            - ext4: Uses 'e2label' on the active device.
            - xfs: Requires a temporary unmount, then uses 'xfs_admin -L', then remounts.
        4.  Refresh: Executes 'udevadm trigger' to force tools like 'lsblk' to see the change.
        
        The label is written directly to the disk hardware and persists across different computers.
        '''
        parser = CmdArgumentParser(prog='label', add_help=False)
        parser.add_argument('name')
        parser.add_argument('new_label', nargs='?')
        
        try:
            split_args = shlex.split(arg)
            args = parser.parse_args(split_args)
        except argparse.ArgumentError as e:
            log(str(e), 'ERROR')
            return
        except SystemExit:
            return

        name = args.name
        new_label = args.new_label
        
        # Resolve target device
        target_dev = None
        mapper_path = f"/dev/mapper/{name}"
        
        if os.path.exists(mapper_path):
            target_dev = mapper_path
        else:
            self.mappings = read_luks_map()
            if name in self.mappings:
                src = self.mappings[name]
                if not os.path.exists(src):
                    log(f"Device for mapping '{name}' is missing: {src}", 'ERROR')
                    return
                
                devnode = os.path.realpath(src)
                # Check if it's LUKS
                try:
                    res = run_command(['cryptsetup', 'isLuks', devnode], sudo=True, check=False)
                    if res.returncode == 0:
                        log(f"Mapping '{name}' is LUKS but not open. Please 'open {name}' first.", 'ERROR')
                        return
                    # if returncode != 0, it's not LUKS, which is what we want for a plain disk
                except:
                    pass
                
                target_dev = devnode
            else:
                log(f"Device not found or unknown mapping: {name}", 'ERROR')
                return
             
        if self._block_if_root_drive(target_dev, f"label {name}"):
            return

        # Get info
        try:
            cmd = ['lsblk', '-J', '-o', 'FSTYPE,MOUNTPOINT,LABEL', target_dev]
            res = run_command(cmd, capture_output=True)
            data = json.loads(res.stdout)
            dev = data.get('blockdevices', [{}])[0]
            fstype = dev.get('fstype')
            mountpoint = dev.get('mountpoint')
            current_label = dev.get('label')
        except Exception as e:
            log(f"Failed to inspect device: {e}", 'ERROR')
            return
            
        if not new_label:
            print(f"Label for {name} ({fstype}): {current_label if current_label else '<none>'}")
            return
            
        if current_label == new_label:
            log("Label is already set to that value.")
        else:
            log(f"Changing label: '{current_label}' -> '{new_label}' ({fstype})")
            
            if fstype == 'ext4':
                try:
                    run_command(['e2label', target_dev, new_label], sudo=True)
                    run_command(['udevadm', 'trigger', '--name-match=' + target_dev], sudo=True)
                    run_command(['udevadm', 'settle'], sudo=True)
                    log("Label updated.")
                except:
                    pass # run_command logs error
            elif fstype == 'xfs':
                # XFS requires unmount
                remount_needed = False
                targets = find_mount_targets(target_dev)
                if targets:
                    log(f"XFS requires unmounting to label. Unmounting {', '.join(targets)}...")
                    try:
                        for mp in targets:
                            run_command(['umount', mp], sudo=True)
                        remount_needed = True
                        # Best effort: restore the "primary" mount after relabel.
                        mountpoint = mountpoint or targets[0]
                    except Exception as e:
                        log(f"Failed to unmount: {e}", 'ERROR')
                        return

                try:
                    run_command(['xfs_admin', '-L', new_label, target_dev], sudo=True)
                    run_command(['udevadm', 'trigger', '--name-match=' + target_dev], sudo=True)
                    run_command(['udevadm', 'settle'], sudo=True)
                    log("Label updated.")
                except:
                    pass
                finally:
                    if remount_needed:
                        log(f"Remounting {mountpoint}...")
                        try:
                             run_command(['mount', target_dev, mountpoint], sudo=True)
                             targets = find_mount_targets(target_dev)
                             mountpoint = targets[0] if targets else None
                        except Exception as e:
                            log(f"Failed to remount: {e}. You may need to mount manually.", 'ERROR')

            else:
                log(f"Unsupported filesystem for labeling: {fstype}", 'ERROR')
                return

    def do_remount(self, arg):
        '''Remount an OPEN disk to its label mountpoint: remount <name>

        This fixes "mounted twice" and "data1/data2 suffix" issues by moving the mount
        to the canonical path: /media/$USER/<label>.

        SAFETY RULES:
        - Refuses if the target mountpoint is already mounted by a different device.
        - Refuses if the target directory exists, is not a mountpoint, and is non-empty.
        - Refuses if the filesystem has no LABEL (set one with: label <name> <new_label>).

        UNDER THE HOOD:
        1.  Resolve Device: Uses /dev/mapper/<name> if present, otherwise the mapped source path.
            If the mapping is LUKS and not OPEN, it refuses.
        2.  Identify Label: Reads the filesystem LABEL via blkid.
        3.  Preflight: Validates /media/$USER/<label> is safe to use.
        4.  Unmount: Unmounts all current mount targets for the device (if any).
        5.  Cleanup: Removes empty old mountpoint directories under /media/$USER (best-effort rmdir).
        6.  Mount: Mounts the device at /media/$USER/<label>.
        '''
        parser = CmdArgumentParser(prog='remount', add_help=False)
        parser.add_argument('name')

        try:
            split_args = shlex.split(arg)
            args = parser.parse_args(split_args)
        except argparse.ArgumentError as e:
            log(str(e), 'ERROR')
            return
        except SystemExit:
            return

        name = args.name

        # Resolve target device (must be OPEN if it's LUKS).
        target_dev = None
        mapper_path = f"/dev/mapper/{name}"
        if os.path.exists(mapper_path):
            target_dev = mapper_path
        else:
            self.mappings = read_luks_map()
            if name not in self.mappings:
                log(f"Device not found or unknown mapping: {name}", 'ERROR')
                return

            src = self.mappings[name]
            if not os.path.exists(src):
                log(f"Device for mapping '{name}' is missing: {src}", 'ERROR')
                return

            devnode = os.path.realpath(src)
            try:
                res = run_command(['cryptsetup', 'isLuks', devnode], sudo=True, check=False)
                if res.returncode == 0:
                    log(f"Mapping '{name}' is LUKS but not open. Please 'open {name}' first.", 'ERROR')
                    return
            except:
                pass

            target_dev = devnode

        if self._block_if_root_drive(target_dev, f"remount {name}"):
            return

        # Determine label -> preferred mountpoint.
        label = ""
        try:
            res_b = run_command(['blkid', '-o', 'value', '-s', 'LABEL', target_dev], sudo=True, check=False)
            label = res_b.stdout.strip()
        except:
            pass

        if not label:
            log(f"REMOUNT BLOCKED: {name} has no filesystem label. Set one with: label {name} <new_label>", 'ERROR')
            return

        user = os.environ.get('USER', 'root')
        new_mountpoint = f"/media/{user}/{label}"

        # Safety: is target mountpoint already in use by another device?
        res_check = run_command(['findmnt', '-rn', '-M', new_mountpoint], check=False)
        if res_check.returncode == 0:
            res_src = run_command(['findmnt', '-rn', '-M', new_mountpoint, '-o', 'SOURCE'], check=False)
            current_src = os.path.realpath(res_src.stdout.strip()) if res_src.stdout.strip() else ""
            if current_src and current_src != os.path.realpath(target_dev):
                log(f"REMOUNT BLOCKED: Mountpoint {new_mountpoint} is already in use by {current_src}.", 'ERROR')
                return

        # Figure out where it's mounted now (may be multiple targets).
        current_targets = find_mount_targets(target_dev)

        if new_mountpoint in current_targets:
            extra = [t for t in current_targets if t != new_mountpoint]
            if not extra:
                log(f"Already mounted at {new_mountpoint}.")
                return

            log(f"Disk is also mounted at {', '.join(extra)}. Unmounting extra mount(s)...")
            try:
                for mp in extra:
                    run_command(['umount', mp], sudo=True)
                    cleanup_mountpoint_dir(mp)
            except Exception as e:
                log(f"Failed to unmount extra mount(s): {e}", 'ERROR')
            return

        if current_targets:
            log(f"Unmounting {', '.join(current_targets)} for remount...")
            try:
                for mp in current_targets:
                    run_command(['umount', mp], sudo=True)
                    if mp != new_mountpoint:
                        cleanup_mountpoint_dir(mp)
            except Exception as e:
                log(f"Failed to unmount existing mount(s): {e}", 'ERROR')
                return

        # Target dir exists but isn't a mountpoint; it must be empty to be safe to mount over.
        if os.path.exists(new_mountpoint):
            if run_command(['findmnt', '-rn', '-M', new_mountpoint], check=False).returncode != 0:
                try:
                    if os.path.isdir(new_mountpoint) and os.listdir(new_mountpoint):
                        log(f"REMOUNT BLOCKED: Directory {new_mountpoint} exists and is not empty.", 'ERROR')
                        return
                except Exception as e:
                    log(f"REMOUNT BLOCKED: Unable to inspect {new_mountpoint}: {e}", 'ERROR')
                    return

        log(f"Mounting {target_dev} to {new_mountpoint}...")
        try:
            run_command(['mkdir', '-p', new_mountpoint], sudo=True)
            run_command(['mount', target_dev, new_mountpoint], sudo=True)
            log(f"Remounted successfully at {new_mountpoint}")
        except Exception as e:
            log(f"Failed to mount at {new_mountpoint}: {e}", 'ERROR')

    def do_luks(self, arg):
        '''LUKS encryption management: luks <passwd|backup|restore> [options]
        
        Subcommands:
          passwd <name>           Change the LUKS passphrase.
          backup <name> [file]    Save the LUKS header to a file.
          restore <name> <file>   Restore the LUKS header from a file (Destructive).
        '''
        args = arg.split()
        if not args:
            self.do_help('luks')
            return

        subcmd = args[0]
        sub_args = args[1:]

        if subcmd == 'passwd':
            if not sub_args:
                log("Usage: luks passwd <name>", 'ERROR')
                return
            name = sub_args[0]
            src = self.resolve_target(name, allow_id=False)
            if not src:
                log(f"Unknown mapping: '{name}'.", 'ERROR')
                return
            devnode = os.path.realpath(src)
            if self._block_if_root_drive(devnode, f"luks passwd {name}"):
                return
            res = run_command(['cryptsetup', 'isLuks', devnode], sudo=True, check=False)
            if res.returncode != 0:
                log(f"Device {name} ({devnode}) is not a LUKS encrypted device.", 'ERROR')
                return
            log(f"Starting passphrase change for {name} ({devnode})...")
            try:
                run_command(['cryptsetup', 'luksChangeKey', devnode], sudo=True, capture_output=False)
                log("Passphrase updated successfully.")
            except Exception as e:
                log(f"Failed to change passphrase: {e}", 'ERROR')

        elif subcmd == 'backup':
            if not sub_args:
                log("Usage: luks backup <name> [filename]", 'ERROR')
                return
            name = sub_args[0]
            filename = sub_args[1] if len(sub_args) > 1 else f"{name}.header.bak"
            src = self.resolve_target(name)
            if not src:
                log(f"Unknown target: '{name}'", 'ERROR')
                return
            devnode = os.path.realpath(src)
            if self._block_if_root_drive(devnode, f"luks backup {name}"):
                return
            res = run_command(['cryptsetup', 'isLuks', devnode], sudo=True, check=False)
            if res.returncode != 0:
                log(f"Device {devnode} is not a valid LUKS device.", 'ERROR')
                return
            log(f"Backing up LUKS header from {name} ({devnode}) to {filename}...")
            try:
                run_command(['cryptsetup', 'luksHeaderBackup', devnode, '--header-backup-file', filename], sudo=True)
                log(f"Header backup successful: {filename}")
            except Exception as e:
                log(f"Backup failed: {e}", 'ERROR')

        elif subcmd == 'restore':
            if len(sub_args) < 2:
                log("Usage: luks restore <name> <filename>", 'ERROR')
                return
            name, filename = sub_args[0], sub_args[1]
            if not os.path.exists(filename):
                log(f"Backup file not found: {filename}", 'ERROR')
                return
            src = self.resolve_target(name)
            if not src:
                log(f"Unknown target: '{name}'", 'ERROR')
                return
            devnode = os.path.realpath(src)
            if self._block_if_root_drive(devnode, f"luks restore {name}"):
                return
            log(f"RESTORE WARNING: About to overwrite LUKS header on {name} ({devnode}) using {filename}")
            if not self.extensive_confirm(name):
                return
            run_command(['sudo', '-v'])
            try:
                run_command(['cryptsetup', 'luksHeaderRestore', devnode, '--header-backup-file', filename], sudo=True)
                log("Header restore completed successfully.")
            except Exception as e:
                log(f"Restore failed: {e}", 'ERROR')
        else:
            log(f"Unknown LUKS subcommand: {subcmd}", 'ERROR')
            self.do_help('luks')

    def do_erase(self, arg):
        '''Securely erase a disk: erase <name> [options]
        
        Note: You must 'map' a disk first to give it a name before erasing it.
        
        NUANCES & SAFETY:
        - Whole Disk (sda): 
          Attempts deep hardware-level wipes (NVMe Sanitize, ATA Secure Erase, etc.). 
          Destroys the Partition Table and ALL partitions on the drive.
        - Partition (sda2): 
          Hardware-level wipes are SKIPPED for safety. The script falls back to 
          highly effective software wipes (blkdiscard or dd zero-overwrite).
          ONLY the specified partition is wiped; other partitions remain safe.
        - Mapped Name (1a): 
          Resolves to the physical partition and follows partition-level safety rules.
        
        UNDER THE HOOD:
        1.  Target Resolution: Maps friendly name to a raw block device.
        2.  Destructive Wipe:
            - NVMe: Prioritizes (1) Sanitize Crypto Erase, (2) Sanitize Block Erase, 
              (3) Format Crypto Erase, and (4) Format Block Erase.
            - SSD: Prioritizes (1) PSID Revert, (2) ATA Sanitize, (3) ATA Secure Erase (Enhanced), 
              (4) ATA Secure Erase (Standard), (5) blkdiscard --secure, and (6) blkdiscard.
            - HDD: Prioritizes (1) ATA Sanitize, (2) ATA Secure Erase (Enhanced), 
              (3) ATA Secure Erase (Standard), and (4) Zero Overwrite + Verify.
        3.  Verification: Executes 'udevadm settle' and 'sync' to ensure all operations are committed.
        
        Note: This is a DESTRUCTIVE operation. Solving two math problems is MANDATORY to proceed.

        WARNING: This operation is IRREVERSIBLE.
        '''
        parser = CmdArgumentParser(prog='erase', add_help=False)
        parser.add_argument('target', help='Target name or device')
        
        try:
            split_args = shlex.split(arg)
            args = parser.parse_args(split_args)
        except argparse.ArgumentError as e:
            log(str(e), 'ERROR')
            return
        except SystemExit:
            return

        name = args.target
        real_target = self.resolve_target(name, allow_id=False)
        
        if not real_target:
            log(f"Unknown mapping: '{name}'. You must 'map' a disk before you can erase it.", 'ERROR')
            return
        
        if not os.path.exists(real_target):
            log(f"Target not found: {real_target}", 'ERROR')
            return
            
        real_target = os.path.realpath(real_target)
        log(f"Target resolved: {real_target}")
        
        if self.is_root_disk(real_target):
            log(f"OPERATION BLOCKED: {real_target} is part of the system root drive!", 'ERROR')
            return

        if not self.extensive_confirm(real_target):
            return

        run_command(['sudo', '-v'])
        
        # Unmount dependencies?
        # TODO: checking mounts
        
        if secure_erase_disk(real_target):
            log("Secure erase completed successfully.")
        else:
            log("Secure erase failed.", 'ERROR')

    def do_clone(self, arg):
        '''Clone one disk or partition to another: clone <src_name> <dst_name>
        
        WARNING (DATA DESTRUCTION):
        - This command writes directly to the destination block device (like running ddrescue/dd).
        - The destination is overwritten starting at byte 0. Any existing partition table,
          filesystems, and files on the destination WILL BE DESTROYED.
        - If the destination is larger than the source, bytes beyond the source size are
          not overwritten. Old data may still physically exist there, but it will not be
          referenced by the cloned partition table.
        - diskmgr does NOT unmount the destination for you. Unmount/close it first to
          avoid live corruption.
        - If you need to sanitize the destination, run: erase <dst_name>

        Note: The target disk MUST be the same size or larger than the source.
        
        STEP-BY-STEP PROCESS:
        1.  Resolution: Maps both friendly names to their physical device nodes (PDP).
        2.  Size Validation: Queries 'blockdev --getsize64' for both. Aborts if dst < src.
        3.  Safety Audit: Verifies that the target is NOT the system root drive.
        4.  Confirmation: Requires solving two math problems to authorize data destruction.
        5.  Cloning: Executes ddrescue in two phases:
            - Pass 1: 'ddrescue --force <src> <dst> <mapfile>'
            - Retry:  'ddrescue --force -r3 <src> <dst> <mapfile>'
        6.  Sync: Flushes kernel buffers to ensure all data is physically committed to disk.

        Note: This is a DESTRUCTIVE operation. Solving two math problems is MANDATORY to proceed.

        SCENARIOS:
        - Drive to Drive: 
          Creates a 1:1 bit-perfect clone. The target disk becomes an identical twin, 
          including the Partition Table, UUIDs, and all partitions. 
          Note: If the target is larger, the extra space appears as 'free' at the end.
        - Partition to Partition: 
          Copies the internal data of the source partition into the target partition. 
          Useful for moving a LUKS container or a specific filesystem. 
          Warning: Filesystem UUIDs will be duplicated; avoid mounting both simultaneously.
        - Partition to Drive: 
          The source partition's content is written to the start of the physical disk. 
          This destroys the target's partition table and turns the disk into a 
          "partitionless" volume (e.g., a raw LUKS device).
        - Drive to Partition (DANGEROUS): 
          Writes the source's boot sectors and partition table into the target partition. 
          This usually results in an unreadable "nested" structure.

        CLONING & ENCRYPTION (CRITICAL):
        - Source is LOCKED (e.g., clone sda sdb): 
          Creates a bit-perfect "Encrypted Twin." The destination remains encrypted 
          and requires the same password. (Recommended for backups).
        - Source is OPEN (e.g., clone sda sdb): 
          Copies encrypted data but may capture a "dirty" filesystem state if 
          files are currently being written. (Close before cloning if possible).
        - Source is MAPPER (e.g., clone dm-0 sdb): 
          Performs a "Strip-and-Clone." The destination receives RAW DECRYPTED 
          DATA. The resulting clone will be completely UNENCRYPTED.
        '''
        args = arg.split()
        if len(args) != 2:
            log("Usage: clone <src_name> <dst_name>", 'ERROR')
            return

        src_name, dst_name = args
        src_path = self.resolve_target(src_name, allow_id=False)
        dst_path = self.resolve_target(dst_name, allow_id=False)

        if not src_path:
            log(f"Unknown source mapping: '{src_name}'", 'ERROR')
            return
        if not dst_path:
            log(f"Unknown target mapping: '{dst_name}'", 'ERROR')
            return

        src_real = os.path.realpath(src_path)
        dst_real = os.path.realpath(dst_path)

        if src_real == dst_real:
            log("Source and target are the same device!", 'ERROR')
            return

        if self.is_root_disk(dst_real):
            log(f"OPERATION BLOCKED: {dst_name} ({dst_real}) is the system root drive!", 'ERROR')
            return

        # Compare sizes
        try:
            src_bytes = int(run_command(['sudo', 'blockdev', '--getsize64', src_real], capture_output=True).stdout.strip())
            dst_bytes = int(run_command(['sudo', 'blockdev', '--getsize64', dst_real], capture_output=True).stdout.strip())
            
            if dst_bytes < src_bytes:
                log(f"Target disk is too small! (Source: {src_bytes}B, Target: {dst_bytes}B)", 'ERROR')
                return
        except Exception as e:
            log(f"Failed to verify disk sizes: {e}", 'ERROR')
            return

        ddrescue_bin = _find_tool_or_common_paths('ddrescue', [
            '/usr/bin/ddrescue',
            '/bin/ddrescue',
            '/usr/local/bin/ddrescue',
        ])
        if ddrescue_bin is None:
            log("ddrescue not found. Install 'gddrescue' and retry.", 'ERROR')
            return

        # Prefer logical sector size for reporting failures.
        sector_size = 512
        try:
            res_ss = run_command(['sudo', 'blockdev', '--getss', src_real], capture_output=True, check=False)
            ss = (getattr(res_ss, 'stdout', '') or '').strip()
            if ss.isdigit():
                sector_size = int(ss)
        except Exception:
            sector_size = 512

        # Refuse to run if anything on the destination device tree is mounted.
        # (Whole-disk clone should not proceed if any target partitions are mounted.)
        try:
            res_m = run_command(['lsblk', '-nr', '-o', 'MOUNTPOINT', dst_real], check=False)
            mounts = [ln.strip() for ln in (getattr(res_m, 'stdout', '') or '').splitlines() if ln.strip()]
            if mounts:
                log(f"Target has mounted filesystems ({', '.join(mounts)}). Unmount/close {dst_name} first.", 'ERROR')
                return
        except Exception:
            pass

        # Confirmation
        if not self.extensive_confirm(f"{dst_name} ({dst_real})"):
            return

        run_command(['sudo', '-v'])
        log(f"Cloning {src_name} -> {dst_name}...")
        
        # Perform clone
        try:
            safe_src = re.sub(r'[^A-Za-z0-9_.-]+', '_', src_name)
            safe_dst = re.sub(r'[^A-Za-z0-9_.-]+', '_', dst_name)
            mapdir = Path('/tmp/diskmgr_clone_maps')
            os.makedirs(mapdir, exist_ok=True)
            mapfile = str(mapdir / f"{safe_src}_to_{safe_dst}.map")

            log(f"ddrescue mapfile: {mapfile}")
            # Pass 1: fast clone + mapfile progress.
            cmd = [ddrescue_bin, '--force', src_real, dst_real, mapfile]
            res1 = run_command(cmd, sudo=True, capture_output=False, check=False)

            # Pass 2: retry failed areas (up to 3 times).
            log("ddrescue retry pass: -r3 (retry failed sectors up to 3 times)...")
            cmd_retry = [ddrescue_bin, '--force', '-r3', src_real, dst_real, mapfile]
            res2 = run_command(cmd_retry, sudo=True, capture_output=False, check=False)
            run_command(['sync'], sudo=True, check=False)

            # Report failures based on mapfile after retries.
            failed = _parse_ddrescue_failed_ranges(mapfile, sector_size=sector_size)
            if failed:
                log(f"Unrecovered sectors remain after retries (mapfile: {mapfile}).", 'WARN')
                print(f"\n{Colors.FAIL}{Colors.BOLD}Unrecovered sector ranges:{Colors.ENDC}")
                max_show = 80
                for r in failed[:max_show]:
                    # LBA range shown as [start, end) for clarity.
                    print(f"  LBA [{r['start_lba']}, {r['end_lba']})  count={r['count_lba']}  bytes={r['size_b']}")
                if len(failed) > max_show:
                    print(f"  ... truncated ({len(failed)} ranges total)")
                print(f"\n{Colors.WARNING}Mapfile:{Colors.ENDC} {mapfile}")
            else:
                log("Cloning complete (no unrecovered sectors reported in the ddrescue mapfile).")

            # ddrescue uses bitmask exit codes; preserve them in logs for troubleshooting.
            rc1 = getattr(res1, 'returncode', 0)
            rc2 = getattr(res2, 'returncode', 0)
            if rc1 != 0 or rc2 != 0:
                log(f"ddrescue exit status: pass1={rc1}, retry={rc2} (non-zero can indicate read errors even if output is usable).", 'WARN')
        except Exception as e:
            log(f"Cloning failed: {e}", 'ERROR')

    def do_health(self, arg):
        '''Display SMART health for a mapped disk: health <name>

        Runs smartctl against the underlying DISK device for the mapping.
        - If the mapping points to a partition, diskmgr automatically targets the parent disk.
        - If the disk transport is USB and the device is /dev/sdX, diskmgr uses:
              smartctl -d sat -a /dev/sdX
          (common for USB-SATA bridges).
        '''
        args = arg.split()
        if len(args) != 1:
            log("Usage: health <name>", 'ERROR')
            return

        name = args[0]
        src = self.resolve_target(name, allow_id=False)
        if not src:
            log(f"Unknown mapping: '{name}'", 'ERROR')
            return

        smartctl_bin = _find_tool_or_common_paths('smartctl', [
            '/usr/sbin/smartctl',
            '/sbin/smartctl',
            '/usr/local/sbin/smartctl',
        ])
        if smartctl_bin is None:
            log("smartctl not found. Install 'smartmontools' and retry.", 'ERROR')
            return

        mapped_dev = os.path.realpath(src)

        # Always query SMART on the underlying whole-disk device (SMART is not partition-scoped).
        disk_dev = mapped_dev
        try:
            mapped_name = _sysfs_block_name(mapped_dev)
            disk_name = _sysfs_to_parent_disk_name(mapped_name)
            candidate = os.path.realpath(f"/dev/{disk_name}")
            if os.path.exists(candidate):
                disk_dev = candidate
        except Exception:
            # Fall back to the mapped device (best-effort) if sysfs probing fails.
            disk_dev = mapped_dev

        tran = ""
        try:
            res_tran = run_command(['lsblk', '-no', 'TRAN', disk_dev], check=False)
            tran = (getattr(res_tran, 'stdout', '') or '').strip().lower()
        except Exception:
            tran = ""

        use_sat = (tran == 'usb' and os.path.basename(disk_dev).startswith('sd'))
        cmd = [smartctl_bin, '-a', disk_dev]
        if use_sat:
            cmd = [smartctl_bin, '-d', 'sat', '-a', disk_dev]

        run_command(['sudo', '-v'])

        res = run_command(cmd, sudo=True, capture_output=True, check=False)
        out = (res.stdout or "")
        err = (res.stderr or "")

        # If SAT probing fails on a USB bridge, retry without -d sat as a best-effort fallback.
        if use_sat and res.returncode != 0 and ("Unknown USB bridge" in (out + err) or "Please specify device type" in (out + err)):
            log("smartctl -d sat failed on this USB bridge; retrying without '-d sat'...", 'WARN')
            cmd = [smartctl_bin, '-a', disk_dev]
            res = run_command(cmd, sudo=True, capture_output=True, check=False)
            out = (res.stdout or "")
            err = (res.stderr or "")

        def _find_first(patterns):
            for p in patterns:
                m = re.search(p, out, re.MULTILINE)
                if m:
                    return m.group(1).strip()
            return None

        overall = _find_first([
            r"^SMART overall-health self-assessment test result:\s*(.+)$",
            r"^SMART Health Status:\s*(.+)$",
        ])
        temp = _find_first([
            r"^Current Temperature:\s*([0-9]+)\s*C",
            r"^Temperature:\s*([0-9]+)\s*C",
            r"^\s*194\s+Temperature_Celsius\s+.*\s([0-9]+)\s*$",
            r"^\s*190\s+Airflow_Temperature_Cel\s+.*\s([0-9]+)\s*$",
        ])
        poh = _find_first([
            r"^Power On Hours:\s*([0-9,]+)",
            r"^\s*9\s+Power_On_Hours\s+.*\s([0-9]+)\s*$",
        ])
        realloc = _find_first([r"^\s*5\s+Reallocated_Sector_Ct\s+.*\s([0-9]+)\s*$"])
        pending = _find_first([r"^\s*197\s+Current_Pending_Sector\s+.*\s([0-9]+)\s*$"])
        offline_unc = _find_first([r"^\s*198\s+Offline_Uncorrectable\s+.*\s([0-9]+)\s*$"])

        mode = "-d sat" if ('-d' in cmd) else "-a"
        extra = f"{tran}" if tran else "unknown transport"
        print(f"\n{Colors.HEADER}{Colors.BOLD}=== SMART health: {name} ({extra}, smartctl {mode}) ==={Colors.ENDC}")
        print(f"{Colors.BOLD}Mapped device:{Colors.ENDC} {mapped_dev}")
        if mapped_dev != disk_dev:
            print(f"{Colors.BOLD}SMART queried on:{Colors.ENDC} {disk_dev} (SMART is disk-level, not partition-level)")
        else:
            print(f"{Colors.BOLD}SMART queried on:{Colors.ENDC} {disk_dev}")

        # NVMe drives don't expose ATA SMART attributes/logs in the same format. For NVMe, just show smartctl output.
        is_nvme = (
            os.path.basename(disk_dev).startswith('nvme')
            or ('SMART/Health Information (NVMe Log' in out)
            or ('NVMe Version' in out)
        )
        if is_nvme:
            if out.strip():
                print(out.rstrip())
            if err.strip():
                print(err.rstrip(), file=sys.stderr)

            # Also show nvme-cli smart-log output (often includes vendor-specific counters smartctl doesn't).
            nvme_bin = _find_tool_or_common_paths('nvme', [
                '/usr/sbin/nvme',
                '/sbin/nvme',
                '/usr/local/sbin/nvme',
                '/usr/bin/nvme',
                '/bin/nvme',
            ])
            if nvme_bin is None:
                log("nvme tool not found. Install 'nvme-cli' to show 'nvme smart-log'.", 'WARN')
            else:
                # Prefer the controller device (/dev/nvmeX) when available; fall back to the namespace node.
                nvme_target = disk_dev
                m = re.match(r"^(/dev/nvme[0-9]+)n[0-9]+$", disk_dev)
                if m:
                    ctrl = m.group(1)
                    if os.path.exists(ctrl):
                        nvme_target = ctrl

                print(f"\n{Colors.HEADER}{Colors.BOLD}--- nvme smart-log {nvme_target} ---{Colors.ENDC}")
                res_nv = run_command([nvme_bin, 'smart-log', nvme_target], sudo=True, capture_output=True, check=False)
                nv_out = (res_nv.stdout or "").rstrip()
                nv_err = (res_nv.stderr or "").rstrip()
                if nv_out:
                    print(nv_out)
                if nv_err:
                    print(nv_err, file=sys.stderr)
                if getattr(res_nv, 'returncode', 0) != 0:
                    log(f"nvme smart-log exit status: {res_nv.returncode}", 'WARN')

            if getattr(res, 'returncode', 0) != 0:
                log(f"smartctl exit status: {res.returncode} (non-zero may indicate SMART warnings).", 'WARN')
            return

        def _print_smartctl_info_block():
            """
            Print the smartctl prolog + information section, but not the full attribute tables/logs.
            """
            if not out:
                return
            lines = str(out).splitlines()
            if not lines:
                return
            info_idx = None
            read_idx = None
            for i, line in enumerate(lines):
                if line.strip() == "=== START OF INFORMATION SECTION ===":
                    info_idx = i
                if line.strip() == "=== START OF READ SMART DATA SECTION ===":
                    read_idx = i
                    break
            if info_idx is None:
                return
            end = read_idx if read_idx is not None else len(lines)
            # Print from the beginning through the end of the information section header block.
            for line in lines[:end]:
                print(line)

        def _print_smartctl_remaining_block():
            """
            Print the remainder of the smartctl output (everything after the information section),
            so the user can still see the attribute tables and logs without duplicating the header/info.
            """
            if not out:
                return
            lines = str(out).splitlines()
            if not lines:
                return
            read_idx = None
            for i, line in enumerate(lines):
                if line.strip() == "=== START OF READ SMART DATA SECTION ===":
                    read_idx = i
                    break
            if read_idx is None:
                # Fall back to the entire output if we can't locate the split point.
                print(out.rstrip())
                return
            tail = lines[read_idx:]
            if not tail:
                return
            print(f"{Colors.HEADER}{Colors.BOLD}--- smartctl details ---{Colors.ENDC}")
            for line in tail:
                print(line)

        _print_smartctl_info_block()

        # Time since last SMART error (if the drive has an ATA SMART Error Log).
        poh_row = _parse_smart_attr_row(out, 9)
        cur_poh_h = _first_int_from_text((poh_row or {}).get("raw")) or _first_int_from_text(poh)
        last_err_no, last_err_poh_h = _parse_smart_last_error_poh(out)
        errlog_cnt = _parse_smart_error_log_count(out)
        if last_err_poh_h is not None:
            delta_h = cur_poh_h - last_err_poh_h if (cur_poh_h is not None) else None
            if delta_h is not None and delta_h >= 0:
                delta_days = delta_h / 24.0
                # Color: green if very old, yellow if recent.
                if delta_h < 72:
                    delta_disp = f"{Colors.WARNING}{delta_h}h{Colors.ENDC} (~{delta_days:.1f} days)"
                else:
                    delta_disp = f"{Colors.OKGREEN}{delta_h}h{Colors.ENDC} (~{delta_days:.1f} days)"
                eno = f"Error {last_err_no}" if last_err_no is not None else "Last error"
                print(f"\n{Colors.BOLD}Time since last SMART error:{Colors.ENDC} {delta_disp} ({eno} at POH {last_err_poh_h}h)\n")
            else:
                eno = f"Error {last_err_no}" if last_err_no is not None else "Last error"
                print(f"\n{Colors.BOLD}Last SMART error logged at:{Colors.ENDC} {eno} at POH {last_err_poh_h}h\n")
        elif errlog_cnt == 0:
            print(f"\n{Colors.BOLD}SMART Error Log:{Colors.ENDC} {Colors.OKGREEN}No Errors Logged{Colors.ENDC}\n")

        # Key HDD indicators (earliest -> most severe), with current values if present.
        crc199 = _parse_smart_attr_raw(out, 199)
        cmd188 = _parse_smart_attr_raw(out, 188)
        errlog = errlog_cnt
        pend197 = _parse_smart_attr_raw(out, 197)
        off198 = _parse_smart_attr_raw(out, 198)
        rep187 = _parse_smart_attr_raw(out, 187)
        realloc5 = _parse_smart_attr_raw(out, 5)
        relocev196 = _parse_smart_attr_raw(out, 196)
        long_fail = _parse_smart_long_selftest_failures(out)

        def _to_int(x):
            if x is None:
                return None
            if isinstance(x, int):
                return x
            s = str(x).strip().replace(",", "")
            if s.isdigit() or (s.startswith('-') and s[1:].isdigit()):
                try:
                    return int(s, 10)
                except ValueError:
                    return None
            return None

        def _v(x):
            return x if x is not None else "-"

        def _color_val(kind, val):
            """
            Colorize values: OK=green, WATCH=yellow, BAD=red.
            """
            ival = _to_int(val)
            raw = str(_v(val))

            # Unknown/unavailable
            if val is None:
                return raw

            # Severity rules (conservative; trend is unknown).
            if kind in ("pending", "unc", "reported", "selftest"):
                if ival is not None and ival > 0:
                    return f"{Colors.FAIL}{raw}{Colors.ENDC}"
                return f"{Colors.OKGREEN}{raw}{Colors.ENDC}"
            if kind in ("crc", "timeout", "errlog", "realloc"):
                if ival is not None and ival > 0:
                    return f"{Colors.WARNING}{raw}{Colors.ENDC}"
                return f"{Colors.OKGREEN}{raw}{Colors.ENDC}"
            if kind == "temp":
                if ival is None:
                    return raw
                if ival >= 60:
                    return f"{Colors.FAIL}{raw}{Colors.ENDC}"
                if ival >= 50:
                    return f"{Colors.WARNING}{raw}{Colors.ENDC}"
                return f"{Colors.OKGREEN}{raw}{Colors.ENDC}"
            return raw

        def _color_overall(s):
            if not s:
                return "-"
            t = str(s).strip()
            if "PASSED" in t.upper() or "OK" == t.upper():
                return f"{Colors.OKGREEN}{t}{Colors.ENDC}"
            return f"{Colors.FAIL}{t}{Colors.ENDC}"

        # Fix Seagate SMART 188 formatting: decode packed 48-bit value into real counters.
        cmd188_disp = cmd188
        cmd188_for_color = cmd188
        d188 = None
        if _smartctl_looks_seagate(out):
            d188 = _decode_seagate_command_timeout(cmd188)
            if d188 and d188["raw_int"] > 0xFFFF:
                cmd188_for_color = d188["timeouts"]
                cmd188_disp = f'{d188["timeouts"]} (packed: >5s={d188["gt_5s"]}, >7.5s={d188["gt_7_5s"]}; raw={d188["raw_int"]} {d188["hex"]})'

        # SMART pretext block (fixed ranking 1=most critical -> 24=least critical).
        rows = {
            1: _parse_smart_attr_row(out, 1),
            3: _parse_smart_attr_row(out, 3),
            4: _parse_smart_attr_row(out, 4),
            5: _parse_smart_attr_row(out, 5),
            7: _parse_smart_attr_row(out, 7),
            9: _parse_smart_attr_row(out, 9),
            10: _parse_smart_attr_row(out, 10),
            12: _parse_smart_attr_row(out, 12),
            184: _parse_smart_attr_row(out, 184),
            187: _parse_smart_attr_row(out, 187),
            188: _parse_smart_attr_row(out, 188),
            189: _parse_smart_attr_row(out, 189),
            190: _parse_smart_attr_row(out, 190),
            191: _parse_smart_attr_row(out, 191),
            192: _parse_smart_attr_row(out, 192),
            193: _parse_smart_attr_row(out, 193),
            197: _parse_smart_attr_row(out, 197),
            198: _parse_smart_attr_row(out, 198),
            199: _parse_smart_attr_row(out, 199),
            240: _parse_smart_attr_row(out, 240),
            241: _parse_smart_attr_row(out, 241),
            242: _parse_smart_attr_row(out, 242),
            254: _parse_smart_attr_row(out, 254),
            194: _parse_smart_attr_row(out, 194),
        }

        # Seagate packed SMART 188 decode already applied to cmd188_disp/cmd188_for_color above.
        cmd188_timeouts = _first_int_from_text(cmd188_for_color)

        def _tb_from_lbas(lbas):
            try:
                n = int(lbas)
            except Exception:
                return None
            # 512-byte LBAs
            return (n * 512) / (1024 ** 4)

        def _rank_color(rank):
            if rank <= 5:
                return Colors.FAIL
            if rank <= 15:
                return Colors.WARNING
            if rank <= 21:
                return Colors.OKCYAN
            return Colors.OKGREEN

        def _fmt_smart_value(aid):
            # Single-line value formatting (no multi-line blocks).
            if aid == 188 and _smartctl_looks_seagate(out) and d188 and d188.get("raw_int") is not None and d188["raw_int"] > 0xFFFF:
                v = f"{d188['timeouts']} (decoded: >5s={d188['gt_5s']}, >7.5s={d188['gt_7_5s']}; raw={d188['hex']})"
                return _color_val('timeout', d188['timeouts']) + v[len(str(d188['timeouts'])):]

            row = rows.get(aid)
            if not row:
                return "-"

            raw = row.get("raw", "-")
            if aid in (1, 7) and _smartctl_looks_seagate(out):
                # Common Seagate packing: hi16=error_count, lo32=op_count.
                d = _decode_seagate_hi16_lo32(raw)
                if d:
                    err_col = f"{Colors.OKGREEN}{d['errors']}{Colors.ENDC}" if d["errors"] == 0 else f"{Colors.FAIL}{d['errors']}{Colors.ENDC}"
                    if aid == 1:
                        return f"read_ops={d['ops']:,}, read_errors={err_col} (raw={d['hex']}; VALUE {row.get('value', '-')}, THRESH {row.get('thresh', '-')})"
                    return f"seek_ops={d['ops']:,}, seek_errors={err_col} (raw={d['hex']}; VALUE {row.get('value', '-')}, THRESH {row.get('thresh', '-')})"

            if aid in (5, 1, 7, 10):
                kind = 'realloc' if aid == 5 else ('reported' if aid == 10 else 'errlog')
                if aid == 10:
                    kind = 'reported'
                v = f"{raw} (VALUE {row.get('value', '-')}, THRESH {row.get('thresh', '-')})"
                # Colorize the RAW count where non-zero is meaningful.
                raw_i = _first_int_from_text(raw)
                if aid == 5:
                    return (_color_val('realloc', raw_i if raw_i is not None else raw)) + v[len(str(raw_i if raw_i is not None else raw)):]
                if aid == 10:
                    return (_color_val('reported', raw_i if raw_i is not None else raw)) + v[len(str(raw_i if raw_i is not None else raw)):]
                # 1/7 fall through above for Seagate; otherwise keep as-is (vendor-specific).
                return v
            if aid == 187:
                raw_i = _first_int_from_text(raw)
                v = f"{raw} (VALUE {row.get('value', '-')})"
                return (_color_val('reported', raw_i if raw_i is not None else raw)) + v[len(str(raw_i if raw_i is not None else raw)):]
            if aid == 188:
                raw_i = cmd188_timeouts or _first_int_from_text(raw)
                v = f"{raw} (VALUE {row.get('value', '-')}, WORST {row.get('worst', '-')})"
                return (_color_val('timeout', raw_i if raw_i is not None else raw)) + v[len(str(raw_i if raw_i is not None else raw)):]
            if aid == 3:
                return f"{Colors.OKGREEN}{raw}{Colors.ENDC} (VALUE {row.get('value', '-')})"
            if aid == 193:
                rv = _first_int_from_text(raw)
                if rv is not None:
                    col = Colors.WARNING if rv > 300000 else Colors.OKGREEN
                    return f"{col}{rv:,}{Colors.ENDC} (VALUE {row.get('value', '-')})"
                return f"{Colors.OKGREEN}{raw}{Colors.ENDC} (VALUE {row.get('value', '-')})"
            if aid in (241, 242):
                rv = _first_int_from_text(raw)
                tb = _tb_from_lbas(rv) if rv is not None else None
                if tb is not None:
                    return f"{Colors.OKGREEN}{raw}{Colors.ENDC} (~{tb:.2f} TiB)"
                return f"{Colors.OKGREEN}{raw}{Colors.ENDC}"
            if aid in (197, 198, 184):
                raw_i = _first_int_from_text(raw)
                v = str(raw)
                kind = 'pending' if aid == 197 else 'unc'
                if aid == 184:
                    kind = 'reported'
                return _color_val(kind, raw_i if raw_i is not None else raw)
            if aid in (199, 191, 254, 189, 192, 4, 12, 9, 240):
                raw_i = _first_int_from_text(raw)
                if aid in (199, 191, 254, 189, 192):
                    kind = 'crc' if aid == 199 else 'timeout'
                    # treat these as medium signals when non-zero
                    return _color_val('timeout', raw_i if raw_i is not None else raw)
                return f"{Colors.OKGREEN}{raw}{Colors.ENDC}"
            if aid in (190, 194):
                raw_i = _first_int_from_text(raw)
                if raw_i is None:
                    return f"{Colors.OKGREEN}{raw}{Colors.ENDC}"
                s = str(raw)
                head = str(raw_i)
                # Preserve the full raw field (including Min/Max etc) but color the leading temperature.
                if s.startswith(head):
                    return _color_val('temp', raw_i) + s[len(head):]
                return _color_val('temp', raw_i)
            return f"{Colors.OKGREEN}{raw}{Colors.ENDC}"

        ranked = [
            (1, 187, "Reported_Uncorrect", "Uncorrectable errors reached the OS/host; corruption has already happened."),
            (2, 198, "Offline_Uncorrectable", "Unrecoverable sectors found during offline scan/self-test; physical defects confirmed."),
            (3, 5, "Reallocated_Sector_Ct", "Bad sectors remapped to spares; increasing suggests real media degradation."),
            (4, 197, "Current_Pending_Sector", "Unstable sectors awaiting re-read/rewrite; data at risk until resolved."),
            (5, 184, "End-to-End_Error", "Internal data-path corruption (cache/buffer <-> media); logic/RAM path issues."),
            (6, 10, "Spin_Retry_Count", "Spin-up retries; motor/bearing/power trouble can trap data permanently."),
            (7, 1, "Raw_Read_Error_Rate", "Seagate RAW is often packed; treat normalized VALUE trend as primary. diskmgr shows decoded ops+errors when possible."),
            (8, 7, "Seek_Error_Rate", "Seagate RAW is often packed; treat normalized VALUE trend as primary. diskmgr shows decoded ops+errors when possible."),
            (9, 3, "Spin_Up_Time", "Drive taking longer to become ready; can indicate wear (trend matters)."),
            (10, 188, "Command_Timeout", "Drive commands timing out/hanging; often link/power/bridge issues (trend matters)."),
            (11, 199, "UDMA_CRC_Error_Count", "Interface CRC errors; usually cable/port/bridge noise, not platter damage."),
            (12, 191, "G-Sense_Error_Rate", "Shock/vibration events while running; can cause (not just reflect) damage."),
            (13, 254, "Free_Fall_Sensor", "Recorded free-fall/drop events (history of dangerous handling)."),
            (14, 193, "Load_Cycle_Count", "Head parking cycles; very high counts increase mechanical wear risk."),
            (15, 189, "High_Fly_Writes", "Head flying height anomalies during writes; risk weak writes/data fade."),
            (16, 194, "Temperature_Celsius", "Internal temperature; only critical when extreme (e.g. >60C)."),
            (17, 190, "Airflow_Temperature_Cel", "Alternate temperature sensor; only critical when extreme."),
            (18, 9, "Power_On_Hours", "Lifetime hours; context only (older drives have higher baseline risk)."),
            (19, 4, "Start_Stop_Count", "Spindle start/stop cycles; wear context."),
            (20, 12, "Power_Cycle_Count", "Power cycles; wear/environment context."),
            (21, 192, "Power-Off_Retract_Count", "Emergency retracts (power loss/unplug); environment context."),
            (22, 241, "Total_LBAs_Written", "Cumulative writes; statistics/context."),
            (23, 242, "Total_LBAs_Read", "Cumulative reads; statistics/context."),
            (24, 240, "Head_Flying_Hours", "Head flying time; informational."),
        ]

        zone_headers = {
            1: "The \"Data is Already Gone\" Zone",
            6: "The \"Mechanical Failure Imminent\" Zone",
            11: "The \"Environmental & Usage Stress\" Zone",
            16: "The \"Old Age & Thermometer\" Zone",
            22: "The \"Pure Statistics\" Zone (Least Critical)",
        }

        print(f"\n{Colors.BOLD}SMART attributes ranked strictly from 1 (most critical) to 24 (least critical):{Colors.ENDC}")
        print("Each attribute is printed on one line (ID + name + current value + meaning).")
        for rank, aid, nm, meaning in ranked:
            if rank in zone_headers:
                print(f"\n{Colors.BOLD}{zone_headers[rank]}:{Colors.ENDC}")
            c = _rank_color(rank)
            v = _fmt_smart_value(aid)
            print(f"{c}{rank:2d}.{Colors.ENDC} {Colors.BOLD}{aid}{Colors.ENDC} {nm}: {v} - {meaning}")

        if overall or temp or poh or realloc or pending or offline_unc:
            if overall:
                print(f"\n{Colors.BOLD}Overall:{Colors.ENDC} {_color_overall(overall)}")
            if temp:
                print(f"{Colors.BOLD}Temp:{Colors.ENDC} {_color_val('temp', temp)} C")
            if poh:
                print(f"{Colors.BOLD}Power-on hours:{Colors.ENDC} {poh}")
            if realloc:
                print(f"{Colors.BOLD}Reallocated sectors:{Colors.ENDC} {_color_val('realloc', realloc)}")
            if pending:
                print(f"{Colors.BOLD}Pending sectors:{Colors.ENDC} {_color_val('pending', pending)}")
            if offline_unc:
                print(f"{Colors.BOLD}Offline uncorrectable:{Colors.ENDC} {_color_val('unc', offline_unc)}")
            print("")

        _print_smartctl_remaining_block()
        if err.strip():
            print(err.rstrip(), file=sys.stderr)

        # smartctl uses a bitmask exit code; non-zero can mean "drive has issues" and is still useful output.
        if getattr(res, 'returncode', 0) != 0:
            log(f"smartctl exit status: {res.returncode} (non-zero may indicate SMART warnings).", 'WARN')

    def do_selftest(self, arg):
        '''Start a SMART long self-test: selftest <name>

        Runs smartctl long test against the underlying DISK device for the mapping.
        - If the mapping points to a partition, diskmgr targets the parent disk.
        - If the disk transport is USB and the device is /dev/sdX, diskmgr uses:
              smartctl -d sat -t long /dev/sdX
          (common for USB-SATA bridges).
        '''
        args = arg.split()
        if len(args) != 1:
            log("Usage: selftest <name>", 'ERROR')
            return

        name = args[0]
        src = self.resolve_target(name, allow_id=False)
        if not src:
            log(f"Unknown mapping: '{name}'", 'ERROR')
            return

        smartctl_bin = _find_tool_or_common_paths('smartctl', [
            '/usr/sbin/smartctl',
            '/sbin/smartctl',
            '/usr/local/sbin/smartctl',
        ])
        if smartctl_bin is None:
            log("smartctl not found. Install 'smartmontools' and retry.", 'ERROR')
            return

        mapped_dev = os.path.realpath(src)

        # Always run SMART commands on the underlying whole-disk device (SMART is not partition-scoped).
        disk_dev = mapped_dev
        try:
            mapped_name = _sysfs_block_name(mapped_dev)
            disk_name = _sysfs_to_parent_disk_name(mapped_name)
            candidate = os.path.realpath(f"/dev/{disk_name}")
            if os.path.exists(candidate):
                disk_dev = candidate
        except Exception:
            disk_dev = mapped_dev

        tran = ""
        try:
            res_tran = run_command(['lsblk', '-no', 'TRAN', disk_dev], check=False)
            tran = (getattr(res_tran, 'stdout', '') or '').strip().lower()
        except Exception:
            tran = ""

        use_sat = (tran == 'usb' and os.path.basename(disk_dev).startswith('sd'))
        cmd = [smartctl_bin, '-t', 'long', disk_dev]
        if use_sat:
            cmd = [smartctl_bin, '-d', 'sat', '-t', 'long', disk_dev]

        mode = "-d sat" if ('-d' in cmd) else ""
        print(f"Starting SMART long self-test: {Colors.BOLD}{name}{Colors.ENDC} -> {disk_dev} {mode}".strip())

        # Confirmation (high-impact; not directly destructive but stresses the drive).
        if not self.extensive_confirm(f"selftest {name} ({disk_dev})", destructive=False):
            return

        run_command(['sudo', '-v'])

        res = run_command(cmd, sudo=True, capture_output=True, check=False)
        out = (res.stdout or "").rstrip()
        err = (res.stderr or "").rstrip()

        if out:
            print(out)
        if err:
            print(err, file=sys.stderr)

        if getattr(res, 'returncode', 0) != 0:
            log(f"smartctl exit status: {res.returncode} (non-zero may indicate it could not start the test).", 'WARN')
        else:
            print(f"\nTo check progress/results: run {Colors.BOLD}health {name}{Colors.ENDC} and look at the SMART Self-test log.")

    def get_mountpoint(self, name):
        '''Resolves the current mountpoint for a friendly name.'''
        self.mappings = read_luks_map()
        if name not in self.mappings:
            return None
        
        src = self.mappings[name]
        devnode = os.path.realpath(src)
        
        # Check if it's LUKS and open
        mapper_path = f"/dev/mapper/{name}"
        target = mapper_path if os.path.exists(mapper_path) else devnode
        
        targets = find_mount_targets(target)
        if not targets:
            return None

        preferred = f"/media/{os.environ.get('USER', 'root')}/{name}"
        return preferred if preferred in targets else targets[0]

    def do_sync(self, arg):
        '''Synchronize two mounted disks: sync <secondary_name> <primary_name>
        
        UNDER THE HOOD:
        1.  Validation: Verifies both disks are mapped and currently mounted.
        2.  Confirmation: Requires solving two math problems (DESTRUCTIVE for secondary).
        3.  Execution: Runs 'rsync -avh --delete --progress <primary_mnt>/ <secondary_mnt>/'.
        
        Note: The SECONDARY disk will be modified to match the PRIMARY disk.
        All files on the secondary that do not exist on the primary will be DELETED.
        '''
        args = arg.split()
        if len(args) != 2:
            log("Usage: sync <secondary_name> <primary_name>", 'ERROR')
            return

        secondary, primary = args
        
        sec_mnt = self.get_mountpoint(secondary)
        pri_mnt = self.get_mountpoint(primary)
        
        if not sec_mnt:
            log(f"Secondary disk '{secondary}' is not mounted.", 'ERROR')
            return
        if not pri_mnt:
            log(f"Primary disk '{primary}' is not mounted.", 'ERROR')
            return

        # Block syncing to/from the system root drive.
        try:
            res_s = run_command(['findmnt', '-rn', '-M', sec_mnt, '-o', 'SOURCE'], check=False)
            sec_src = (getattr(res_s, 'stdout', '') or '').strip()
            res_p = run_command(['findmnt', '-rn', '-M', pri_mnt, '-o', 'SOURCE'], check=False)
            pri_src = (getattr(res_p, 'stdout', '') or '').strip()
            if sec_src and self._block_if_root_drive(os.path.realpath(sec_src), f"sync {secondary} {primary}"):
                return
            if pri_src and self._block_if_root_drive(os.path.realpath(pri_src), f"sync {secondary} {primary}"):
                return
        except Exception:
            pass

        print(f"Syncing: {Colors.BOLD}{pri_mnt}/{Colors.ENDC} -> {Colors.WARNING}{sec_mnt}/{Colors.ENDC}")
        
        if not self.extensive_confirm(secondary):
            return

        run_command(['sudo', '-v'])
        log(f"Starting rsync: {primary} -> {secondary}...")
        
        try:
            # Ensure trailing slashes for rsync to sync directory CONTENTS
            src_path = pri_mnt.rstrip('/') + '/'
            dst_path = sec_mnt.rstrip('/') + '/'
            
            cmd = ['rsync', '-avh', '--delete', '--progress', src_path, dst_path]
            # Use sudo if mountpoints are owned by root
            run_command(cmd, sudo=True, capture_output=False)
            log("Sync complete.")
        except Exception as e:
            log(f"Sync failed: {e}", 'ERROR')

    def do_defrag(self, arg):
        '''Defragment a mounted filesystem: defrag <name>

        UNDER THE HOOD:
        1.  Validation: Verifies the disk is mapped and currently mounted.
        2.  Confirmation: Requires solving two math problems.
        3.  Execution:
            - ext4:  runs 'sudo e4defrag <mountpoint>'
            - btrfs: runs 'sudo btrfs filesystem defragment -r <mountpoint>'
        4.  Recording: Stores a timestamp on the mountpoint root via:
              sudo setfattr -n user.last_defrag -v "<date>" <mountpoint>
        '''
        args = arg.split()
        if len(args) != 1:
            log("Usage: defrag <name>", 'ERROR')
            return

        name = args[0]
        mnt = self.get_mountpoint(name)
        if not mnt:
            log(f"Disk '{name}' is not mounted. Run 'open {name}' first.", 'ERROR')
            return

        # Block defrag on the system root drive (writes lots of blocks/metadata).
        try:
            res_src = run_command(['findmnt', '-rn', '-M', mnt, '-o', 'SOURCE'], check=False)
            src = (getattr(res_src, 'stdout', '') or '').strip()
            if src and self._block_if_root_drive(os.path.realpath(src), f"defrag {name}"):
                return
        except Exception:
            pass

        # Determine filesystem type.
        fstype = ""
        try:
            res_fs = run_command(['findmnt', '-rn', '-M', mnt, '-o', 'FSTYPE'], check=False)
            fstype = (getattr(res_fs, 'stdout', '') or '').strip().lower()
        except Exception:
            fstype = ""

        if fstype not in ("ext4", "btrfs"):
            log(f"Defrag not supported for filesystem type '{fstype or 'unknown'}' at {mnt}.", 'ERROR')
            log("Supported: ext4 (e4defrag), btrfs (btrfs filesystem defragment).", 'ERROR')
            return

        # Confirmation (not strictly destructive, but high-impact: rewrites lots of blocks/metadata).
        print(f"Defragmenting: {Colors.BOLD}{mnt}{Colors.ENDC} (fstype={fstype})")
        if not self.extensive_confirm(f"defrag {name} ({mnt})", destructive=False):
            return

        run_command(['sudo', '-v'])

        # Find tools (PATH may not include sbin).
        e4defrag_bin = _find_tool_or_common_paths('e4defrag', [
            '/usr/sbin/e4defrag',
            '/sbin/e4defrag',
            '/usr/local/sbin/e4defrag',
            '/usr/bin/e4defrag',
            '/bin/e4defrag',
        ])
        btrfs_bin = _find_tool_or_common_paths('btrfs', [
            '/usr/sbin/btrfs',
            '/sbin/btrfs',
            '/usr/local/sbin/btrfs',
            '/usr/bin/btrfs',
            '/bin/btrfs',
        ])
        setfattr_bin = _find_tool_or_common_paths('setfattr', [
            '/usr/bin/setfattr',
            '/bin/setfattr',
            '/usr/sbin/setfattr',
            '/sbin/setfattr',
        ])

        try:
            if fstype == "ext4":
                if e4defrag_bin is None:
                    log("e4defrag not found. Install 'e2fsprogs' and retry.", 'ERROR')
                    return
                log(f"Running: {e4defrag_bin} {mnt}")
                run_command([e4defrag_bin, mnt], sudo=True, capture_output=False, check=False)
            else:
                if btrfs_bin is None:
                    log("btrfs not found. Install 'btrfs-progs' and retry.", 'ERROR')
                    return
                log(f"Running: {btrfs_bin} filesystem defragment -r {mnt}")
                run_command([btrfs_bin, 'filesystem', 'defragment', '-r', mnt], sudo=True, capture_output=False, check=False)

            # Record timestamp in xattr on mountpoint root.
            if setfattr_bin is None:
                log("setfattr not found. Install 'attr' and retry to record last_defrag.", 'WARN')
                return

            ds = ""
            try:
                res_date = run_command(['date'], capture_output=True, check=False)
                ds = (getattr(res_date, 'stdout', '') or '').strip()
            except Exception:
                ds = ""
            if not ds:
                ds = datetime.datetime.now().isoformat(sep=' ', timespec='seconds')

            run_command([setfattr_bin, '-n', 'user.last_defrag', '-v', ds, mnt], sudo=True, check=False)
            log(f"Recorded xattr: user.last_defrag={ds} on {mnt}")
        except Exception as e:
            log(f"Defrag failed: {e}", 'ERROR')

    def do_fsdiag(self, arg):
        '''Filesystem diagnostics: fsdiag <name>

        Shows filesystem-specific diagnostic output and local "maintenance" timestamps.

        - ext4:  sudo tune2fs -l <device>
                sudo e4defrag -c <mountpoint>   (fragmentation score)
        - btrfs: sudo btrfs filesystem usage <mountpoint>
        - xfs:   xfs_info <mountpoint>

        Also reads xattrs from the mountpoint root:
          user.last_defrag, user.last_scrub
        '''
        args = arg.split()
        if len(args) != 1:
            log("Usage: fsdiag <name>", 'ERROR')
            return

        name = args[0]
        mnt = self.get_mountpoint(name)
        if not mnt:
            log(f"Disk '{name}' is not mounted. Run 'open {name}' first.", 'ERROR')
            return

        fstype = ""
        src = ""
        try:
            res = run_command(['findmnt', '-rn', '-M', mnt, '-o', 'FSTYPE,SOURCE'], check=False)
            parts = (getattr(res, 'stdout', '') or '').strip().split()
            if len(parts) >= 2:
                fstype = parts[0].strip().lower()
                src = parts[1].strip()
            else:
                # Fallback to separate calls.
                res_fs = run_command(['findmnt', '-rn', '-M', mnt, '-o', 'FSTYPE'], check=False)
                fstype = (getattr(res_fs, 'stdout', '') or '').strip().lower()
                res_src = run_command(['findmnt', '-rn', '-M', mnt, '-o', 'SOURCE'], check=False)
                src = (getattr(res_src, 'stdout', '') or '').strip()
        except Exception:
            pass

        src_real = os.path.realpath(src) if src else ""

        def _read_xattr_text(path, key):
            try:
                v = os.getxattr(path, key)
            except OSError:
                return None
            try:
                if isinstance(v, (bytes, bytearray)):
                    return v.decode('utf-8', errors='replace')
            except Exception:
                return str(v)
            return str(v)

        last_defrag = _read_xattr_text(mnt, 'user.last_defrag')
        last_scrub = _read_xattr_text(mnt, 'user.last_scrub')

        print(f"\n{Colors.HEADER}{Colors.BOLD}=== Filesystem diagnostics: {name} ==={Colors.ENDC}")
        print(f"{Colors.BOLD}Mountpoint:{Colors.ENDC} {mnt}")
        if src_real:
            print(f"{Colors.BOLD}Source:{Colors.ENDC} {src_real}")
        if fstype:
            print(f"{Colors.BOLD}FSType:{Colors.ENDC} {fstype}")
        print(f"{Colors.BOLD}Last defrag:{Colors.ENDC} {last_defrag or '-'}")
        print(f"{Colors.BOLD}Last scrub:{Colors.ENDC} {last_scrub or '-'}")

        run_command(['sudo', '-v'])

        # Compute/print "defragmentation state" (ext4 only, best-effort).
        if fstype == 'ext4':
            e4defrag_bin = _find_tool_or_common_paths('e4defrag', [
                '/usr/sbin/e4defrag',
                '/sbin/e4defrag',
                '/usr/local/sbin/e4defrag',
                '/usr/bin/e4defrag',
                '/bin/e4defrag',
            ])
            if e4defrag_bin:
                res_f = run_command([e4defrag_bin, '-c', mnt], sudo=True, capture_output=True, check=False)
                frag_out = (getattr(res_f, 'stdout', '') or '') + (getattr(res_f, 'stderr', '') or '')
                m = re.search(r"(?im)Fragmentation score(?: is)?\s*([0-9]+)\b", frag_out)
                if m:
                    try:
                        score = int(m.group(1), 10)
                    except ValueError:
                        score = None
                    if score is not None:
                        # e4defrag convention: 0-30: no problem, 31-55: a little, 56+: should defrag.
                        if score <= 30:
                            state = f"{Colors.OKGREEN}GOOD{Colors.ENDC}"
                        elif score <= 55:
                            state = f"{Colors.WARNING}MEDIUM{Colors.ENDC}"
                        else:
                            state = f"{Colors.FAIL}BAD{Colors.ENDC}"
                        print(f"{Colors.BOLD}Defragmentation state:{Colors.ENDC} {state} (ext4 fragmentation score {score})")
                else:
                    print(f"{Colors.BOLD}Defragmentation state:{Colors.ENDC} - (could not parse e4defrag score)")
            else:
                print(f"{Colors.BOLD}Defragmentation state:{Colors.ENDC} - (e4defrag not found)")
        else:
            print(f"{Colors.BOLD}Defragmentation state:{Colors.ENDC} - (no global defrag metric for {fstype or 'unknown'})")

        # Filesystem diagnostics output (read-only).
        if fstype == 'ext4':
            tune2fs_bin = _find_tool_or_common_paths('tune2fs', [
                '/usr/sbin/tune2fs',
                '/sbin/tune2fs',
                '/usr/local/sbin/tune2fs',
                '/usr/bin/tune2fs',
                '/bin/tune2fs',
            ])
            if tune2fs_bin is None:
                log("tune2fs not found. Install 'e2fsprogs' to view ext4 diagnostics.", 'WARN')
                return
            if not src_real:
                log("Could not determine source device for this mount (findmnt SOURCE).", 'ERROR')
                return
            print(f"\n{Colors.HEADER}{Colors.BOLD}--- tune2fs -l {src_real} ---{Colors.ENDC}")
            res = run_command([tune2fs_bin, '-l', src_real], sudo=True, capture_output=True, check=False)
            if (res.stdout or "").strip():
                print(res.stdout.rstrip())
            if (res.stderr or "").strip():
                print(res.stderr.rstrip(), file=sys.stderr)
        elif fstype == 'btrfs':
            btrfs_bin = _find_tool_or_common_paths('btrfs', [
                '/usr/sbin/btrfs',
                '/sbin/btrfs',
                '/usr/local/sbin/btrfs',
                '/usr/bin/btrfs',
                '/bin/btrfs',
            ])
            if btrfs_bin is None:
                log("btrfs not found. Install 'btrfs-progs' to view btrfs diagnostics.", 'WARN')
                return
            print(f"\n{Colors.HEADER}{Colors.BOLD}--- btrfs filesystem usage {mnt} ---{Colors.ENDC}")
            res = run_command([btrfs_bin, 'filesystem', 'usage', mnt], sudo=True, capture_output=True, check=False)
            if (res.stdout or "").strip():
                print(res.stdout.rstrip())
            if (res.stderr or "").strip():
                print(res.stderr.rstrip(), file=sys.stderr)
        elif fstype == 'xfs':
            xfs_info_bin = _find_tool_or_common_paths('xfs_info', [
                '/usr/sbin/xfs_info',
                '/sbin/xfs_info',
                '/usr/local/sbin/xfs_info',
                '/usr/bin/xfs_info',
                '/bin/xfs_info',
            ]) or 'xfs_info'
            print(f"\n{Colors.HEADER}{Colors.BOLD}--- xfs_info {mnt} ---{Colors.ENDC}")
            res = run_command([xfs_info_bin, mnt], sudo=False, capture_output=True, check=False)
            if (res.stdout or "").strip():
                print(res.stdout.rstrip())
            if (res.stderr or "").strip():
                print(res.stderr.rstrip(), file=sys.stderr)
        else:
            log(f"Unsupported or unknown filesystem type '{fstype or 'unknown'}'.", 'ERROR')

    def do_scrub(self, arg):
        '''Scrub a mounted btrfs filesystem: scrub <name>

        UNDER THE HOOD:
        1.  Validation: Verifies the disk is mapped and currently mounted.
        2.  Confirmation: Requires solving two math problems.
        3.  Execution: Runs 'sudo btrfs scrub start -B -R <mountpoint>'.
        4.  Recording: Stores a timestamp on the mountpoint root via:
              sudo setfattr -n user.last_scrub -v "<date>" <mountpoint>
        '''
        args = arg.split()
        if len(args) != 1:
            log("Usage: scrub <name>", 'ERROR')
            return

        name = args[0]
        mnt = self.get_mountpoint(name)
        if not mnt:
            log(f"Disk '{name}' is not mounted. Run 'open {name}' first.", 'ERROR')
            return

        # Determine filesystem type.
        fstype = ""
        try:
            res_fs = run_command(['findmnt', '-rn', '-M', mnt, '-o', 'FSTYPE'], check=False)
            fstype = (getattr(res_fs, 'stdout', '') or '').strip().lower()
        except Exception:
            fstype = ""

        if fstype != "btrfs":
            log(f"Scrub requires btrfs, but {mnt} is '{fstype or 'unknown'}'.", 'ERROR')
            return

        # Block scrub on the system root drive.
        try:
            res_src = run_command(['findmnt', '-rn', '-M', mnt, '-o', 'SOURCE'], check=False)
            src = (getattr(res_src, 'stdout', '') or '').strip()
            if src and self._block_if_root_drive(os.path.realpath(src), f"scrub {name}"):
                return
        except Exception:
            pass

        print(f"Scrubbing: {Colors.BOLD}{mnt}{Colors.ENDC} (fstype=btrfs)")
        if not self.extensive_confirm(f"scrub {name} ({mnt})", destructive=False):
            return

        run_command(['sudo', '-v'])

        btrfs_bin = _find_tool_or_common_paths('btrfs', [
            '/usr/sbin/btrfs',
            '/sbin/btrfs',
            '/usr/local/sbin/btrfs',
            '/usr/bin/btrfs',
            '/bin/btrfs',
        ])
        if btrfs_bin is None:
            log("btrfs not found. Install 'btrfs-progs' and retry.", 'ERROR')
            return

        setfattr_bin = _find_tool_or_common_paths('setfattr', [
            '/usr/bin/setfattr',
            '/bin/setfattr',
            '/usr/sbin/setfattr',
            '/sbin/setfattr',
        ])

        try:
            # -B blocks until complete; -R reports stats.
            run_command([btrfs_bin, 'scrub', 'start', '-B', '-R', mnt], sudo=True, capture_output=False, check=False)

            if setfattr_bin is None:
                log("setfattr not found. Install 'attr' and retry to record last_scrub.", 'WARN')
                return

            ds = ""
            try:
                res_date = run_command(['date'], capture_output=True, check=False)
                ds = (getattr(res_date, 'stdout', '') or '').strip()
            except Exception:
                ds = ""
            if not ds:
                ds = datetime.datetime.now().isoformat(sep=' ', timespec='seconds')

            run_command([setfattr_bin, '-n', 'user.last_scrub', '-v', ds, mnt], sudo=True, check=False)
            log(f"Recorded xattr: user.last_scrub={ds} on {mnt}")
        except Exception as e:
            log(f"Scrub failed: {e}", 'ERROR')

    def do_create(self, arg):
        '''Initialize a disk: create <name> [options]
        
        Note: You must 'map' a disk first to give it a name before initializing it.
        
        NUANCES & SCOPE:
        1. Running create on a Partition (e.g., sda2)
           The Result: Container-in-a-Box.
           The script treats the existing partition as its "entire world."
           - Partitioning: It skips the GPT/MBR step because you've already given it a partition.
           - Encryption: It sets up LUKS directly inside the sda2 boundary.
           - Filesystem: It formats the area inside sda2.
           - The Big Picture: The rest of your disk (like sda1 or sda3) is untouched. 
             You are simply replacing whatever was inside partition #2 with a new encrypted volume.

        2. Running create on a Whole Disk (e.g., sda)
           The Result: Total Takeover.
           The script wipes the slate clean and rebuilds the drive from scratch.
           - Wipe: It deletes the Partition Table (GPT/MBR) at the start of the disk. 
             All existing partitions (sda1, sda2, etc.) are instantly lost.
           - Rebuild:
             * If you didn't use --gpt or --mbr: It formats the Entire Disk as one 
               giant LUKS container (no partition table).
             * If you used --gpt: It creates a fresh GPT table, creates a new 
               partition #1 spanning the whole drive, and puts LUKS inside that.
           - The Big Picture: You lose everything on the physical drive, and it 
             becomes a single, clean encrypted volume.

        3. Using --plain with --gpt or --mbr
           The Result: Standard Unencrypted Disk.
           - Partitioning: Creates a fresh GPT/MBR table and one primary partition.
           - Encryption: Skipped entirely.
           - Mapping: The friendly name in diskmap.tsv points directly to the 
             raw hardware partition (e.g., /dev/disk/by-id/...-part1).
           - The Big Picture: You get a standard unencrypted partitioned volume 
             manageable via diskmgr's persistent naming.
        
        Options:
          --fs <ext4|xfs|btrfs>   Filesystem type (default: ext4)
          --label <label>   Set a different internal filesystem label (other than <name>)
          --plain           Create a non-encrypted disk (skips LUKS)
          --gpt             Create GPT partition table + 1 partition (Whole disk only)
          --mbr             Create MBR partition table + 1 partition (Whole disk only)
        
        UNDER THE HOOD:
        1.  Unmount: Forcefully unmounts any existing partitions on the target.
        2.  Wipe: Executes 'wipefs' to remove old filesystem signatures.
        3.  Partitioning (Optional): Uses 'sgdisk' (GPT) or 'sfdisk' (MBR) to create a single partition.
        4.  LUKS Format (Default):
            - Uses 'passgen' to generate a master key.
            - Runs 'cryptsetup luksFormat' with LUKS2 encryption.
        5.  Filesystem:
            - Formats the cleartext device with ext4, xfs, or btrfs.
            - (ext4 only): Reclaims the 5% reserved space for root using 'tune2fs -m 0'.
        6.  Persistence: Adds the new disk's PDP to diskmap.tsv automatically.

        Note: This is a DESTRUCTIVE operation. Solving two math problems is MANDATORY to proceed.
        '''
        parser = CmdArgumentParser(prog='create', add_help=False)
        parser.add_argument('args', nargs=1, help='<name>')
        parser.add_argument('--fs', default='ext4', choices=['ext4', 'xfs', 'btrfs'])
        parser.add_argument('--label', help='Filesystem label')
        parser.add_argument('--plain', action='store_true', help='No LUKS encryption')
        parser.add_argument('--gpt', action='store_true')
        parser.add_argument('--mbr', action='store_true')

        try:
            split_args = shlex.split(arg)
            args = parser.parse_args(split_args)
        except argparse.ArgumentError as e:
            log(str(e), 'ERROR')
            return
        except SystemExit:
            return

        name = args.args[0]
        target = self.resolve_target(name, allow_id=False)
        if not target:
            log(f"Unknown mapping: '{name}'. You must 'map' a disk before you can initialize it.", 'ERROR')
            return

        # Wait/Verify target existence
        real_target = os.path.realpath(target)
        if not os.path.exists(real_target):
            log(f"Target device not found: {target} (resolved: {real_target})", 'ERROR')
            return
            
        if self.is_root_disk(real_target):
            log(f"OPERATION BLOCKED: {real_target} is part of the system root drive!", 'ERROR')
            return

        log(f"Target: {real_target}")
        log(f"Name: {name}")
        
        # Safety checks
        if not self.extensive_confirm(f"{name} ({real_target})"):
            return

        run_command(['sudo', '-v'])

        # Unmount anything on the disk
        log("Ensuring target is unmounted...")
        # (Simplified unmount check)
        
        # Always do a soft wipe for create
        run_command(['wipefs', '-a', real_target], sudo=True)

        crypt_target = real_target
        
        # Partitioning
        if args.gpt:
            log("Creating GPT partition...")
            run_command(['sgdisk', '--zap-all', real_target], sudo=True)
            run_command(['sgdisk', '-n', f'1:0:0', '-t', '1:8300', '-c', f'1:{name}', real_target], sudo=True)
            run_command(['udevadm', 'settle'], sudo=True)
            # Guess partition name
            if 'nvme' in real_target:
                crypt_target = f"{real_target}p1"
            else:
                crypt_target = f"{real_target}1"
        elif args.mbr:
            log("Creating MBR partition...")
            # using sfdisk scripting
            sfdisk_script = f"label: dos\n{real_target}1 : start=2048, type=83"
            run_command(['sfdisk', '--wipe', 'always', '--wipe-partitions', 'always', real_target], 
                       input_str=sfdisk_script, sudo=True)
            run_command(['udevadm', 'settle'], sudo=True)
             # Guess partition name
            if 'nvme' in real_target:
                crypt_target = f"{real_target}p1"
            else:
                crypt_target = f"{real_target}1"

        if not args.plain:
            # LUKS Format
            log(f"Formatting LUKS on {crypt_target}...")
            pg_cmd = subprocess.Popen([PASSGEN_BIN], stdout=subprocess.PIPE, text=True)
            try:
                run_command(
                    ['cryptsetup', 'luksFormat', '--type', 'luks2', '--batch-mode', '--key-file', '-', crypt_target],
                    input_str=pg_cmd.communicate()[0],
                    sudo=True,
                    check=True
                )
            except Exception as e:
                log(f"LUKS Format failed: {e}", 'ERROR')
                return

            # Open
            log("Opening new LUKS volume...")
            pg_cmd = subprocess.Popen([PASSGEN_BIN], stdout=subprocess.PIPE, text=True)
            run_command(
                ['cryptsetup', 'open', '--key-file', '-', crypt_target, name],
                input_str=pg_cmd.communicate()[0],
                sudo=True,
                check=True
            )
            fs_target = f"/dev/mapper/{name}"
        else:
            fs_target = crypt_target

        # Mkfs
        label = args.label if args.label else name
        log(f"Formatting filesystem {args.fs} (label={label}) on {fs_target}...")
        
        if args.fs == 'ext4':
            run_command(['mkfs.ext4', '-F', '-L', label, fs_target], sudo=True)
            log("Reclaiming 5% reserved space (tune2fs -m 0)...")
            run_command(['tune2fs', '-m', '0', fs_target], sudo=True)
        elif args.fs == 'xfs':
            run_command(['mkfs.xfs', '-f', '-L', label, fs_target], sudo=True)
        elif args.fs == 'btrfs':
            mkfs_btrfs = _find_tool_or_common_paths('mkfs.btrfs', [
                '/usr/sbin/mkfs.btrfs',
                '/sbin/mkfs.btrfs',
                '/usr/local/sbin/mkfs.btrfs',
            ]) or 'mkfs.btrfs'
            # -f required because we just wipefs'ed; still safer to be explicit.
            run_command([mkfs_btrfs, '-f', '-L', label, fs_target], sudo=True)

        # Mount
        mountpoint = f"/media/{os.environ.get('USER', 'root')}/{label}"
        
        # Safety Check: Is this mountpoint already in use by another device?
        res_check = run_command(['findmnt', '-rn', '-M', mountpoint], check=False)
        if res_check.returncode == 0:
            res_src = run_command(['findmnt', '-rn', '-M', mountpoint, '-o', 'SOURCE'], capture_output=True)
            current_src = os.path.realpath(res_src.stdout.strip())
            if current_src != os.path.realpath(fs_target):
                log(f"MOUNT BLOCKED: Path {mountpoint} is already in use by {current_src}.", 'ERROR')
                log("Disk was initialized successfully, but could not be mounted at the preferred path.", 'WARN')
                return

        run_command(['mkdir', '-p', mountpoint], sudo=True)
        run_command(['mount', fs_target, mountpoint], sudo=True)

        # Update map if needed
        self.mappings = read_luks_map()
        if name not in self.mappings:
            stable_path = crypt_target
            # Try to find by-id
            pdp = self.find_persistent_path(os.path.basename(crypt_target))
            if pdp != '-':
                stable_path = pdp
            
            self.mappings[name] = stable_path
            save_luks_map(self.mappings)
            log(f"Added mapping: {name} -> {stable_path}")

        log("Disk initialization complete.")


if __name__ == '__main__':
    try:
        os.chmod(__file__, 0o755)
    except:
        pass
    try:
        DiskMgrShell().cmdloop()
    except KeyboardInterrupt:
        print("\nExiting...")
